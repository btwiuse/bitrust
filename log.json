[
  {
    "hash": "d30f225b492163b14005d5069b7924f3fecf868c",
    "author": "Alex Crichton",
    "date": 1422996083,
    "message": "std: Remove `iter::ByRef` and generalize impls\n\nThis removes the `ByRef` iterator adaptor to stay in line with the changes to\n`std::io`. The `by_ref` method instead just returns `&mut Self`.\n\nThis also removes the implementation of `Iterator for &mut Iterator` and instead\ngeneralizes it to `Iterator for &mut I` where `I: Iterator + ?Sized`. The\n`Box<I>` implementations were also updated.\n\nThis is a breaking change due to the removal of the `std::iter::ByRef` type. All\nmentions of `ByRef<'a, T>` should be replaced with `&mut T` to migrate forward.\n\n[breaking-change]"
  },
  {
    "hash": "8550bf74c1149eb54fc568bb53b78fd2b6caec98",
    "author": "Alex Crichton",
    "date": 1423006553,
    "message": "rollup merge of #21759: aturon/new-path\n\nThis PR implements [path reform](https://github.com/rust-lang/rfcs/pull/474), and motivation and details for the change can be found there.\n\nFor convenience, the old path API is being kept as `old_path` for the time being. Updating after this PR is just a matter of changing imports to `old_path` (which is likely not needed, since the prelude entries still export the old path API).\n\nThis initial PR does not include additional normalization or platform-specific path extensions. These will be done in follow up commits or PRs.\n\n[breaking-change]\n\nCloses #20034\nCloses #12056\nCloses #11594\nCloses #14028\nCloses #14049\nCloses #10035"
  },
  {
    "hash": "3e39f0bc0e96f76610104918edaa5912f4f352df",
    "author": "Aaron Turon",
    "date": 1423002882,
    "message": "Rename std::path to std::old_path\n\nAs part of [RFC 474](https://github.com/rust-lang/rfcs/pull/474), this\ncommit renames `std::path` to `std::old_path`, leaving the existing path\nAPI in place to ease migration to the new one. Updating should be as\nsimple as adjusting imports, and the prelude still maps to the old path\nAPIs for now.\n\n[breaking-change]"
  },
  {
    "hash": "99b2bd4bfa332c5a723114d09e8bb74d5a0c7376",
    "author": "Alex Crichton",
    "date": 1422903676,
    "message": "rollup merge of #21842: alexcrichton/issue-21839\n\nNow that associated types are fully implemented the iterator adaptors only need\ntype parameters which are associated with actual storage. All other type\nparameters can either be derived from these (e.g. they are an associated type)\nor can be bare on the `impl` block itself.\n\nThis is a breaking change due to the removal of type parameters on these\niterator adaptors, but code can fairly easily migrate by just deleting the\nrelevant type parameters for each adaptor. Other behavior should not be\naffected.\n\nCloses #21839\n[breaking-change]"
  },
  {
    "hash": "0e4448409ef61c703b98e4c5b2fd99447308942d",
    "author": "Alex Crichton",
    "date": 1422824723,
    "message": "std: Remove extra type params on iter adaptors\n\nNow that associated types are fully implemented the iterator adaptors only need\ntype parameters which are associated with actual storage. All other type\nparameters can either be derived from these (e.g. they are an associated type)\nor can be bare on the `impl` block itself.\n\nThis is a breaking change due to the removal of type parameters on these\niterator adaptors, but code can fairly easily migrate by just deleting the\nrelevant type parameters for each adaptor. Other behavior should not be\naffected.\n\nCloses #21839\n[breaking-change]"
  },
  {
    "hash": "70ed3a48dfa301c5bb56de3e0a7c25214539b83c",
    "author": "Alex Crichton",
    "date": 1422817695,
    "message": "std: Add a new `env` module\n\nThis is an implementation of [RFC 578][rfc] which adds a new `std::env` module\nto replace most of the functionality in the current `std::os` module. More\ndetails can be found in the RFC itself, but as a summary the following methods\nhave all been deprecated:\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/578\n\n* `os::args_as_bytes`   => `env::args`\n* `os::args`            => `env::args`\n* `os::consts`          => `env::consts`\n* `os::dll_filename`    => no replacement, use `env::consts` directly\n* `os::page_size`       => `env::page_size`\n* `os::make_absolute`   => use `env::current_dir` + `join` instead\n* `os::getcwd`          => `env::current_dir`\n* `os::change_dir`      => `env::set_current_dir`\n* `os::homedir`         => `env::home_dir`\n* `os::tmpdir`          => `env::temp_dir`\n* `os::join_paths`      => `env::join_paths`\n* `os::split_paths`     => `env::split_paths`\n* `os::self_exe_name`   => `env::current_exe`\n* `os::self_exe_path`   => use `env::current_exe` + `pop`\n* `os::set_exit_status` => `env::set_exit_status`\n* `os::get_exit_status` => `env::get_exit_status`\n* `os::env`             => `env::vars`\n* `os::env_as_bytes`    => `env::vars`\n* `os::getenv`          => `env::var` or `env::var_string`\n* `os::getenv_as_bytes` => `env::var`\n* `os::setenv`          => `env::set_var`\n* `os::unsetenv`        => `env::remove_var`\n\nMany function signatures have also been tweaked for various purposes, but the\nmain changes were:\n\n* `Vec`-returning APIs now all return iterators instead\n* All APIs are now centered around `OsString` instead of `Vec<u8>` or `String`.\n  There is currently on convenience API, `env::var_string`, which can be used to\n  get the value of an environment variable as a unicode `String`.\n\nAll old APIs are `#[deprecated]` in-place and will remain for some time to allow\nfor migrations. The semantics of the APIs have been tweaked slightly with regard\nto dealing with invalid unicode (panic instead of replacement).\n\nThe new `std::env` module is all contained within the `env` feature, so crates\nmust add the following to access the new APIs:\n\n    #![feature(env)]\n\n[breaking-change]"
  },
  {
    "hash": "f1f9cb705df95171fce4e575374c959509e58dea",
    "author": "bors",
    "date": 1422785691,
    "message": "Auto merge of #21809 - japaric:no-copy, r=alexcrichton\n\nRemoves `Copy` from `ops::Range` (`a..b`) and `ops::RangeFrom` (`a..`)\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nI forgot about these two in #20790, this PR also adds `Clone` to the `Peekable` adapter which used to be `Copy`able.\r\n\r\nr? @nikomatsakis or anyone"
  },
  {
    "hash": "62273575139a80c2b208a3a27e0c2392b1425be6",
    "author": "Alex Crichton",
    "date": 1422638516,
    "message": "std: Stabilize the std::fmt module\n\nThis commit performs a final stabilization pass over the std::fmt module,\nmarking all necessary APIs as stable. One of the more interesting aspects of\nthis module is that it exposes a good deal of its runtime representation to the\noutside world in order for `format_args!` to be able to construct the format\nstrings. Instead of hacking the compiler to assume that these items are stable,\nthis commit instead lays out a story for the stabilization and evolution of\nthese APIs.\n\nThere are three primary details used by the `format_args!` macro:\n\n1. `Arguments` - an opaque package of a \"compiled format string\". This structure\n   is passed around and the `write` function is the source of truth for\n   transforming a compiled format string into a string at runtime. This must be\n   able to be constructed in stable code.\n\n2. `Argument` - an opaque structure representing an argument to a format string.\n   This is *almost* a trait object as it's just a pointer/function pair, but due\n   to the function originating from one of many traits, it's not actually a\n   trait object. Like `Arguments`, this must be constructed from stable code.\n\n3. `fmt::rt` - this module contains the runtime type definitions primarily for\n   the `rt::Argument` structure. Whenever an argument is formatted with\n   nonstandard flags, a corresponding `rt::Argument` is generated describing how\n   the argument is being formatted. This can be used to construct an\n   `Arguments`.\n\nThe primary interface to `std::fmt` is the `Arguments` structure, and as such\nthis type name is stabilize as-is today. It is expected for libraries to pass\naround an `Arguments` structure to represent a pending formatted computation.\n\nThe remaining portions are largely \"cruft\" which would rather not be stabilized,\nbut due to the stability checks they must be. As a result, almost all pieces\nhave been renamed to represent that they are \"version 1\" of the formatting\nrepresentation. The theory is that at a later date if we change the\nrepresentation of these types we can add new definitions called \"version 2\" and\ncorresponding constructors for `Arguments`.\n\nOne of the other remaining large questions about the fmt module were how the\npending I/O reform would affect the signatures of methods in the module. Due to\n[RFC 526][rfc], however, the writers of fmt are now incompatible with the\nwriters of io, so this question has largely been solved. As a result the\ninterfaces are largely stabilized as-is today.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0526-fmt-text-writer.md\n\nSpecifically, the following changes were made:\n\n* The contents of `fmt::rt` were all moved under `fmt::rt::v1`\n* `fmt::rt` is stable\n* `fmt::rt::v1` is stable\n* `Error` is stable\n* `Writer` is stable\n* `Writer::write_str` is stable\n* `Writer::write_fmt` is stable\n* `Formatter` is stable\n* `Argument` has been renamed to `ArgumentV1` and is stable\n* `ArgumentV1::new` is stable\n* `ArgumentV1::from_uint` is stable\n* `Arguments::new_v1` is stable (renamed from `new`)\n* `Arguments::new_v1_formatted` is stable (renamed from `with_placeholders`)\n* All formatting traits are now stable, as well as the `fmt` method.\n* `fmt::write` is stable\n* `fmt::format` is stable\n* `Formatter::pad_integral` is stable\n* `Formatter::pad` is stable\n* `Formatter::write_str` is stable\n* `Formatter::write_fmt` is stable\n* Some assorted top level items which were only used by `format_args!` were\n  removed in favor of static functions on `ArgumentV1` as well.\n* The formatting-flag-accessing methods remain unstable\n\nWithin the contents of the `fmt::rt::v1` module, the following actions were\ntaken:\n\n* Reexports of all enum variants were removed\n* All prefixes on enum variants were removed\n* A few miscellaneous enum variants were renamed\n* Otherwise all structs, fields, and variants were marked stable.\n\nIn addition to these actions in the `std::fmt` module, many implementations of\n`Show` and `String` were stabilized as well.\n\nIn some other modules:\n\n* `ToString` is now stable\n* `ToString::to_string` is now stable\n* `Vec` no longer implements `fmt::Writer` (this has moved to `String`)\n\nThis is a breaking change due to all of the changes to the `fmt::rt` module, but\nthis likely will not have much impact on existing programs.\n\nCloses #20661\n[breaking-change]"
  },
  {
    "hash": "341e858bd882061b823dac236fd718d473f8ab2e",
    "author": "Alex Crichton",
    "date": 1422648164,
    "message": "rollup merge of #20790: japaric/for-loops\n\nAs per [RFC #235][rfc], you can now do:\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0235-collections-conventions.md#intoiterator-and-iterable\n\n``` rust\nlet mut v = vec![1];\n\n// iterate over immutable references\nfor x in &v {\n    assert_eq!(x, &1);\n}\n\n// iterate over mutable references\nfor x in &mut v {\n    assert_eq!(x, &mut 1);\n}\n\n// iterate over values, this consumes `v`\nfor x in v {\n    assert_eq!(x, 1);\n}\n```\n\n[breaking-change]s\n\nFor loops now \"consume\" (move) the iterator, this breaks iterating over mutable references to iterators, and also breaks multiple iterations over the same iterator:\n\n``` rust\nfn foo(mut it: &mut Iter) {  // `Iter` implements `Iterator`\n    for x in it { .. }  //~ error: `&mut Iter` doesn't implement Iterator\n}\n\nfn bar() {\n    for x in it { .. }  //~ note: `it` moved here\n    for x in it { .. }  //~ error: `it` has been moved\n}\n```\n\nBoth cases can be fixed using the `by_ref()` adapter to create an iterator from the mutable reference:\n\n``` rust\nfn foo(mut it: &mut Iter) {\n    for x in it.by_ref() { .. }\n}\n\nfn bar() {\n    for x in it.by_ref() { .. }\n    for x in it { .. }\n}\n```\n\nThis PR also makes iterator non-implicitly copyable, as this was source of subtle bugs in the libraries. You can still use `clone()` to explictly copy the iterator.\n\nFinally, since the for loops are implemented in the frontend and use global paths to `IntoIterator`, `Iterator` and `Option` variants, users of the `core` crate will have to use add an `std` module to the root of their crate to be able to use for loops:\n\n``` rust\n#![no_std]\n\nextern crate core;\n\nfn main() {\n    for x in 0..10 {}\n}\n\n#[doc(hidden)]\nmod std {\n    // these imports are needed to use for-loops\n    pub use core::iter;\n    pub use core::option;\n}\n```\n\n---\n\nr? @nikomatsakis @aturon\ncc #18424\ncloses #18045"
  },
  {
    "hash": "a9d465fec902588b71937de96e66d160d2adebf5",
    "author": "Nick Cameron",
    "date": 1422572420,
    "message": "Use absolute path to FullRange, rather than assuming it is in the prelude\n\nCloses #21263\n\n[breaking-change]\n\nIf you are using `core::ops::FullRange` you should change to using `core::ops::RangeFull`"
  },
  {
    "hash": "d77f6d5366b330f9c2061cad0d3ff638c9cc05b7",
    "author": "bors",
    "date": 1422356846,
    "message": "Auto merge of #21657 - pnkfelix:block-remainder-extents, r=nikomatsakis\n\n Add `CodeExtent::Remainder` variant; pre-req for new scoping/drop rules.\r\n\r\nThis new enum variant introduces finer-grain code extents, i.e. we now track that a binding lives only for a suffix of a block, and (importantly) will be dropped when it goes out of scope *before* the bindings that occurred earlier in the block.\r\n\r\nBoth of these notions are neatly captured by marking the block (and each suffix) as an enclosing scope of the next suffix beneath it.\r\n\r\nThis is work that is part of the foundation for issue #8861.\r\n\r\n(It actually has been seen in earlier posted pull requests, in particular #21022; I have just factored it out into its own PR to ease my own near-future rebasing, and also get people used to the new rules.)\r\n\r\n----\r\n\r\nThese finer grained scopes do mean that some code is newly rejected by `rustc`; for example:\r\n\r\n```rust\r\nlet mut map : HashMap<u8, &u8> = HashMap::new();\r\nlet tmp = Box::new(2);\r\nmap.insert(43, &*tmp);\r\n```\r\n\r\nThis will now fail to compile with a message that `*tmp` does not live long enough, because the scope of `tmp` is now strictly smaller than\r\nthat of `map`, and the use of `&u8` in map's type requires that the borrowed references are all to data that live at least as long as the map.\r\n\r\nThe usual fix for a case like this is to move the binding for `tmp` up above that of `map`; note that you can still leave the initialization in the original spot, like so:\r\n\r\n```rust\r\nlet tmp;\r\nlet mut map : HashMap<u8, &u8> = HashMap::new();\r\ntmp = box 2;\r\nmap.insert(43, &*tmp);\r\n```\r\n\r\nSimilarly, one can encounter an analogous situation with `Vec`: one would need to rewrite:\r\n\r\n```rust\r\nlet mut vec = Vec::new();\r\nlet tmp = 'c';\r\nvec.push(&tmp);\r\n```\r\n\r\nas:\r\n\r\n```rust\r\nlet tmp;\r\nlet mut vec = Vec::new();\r\ntmp = 'c';\r\nvec.push(&tmp);\r\n```\r\n\r\n----\r\n\r\nIn some corner cases, it does not suffice to reorder the bindings; in particular, when the types for both bindings need to reflect exactly the *same* code extent, and a parent/child relationship between them does not work.\r\n\r\nIn pnkfelix's experience this has arisen most often when mixing uses of cyclic data structures while also allowing a lifetime parameter `'a` to flow into a type parameter context where the type is *invariant* with respect to the type parameter. An important instance of this is `arena::TypedArena<T>`, which is invariant with respect to `T`.\r\n\r\n(The reason that variance is relevant is this: *if* `TypedArena` were covariant with respect to its type parameter, then we could assign it\r\nthe longer lifetime when it is initialized, and then convert it to a subtype (via covariance) with a shorter lifetime when necessary.  But `TypedArena` is invariant with respect to its type parameter, and thus if `S` is a subtype of `T` (in particular, if `S` has a lifetime parameter that is shorter than that of `T`), then a `TypedArena<S>` is unrelated to `TypedArena<T>`.)\r\n\r\nConcretely, consider code like this:\r\n\r\n```rust\r\nstruct Node<'a> { sibling: Option<&'a Node<'a>> }\r\nstruct Context<'a> {\r\n    // because of this field, `Context<'a>` is invariant with respect to `'a`.\r\n    arena: &'a TypedArena<Node<'a>>,\r\n    ...\r\n}\r\nfn new_ctxt<'a>(arena: &'a TypedArena<Node<'a>>) -> Context<'a> { ... }\r\nfn use_ctxt<'a>(fcx: &'a Context<'a>) { ... }\r\n\r\nlet arena = TypedArena::new();\r\nlet ctxt = new_ctxt(&arena);\r\n\r\nuse_ctxt(&ctxt);\r\n```\r\n\r\nIn these situations, if you try to introduce two bindings via two distinct `let` statements, each is (with this commit) assigned a distinct extent, and the region inference system cannot find a single region to assign to the lifetime `'a` that works for both of the bindings. So you get an error that `ctxt` does not live long enough; but moving its binding up above that of `arena` just shifts the error so now the compiler complains that `arena` does not live long enough.\r\n\r\n * SO: What to do? The easiest fix in this case is to ensure that the two bindings *do* get assigned the same static extent, by stuffing both\r\nbindings into the same let statement, like so:\r\n\r\n```rust\r\nlet (arena, ctxt): (TypedArena, Context);\r\narena = TypedArena::new();\r\nctxt = new_ctxt(&arena);\r\n\r\nuse_ctxt(&ctxt);\r\n```\r\n\r\n----\r\n\r\nDue to the new code restrictions outlined above, this is a ...\r\n\r\n[breaking-change]"
  },
  {
    "hash": "d6bf04a22e78afbe62e9d81e3578418f420123bc",
    "author": "Felix S. Klock II",
    "date": 1422350812,
    "message": "Add `CodeExtent::Remainder` variant; pre-req for new scoping/drop rules.\n\nThis new variant introduces finer-grain code extents, i.e. we now\ntrack that a binding lives only for a suffix of a block, and\n(importantly) will be dropped when it goes out of scope *before* the\nbindings that occurred earlier in the block.\n\nBoth of these notions are neatly captured by marking the block (and\neach suffix) as an enclosing scope of the next suffix beneath it.\n\nThis is work that is part of the foundation for issue #8861.\n\n(It actually has been seen in earlier posted pull requests; I have\njust factored it out into its own PR to ease my own rebasing.)\n\n----\n\nThese finer grained scopes do mean that some code is newly rejected by\n`rustc`; for example:\n\n```rust\nlet mut map : HashMap<u8, &u8> = HashMap::new();\nlet tmp = Box::new(2);\nmap.insert(43, &*tmp);\n```\n\nThis will now fail to compile with a message that `*tmp` does not live\nlong enough, because the scope of `tmp` is now strictly smaller than\nthat of `map`, and the use of `&u8` in map's type requires that the\nborrowed references are all to data that live at least as long as the\nmap.\n\nThe usual fix for a case like this is to move the binding for `tmp`\nup above that of `map`; note that you can still leave the initialization\nin the original spot, like so:\n\n```rust\nlet tmp;\nlet mut map : HashMap<u8, &u8> = HashMap::new();\ntmp = box 2;\nmap.insert(43, &*tmp);\n```\n\nSimilarly, one can encounter an analogous situation with `Vec`: one\nwould need to rewrite:\n\n```rust\nlet mut vec = Vec::new();\nlet tmp = 'c';\nvec.push(&tmp);\n```\n\nas:\n\n```\nlet tmp;\nlet mut vec = Vec::new();\ntmp = 'c';\nvec.push(&tmp);\n```\n\n----\n\nIn some corner cases, it does not suffice to reorder the bindings; in\nparticular, when the types for both bindings need to reflect exactly\nthe *same* code extent, and a parent/child relationship between them\ndoes not work.\n\nIn pnkfelix's experience this has arisen most often when mixing uses\nof cyclic data structures while also allowing a lifetime parameter\n`'a` to flow into a type parameter context where the type is\n*invariant* with respect to the type parameter. An important instance\nof this is `arena::TypedArena<T>`, which is invariant with respect\nto `T`.\n\n(The reason that variance is relevant is this: *if* `TypedArena` were\ncovariant with respect to its type parameter, then we could assign it\nthe longer lifetime when it is initialized, and then convert it to a\nsubtype (via covariance) with a shorter lifetime when necessary.  But\n`TypedArena` is invariant with respect to its type parameter, and thus\nif `S` is a subtype of `T` (in particular, if `S` has a lifetime\nparameter that is shorter than that of `T`), then a `TypedArena<S>` is\nunrelated to `TypedArena<T>`.)\n\nConcretely, consider code like this:\n\n```rust\nstruct Node<'a> { sibling: Option<&'a Node<'a>> }\nstruct Context<'a> {\n    // because of this field, `Context<'a>` is invariant with respect to `'a`.\n    arena: &'a TypedArena<Node<'a>>,\n    ...\n}\nfn new_ctxt<'a>(arena: &'a TypedArena<Node<'a>>) -> Context<'a> { ... }\nfn use_ctxt<'a>(fcx: &'a Context<'a>) { ... }\n\nlet arena = TypedArena::new();\nlet ctxt = new_ctxt(&arena);\n\nuse_ctxt(&ctxt);\n```\n\nIn these situations, if you try to introduce two bindings via two\ndistinct `let` statements, each is (with this commit) assigned a\ndistinct extent, and the region inference system cannot find a single\nregion to assign to the lifetime `'a` that works for both of the\nbindings. So you get an error that `ctxt` does not live long enough;\nbut moving its binding up above that of `arena` just shifts the error\nso now the compiler complains that `arena` does not live long enough.\n\nSO: What to do? The easiest fix in this case is to ensure that the two\nbindings *do* get assigned the same static extent, by stuffing both\nbindings into the same let statement, like so:\n\n```rust\nlet (arena, ctxt): (TypedArena, Context);\narena = TypedArena::new();\nctxt = new_ctxt(&arena);\n\nuse_ctxt(&ctxt);\n```\n\nDue to the new code rejections outlined above, this is a ...\n\n[breaking-change]"
  },
  {
    "hash": "a6a6fadbb97268d2b3e47649d91053fbb4827266",
    "author": "bors",
    "date": 1422326769,
    "message": "Auto merge of #21543 - alexcrichton:old-io, r=aturon\n\nIn preparation for the I/O rejuvination of the standard library, this commit\r\nrenames the current `io` module to `old_io` in order to make room for the new\r\nI/O modules. It is expected that the I/O RFCs will land incrementally over time\r\ninstead of all at once, and this provides a fresh clean path for new modules to\r\nenter into as well as guaranteeing that all old infrastructure will remain in\r\nplace for some time.\r\n\r\nAs each `old_io` module is replaced it will be deprecated in-place for new\r\nstructures in `std::{io, fs, net}` (as appropriate).\r\n\r\nThis commit does *not* leave a reexport of `old_io as io` as the deprecation\r\nlint does not currently warn on this form of use. This is quite a large breaking\r\nchange for all imports in existing code, but all functionality is retained\r\nprecisely as-is and path statements simply need to be renamed from `io` to\r\n`old_io`.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "5d836cdf8666ce0af6911a0c89dffea4da74b374",
    "author": "Alex Crichton",
    "date": 1422316918,
    "message": "std: Rename Writer::write to Writer::write_all\n\nIn preparation for upcoming changes to the `Writer` trait (soon to be called\n`Write`) this commit renames the current `write` method to `write_all` to match\nthe semantics of the upcoming `write_all` method. The `write` method will be\nrepurposed to return a `usize` indicating how much data was written which\ndiffers from the current `write` semantics. In order to head off as much\nunintended breakage as possible, the method is being deprecated now in favor of\na new name.\n\n[breaking-change]"
  },
  {
    "hash": "f72b1645103e12b581f7022b893c37b5fe41aef7",
    "author": "Alex Crichton",
    "date": 1422316876,
    "message": "std: Rename io to old_io\n\nIn preparation for the I/O rejuvination of the standard library, this commit\nrenames the current `io` module to `old_io` in order to make room for the new\nI/O modules. It is expected that the I/O RFCs will land incrementally over time\ninstead of all at once, and this provides a fresh clean path for new modules to\nenter into as well as guaranteeing that all old infrastructure will remain in\nplace for some time.\n\nAs each `old_io` module is replaced it will be deprecated in-place for new\nstructures in `std::{io, fs, net}` (as appropriate).\n\nThis commit does *not* leave a reexport of `old_io as io` as the deprecation\nlint does not currently warn on this form of use. This is quite a large breaking\nchange for all imports in existing code, but all functionality is retained\nprecisely as-is and path statements simply need to be renamed from `io` to\n`old_io`.\n\n[breaking-change]"
  },
  {
    "hash": "43046becce78147fa43808626bbb48569086b6a5",
    "author": "bors",
    "date": 1422165030,
    "message": "Auto merge of #21558 - alexcrichton:result-debug, r=aturon\n\nThis commit relaxes the bound on `Result::unwrap` and `Result::unwrap_err` from\r\nthe `Display` trait to the `Debug` trait for generating an error message about\r\nthe unwrapping operation.\r\n\r\nThis commit is a breaking change and any breakage should be mitigated by\r\nensuring that `Debug` is implemented on the relevant type.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "08246520c0fef902b169233e26e15cf58ef1cd8b",
    "author": "Alex Crichton",
    "date": 1422051094,
    "message": "std: Relax Result::unwrap() to Debug\n\nThis commit relaxes the bound on `Result::unwrap` and `Result::unwrap_err` from\nthe `Display` trait to the `Debug` trait for generating an error message about\nthe unwrapping operation.\n\nThis commit is a breaking change and any breakage should be mitigated by\nensuring that `Debug` is implemented on the relevant type.\n\n[breaking-change]"
  },
  {
    "hash": "e5c1f166a8282072089de2ad62a5b2427bd2bebf",
    "author": "bors",
    "date": 1422076335,
    "message": "Auto merge of #21458 - alexcrichton:remove-some-code, r=brson\n\nThe base64 support can be trivially removed (there are no in-tree users) and the regex support is a whopping 4k lines of code to maintain for a few non-critical uses in-tree. This commit migrates all current users in-tree away from regexes to custom matching code.\r\n\r\nThe most critical application affected by this migration is that the testing framework no longer considers filter arguments as regexes, but rather just a substring matching. It is expected that more featureful testing frameworks can evolve outside of the in-tree libtest version over time which can properly depend on libregex from crates.io.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "092ba6a8563b5c95f5aa53a705eaba6cc94e2da7",
    "author": "Aaron Turon",
    "date": 1421855145,
    "message": "Deprecate slicing methods in favor of notation\n\nThis commit deprecates `slice`, `slice_from`, `slice_to` and their\nmutable variants in favor of slice notation.\n\nThe `as_slice` methods are left intact, for now.\n\n[breaking-change]"
  },
  {
    "hash": "fba0bf63a90379e8825012a817167774e14a627f",
    "author": "Aaron Turon",
    "date": 1421855145,
    "message": "Stabilize Index traits and most range notation\n\nThis commit marks as `#[stable]`:\n\n* The `Index` and `IndexMut` traits. These are stabilized as taking the\n  index itself *by reference*; after extensive discussion it was\n  determined that this is a better match with our choices\n  elsewhere (e.g. making comparison operators auto-reference), and that\n  the use cases for by-value indices are better handled through\n  `IndexSet`.\n\n* The `Range`, `RangeFrom` and `RangeTo` structs, introduced for range\n  notation.\n\n* Various impls of `Index` and `IndexMut`.\n\nThe `FullRange` struct is left unstable as we may wish to rename it to\n`RangeFull` in the future.\n\nThis commit also *removes* the `Step` trait in favor of direct\nimplementation of iterator traits on ranges for integers. The `Step`\ntrait was not a terribly useful factoring internally, and it is likely\nthat external integer types are best off implementing range iterators\ndirectly. It was removed to simplify the API surface. We can always\nreintroduce `Step` later if it turns out to be useful.\n\nDue to this removal, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "3cb9fa26ef9905c00a29ea577fb55a12a91c8e7b",
    "author": "Alex Crichton",
    "date": 1421822173,
    "message": "std: Rename Show/String to Debug/Display\n\nThis commit is an implementation of [RFC 565][rfc] which is a stabilization of\nthe `std::fmt` module and the implementations of various formatting traits.\nSpecifically, the following changes were performed:\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0565-show-string-guidelines.md\n\n* The `Show` trait is now deprecated, it was renamed to `Debug`\n* The `String` trait is now deprecated, it was renamed to `Display`\n* Many `Debug` and `Display` implementations were audited in accordance with the\n  RFC and audited implementations now have the `#[stable]` attribute\n  * Integers and floats no longer print a suffix\n  * Smart pointers no longer print details that they are a smart pointer\n  * Paths with `Debug` are now quoted and escape characters\n* The `unwrap` methods on `Result` now require `Display` instead of `Debug`\n* The `Error` trait no longer has a `detail` method and now requires that\n  `Display` must be implemented. With the loss of `String`, this has moved into\n  libcore.\n* `impl<E: Error> FromError<E> for Box<Error>` now exists\n* `derive(Show)` has been renamed to `derive(Debug)`. This is not currently\n  warned about due to warnings being emitted on stage1+\n\nWhile backwards compatibility is attempted to be maintained with a blanket\nimplementation of `Display` for the old `String` trait (and the same for\n`Show`/`Debug`) this is still a breaking change due to primitives no longer\nimplementing `String` as well as modifications such as `unwrap` and the `Error`\ntrait. Most code is fairly straightforward to update with a rename or tweaks of\nmethod calls.\n\n[breaking-change]\nCloses #21436"
  },
  {
    "hash": "8d05f6c74c34c1d72fd91be3057fe7d4581aca3a",
    "author": "Barosl LEE",
    "date": 1421774211,
    "message": "Rollup merge of #21388 - aochagavia:collections, r=Gankro\n\n**Breaking change**: `VecMap::into_iter` now consumes the `VecMap`. To fix it you should pass the VecMap by value instead of by reference.\r\n\r\n[breaking-change]\r\n\r\nr? @Gankro"
  },
  {
    "hash": "2366dee8e9cb41d963900c8d5128f810a87fc6bb",
    "author": "Adolfo Ochagav√≠a",
    "date": 1421660881,
    "message": "Make VecMap::into_iter consume the VecMap\n\nThis is a breaking change. To fix it you should pass the VecMap by value\ninstead of by reference.\n\n[breaking-change]"
  },
  {
    "hash": "e63443d536a0e6157dce0cfb39dfcd2d614fb357",
    "author": "Barosl LEE",
    "date": 1421774207,
    "message": "Rollup merge of #21312 - michaelsproul:remove-error-send-bound, r=aturon\n\nAs discussed with @aturon, this PR removes the `Send` bound from `std::error::Error`, allowing us to implement `Error` for error types containing non-`Send` types. Current examples include `PoisonError` and `TryLockError` from `std::sync` which contain a Guard that we don't want sent between tasks.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "cda3490f8fb099a1ddd1f253a75c29110042dc01",
    "author": "bors",
    "date": 1421682281,
    "message": "Auto merge of #21269 - alexcrichton:issue-6936, r=pnkfelix\n\nThis commit modifies resolve to prevent conflicts with typedef names in the same\r\nmethod that conflits are prevented with enum names. This is a breaking change\r\ndue to the differing semantics in resolve, and any errors generated on behalf of\r\nthis change require that a conflicting typedef, module, or structure to be\r\nrenamed so they do not conflict.\r\n\r\n[breaking-change]\r\nCloses #6936"
  },
  {
    "hash": "2549cbec9dfe02cdc93a3cf3bfe9638e5a4c2948",
    "author": "Alex Crichton",
    "date": 1421634355,
    "message": "rustc_resolve: Do not allow mods to shadow types\n\nThis commit modifies resolve to prevent conflicts with typedef names in the same\nmethod that conflits are prevented with enum names. This is a breaking change\ndue to the differing semantics in resolve, and any errors generated on behalf of\nthis change require that a conflicting typedef, module, or structure to be\nrenamed so they do not conflict.\n\n[breaking-change]\nCloses #6936"
  },
  {
    "hash": "7b87900d72cf53037119e3bac1506a9786ca508a",
    "author": "bors",
    "date": 1421662763,
    "message": "Auto merge of #20874 - klutzy:windows-dynamic-lib, r=alexcrichton\n\nThis is a [breaking-change] since `std::dynamic_lib::dl` is now\r\nprivate.\r\n\r\nWhen `LoadLibraryW()` fails, original code called `errno()` to get error\r\ncode.  However, there was local allocation of `Vec` before\r\n`LoadLibraryW()`, and it drops before `errno()`, and the drop\r\n(deallocation) changed `errno`! Therefore `dynamic_lib::open()` thought\r\nit always succeeded.\r\nThis commit fixes the issue.\r\n\r\nThis commit also sets Windows error mode during `LoadLibrary()` to\r\nprevent \"dll load failed\" dialog."
  },
  {
    "hash": "d053ccb45fafc12a52629f209122c1ce9bbfabed",
    "author": "klutzy",
    "date": 1421593965,
    "message": "std::dynamic_lib: Fix Windows error handling\n\nThis is a [breaking-change] since `std::dynamic_lib::dl` is now\nprivate.\n\nWhen `LoadLibraryW()` fails, original code called `errno()` to get error\ncode.  However, there was local allocation of `Vec` before\n`LoadLibraryW()`, and it drops before `errno()`, and the drop\n(deallocation) changed `errno`! Therefore `dynamic_lib::open()` thought\nit always succeeded.\nThis commit fixes the issue.\n\nThis commit also sets Windows error mode during `LoadLibrary()` to\nprevent \"dll load failed\" dialog."
  },
  {
    "hash": "34fa70fba5425cbbb96bce783e9fd5c23dd9b471",
    "author": "Alex Crichton",
    "date": 1421509867,
    "message": "std: Move the bitflags! macro to a gated crate\n\nIn accordance with [collections reform part 2][rfc] this macro has been moved to\nan external [bitflags crate][crate] which is [available though\ncrates.io][cratesio]. Inside the standard distribution the macro has been moved\nto a crate called `rustc_bitflags` for current users to continue using.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0509-collections-reform-part-2.md\n[crate]: https://github.com/rust-lang/bitflags\n[cratesio]: http://crates.io/crates/bitflags\n\nThe major user of `bitflags!` in terms of a public-facing possibly-stable API\ntoday is the `FilePermissions` structure inside of `std::io`. This user,\nhowever, will likely no longer use `bitflags!` after I/O reform has landed. To\nprevent breaking APIs today, this structure remains as-is.\n\nCurrent users of the `bitflags!` macro should add this to their `Cargo.toml`:\n\n    bitflags = \"0.1\"\n\nand this to their crate root:\n\n    #[macro_use] extern crate bitflags;\n\nDue to the removal of a public macro, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "873ae555e9a42fd12b0a92134112ec000d749ab2",
    "author": "Simonas Kazlauskas",
    "date": 1421509789,
    "message": "Revert stability for Bitv and BitvSet\n\nThe collections were promoted to stable by mistake and do not match RFC 509.\nThis reverts the stability back to unstable.\n\n[breaking-change] since previously stable API became unstable.\n\nFixes #21193"
  },
  {
    "hash": "cbeb77ec7a42b988703fa0b0c857f26d464fdc2f",
    "author": "Alex Crichton",
    "date": 1421426896,
    "message": "rustc: Fix a leak in dependency= paths\n\nWith the addition of separate search paths to the compiler, it was intended that\napplications such as Cargo could require a `--extern` flag per `extern crate`\ndirective in the source. The system can currently be subverted, however, due to\nthe `existing_match()` logic in the crate loader.\n\nWhen loading crates we first attempt to match an `extern crate` directive\nagainst all previously loaded crates to avoid reading metadata twice. This \"hit\nthe cache if possible\" step was erroneously leaking crates across the search\npath boundaries, however. For example:\n\n    extern crate b;\n    extern crate a;\n\nIf `b` depends on `a`, then it will load crate `a` when the `extern crate b`\ndirective is being processed. When the compiler reaches `extern crate a` it will\nuse the previously loaded version no matter what. If the compiler was not\ninvoked with `-L crate=path/to/a`, it will still succeed.\n\nThis behavior is allowing `extern crate` declarations in Cargo without a\ncorresponding declaration in the manifest of a dependency, which is considered\na bug.\n\nThis commit fixes this problem by keeping track of the origin search path for a\ncrate. Crates loaded from the dependency search path are not candidates for\ncrates which are loaded from the crate search path.\n\nAs a result of this fix, this is a likely a breaking change for a number of\nCargo packages. If the compiler starts informing that a crate can no longer be\nfound, it likely means that the dependency was forgotten in your Cargo.toml.\n\n[breaking-change]"
  },
  {
    "hash": "ee2bfae011e368e224d6d4f4c9fad13606ee99da",
    "author": "bors",
    "date": 1421413859,
    "message": "auto merge of #20972 : FlaPer87/rust/oibit-send-and-friends, r=nikomatsakis\n\nThis PR adds rules for negative implementations. It follows pretty much what the [RFC](https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md) says with 1 main difference:\r\n\r\nInstead of positive implementations override negative implementations, this have been implemented in a way that a negative implementation of `Trait` for `T` will overlap with a positive implementation, causing a coherence error.\r\n\r\n@nikomatsakis r?\r\n\r\ncc #13231\r\n\r\n[breaking-change]"
  },
  {
    "hash": "0419b4ab1225595b022d8ed4e425526b4d850995",
    "author": "Alex Crichton",
    "date": 1421359920,
    "message": "rollup merge of #21167: FlaPer87/coherence-impls\n\nFixes #21080\n\nr? @nikomatsakis\n\n[breaking-change]"
  },
  {
    "hash": "3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c",
    "author": "bors",
    "date": 1421103380,
    "message": "auto merge of #20896 : sfackler/rust/atomic-rename, r=alexcrichton\n\nChange any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize\r\n\r\nCloses #20893\r\n\r\n[breaking-change]"
  },
  {
    "hash": "8b6cda3ce681d4d95c3097d12ed754975b4a07f6",
    "author": "Steven Fackler",
    "date": 1421005664,
    "message": "Rename AtomicInt and AtomicUint\n\nChange any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize\n\nCloses #20893\n\n[breaking-change]"
  },
  {
    "hash": "2e4cef4e78253beb4c08ed35416fad076d978344",
    "author": "bors",
    "date": 1420994748,
    "message": "auto merge of #20910 : sfackler/rust/show-impls, r=alexcrichton\n\nA derived implementation would not be appropriate for the Buffered types\r\nsince the buffer is both huge (64k by default) and full of uninitialized\r\nmemory. Instead of printing the whole thing, we display how full it is.\r\n\r\nI also altered `MultiWriter` to make it generic over Writers instead of\r\ntaking `Box<Writer>` trait objects. `Box<Writer>` implements `Writer` so\r\nexisting use cases should continue to work, and this enables a more\r\nuseful Show implementation in applicable cases.\r\n\r\nThe change to `MultiWriter` may break code that uses it, but any fixes\r\nshould be easy.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton"
  },
  {
    "hash": "b4fae2fba99e713a6d6a8a59caaf1cfba847b50e",
    "author": "Steven Fackler",
    "date": 1420939974,
    "message": "Implement Show for types in std::io::{buffered,util}\n\nA derived implementation would not be appropriate for the Buffered types\nsince the buffer is both huge (64k by default) and full of uninitialized\nmemory. Instead of printing the whole thing, we display how full it is.\n\nI also altered MultiWriter to make it generic over Writers instead of\ntaking Box<Writer> trait objects. Box<Writer> implements Writer so\nexisting use cases should continue to work, and this enables a more\nuseful Show implementation in applicable cases.\n\nThe change to MultiWriter may break code that uses it, but any fixes\nshould be easy.\n\n[breaking-change]"
  },
  {
    "hash": "daee409b60cdb17040122343e0a184049c62180b",
    "author": "Alex Crichton",
    "date": 1420737726,
    "message": "rollup merge of #20740: FlaPer87/remove-opt-out-copy\n\n[breaking-change] code using this feature will break."
  },
  {
    "hash": "4a31aaddb364f5ab8280242a1016bdd3d10dcaed",
    "author": "Felix S. Klock II",
    "date": 1420674103,
    "message": "Added `box_syntax` feature gate; added to std and rustc crates for bootstrap.\n\nTo avoid using the feauture, change uses of `box <expr>` to\n`Box::new(<expr>)` alternative, as noted by the feature gate message.\n\n(Note that box patterns have no analogous trivial replacement, at\nleast not in general; you need to revise the code to do a partial\nmatch, deref, and then the rest of the match.)\n\n[breaking-change]"
  },
  {
    "hash": "63a9bd5e0adc03652e10506055564077aa00eeaa",
    "author": "Nick Cameron",
    "date": 1420669500,
    "message": "Fix precedence for ranges.\n\nTechnically this is a\n\n[breaking-change]\n\nbut it probably shouldn't affect your code.\n\nCloses #20256"
  },
  {
    "hash": "209c701bf9e95542aec69455bc12c7ca295109c4",
    "author": "Alex Crichton",
    "date": 1420664176,
    "message": "std: Stablize the macros module\n\nThis commit performs a pass over the `std::macros` module, applying stability\nattributes where necessary. In particular, this audits macros for patterns such\nas:\n\n* Standard use of forward-to-format-args via `$($arg:tt)*` (or `+`)\n* Prevent macro-defined identifiers from leaking into expression arguments as\n  hygiene is not perfectly implemented.\n* Wherever possible, `$crate` is used now.\n\nSpecifically, the following actions were taken:\n\n* The `std::macros` module itself is no longer public.\n* The `panic!` macro is stable\n* The `assert!` macro is stable\n* The `assert_eq!` macro is stable\n* The `debug_assert!` macro is stable\n* The `debug_assert_eq!` macro is stable\n* The `unreachable!` macro is stable after removing the extra forms to bring the\n  definition in line with the `unimplemented!` macro.\n* The `try!` macro is stable\n* The `vec!` macro is stable\n\n[breaking-change]"
  },
  {
    "hash": "92cd8ea96ad2a1da51863b7f089baec41ed10ce9",
    "author": "Huon Wilson",
    "date": 1420680448,
    "message": "Prohibit type parameter shadowing with a clunky hammer.\n\nThis is a [breaking-change].\n\nChange\n\n    impl<T> Foo<T> {\n        fn bar<T>(...\n\nto (for example)\n\n    impl<T> Foo<T> {\n        fn bar<U>(...\n\nPer RFC 459.\n\nCloses #19390."
  },
  {
    "hash": "7deb9abd1b45f3e56ca6b13432866ae89886f21f",
    "author": "Aaron Turon",
    "date": 1420659611,
    "message": "Add isize, usize modules, deprecate int, uint modules\n\nThis PR introduces `isize` and `usize` modules to `core` and `std`, and\ndeprecates the existing `int` and `uint` modules. The rustdoc primitive\ntype links now point to these new modules.\n\nDue to deprecation this is a:\n\n[breaking-change]"
  },
  {
    "hash": "6301c7878ebcaa45e77315db2a9afd8b5d1425c8",
    "author": "Alex Crichton",
    "date": 1420679843,
    "message": "rollup merge of #20680: nick29581/target-word\n\nCloses #20421\n\n[breaking-change]\n\nr? @brson"
  },
  {
    "hash": "dd3e89aaf25c667fa8207f8800c4b60d70d76c1b",
    "author": "Nick Cameron",
    "date": 1420661275,
    "message": "Rename `target_word_size` to `target_pointer_width`\n\nCloses #20421\n\n[breaking-change]"
  },
  {
    "hash": "8bf3ee7c5c44fa5aa0a1003e8fe61a0af1527927",
    "author": "Alex Crichton",
    "date": 1420679839,
    "message": "rollup merge of #20654: alexcrichton/stabilize-hash\n\nThis commit aims to prepare the `std::hash` module for alpha by formalizing its\ncurrent interface whileholding off on adding `#[stable]` to the new APIs.  The\ncurrent usage with the `HashMap` and `HashSet` types is also reconciled by\nseparating out composable parts of the design. The primary goal of this slight\nredesign is to separate the concepts of a hasher's state from a hashing\nalgorithm itself.\n\nThe primary change of this commit is to separate the `Hasher` trait into a\n`Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was\nactually just a factory for various states, but hashing had very little control\nover how these states were used. Additionally the old `Hasher` trait was\nactually fairly unrelated to hashing.\n\nThis commit redesigns the existing `Hasher` trait to match what the notion of a\n`Hasher` normally implies with the following definition:\n\n    trait Hasher {\n        type Output;\n        fn reset(&mut self);\n        fn finish(&self) -> Output;\n    }\n\nThis `Hasher` trait emphasizes that hashing algorithms may produce outputs other\nthan a `u64`, so the output type is made generic. Other than that, however, very\nlittle is assumed about a particular hasher. It is left up to implementors to\nprovide specific methods or trait implementations to feed data into a hasher.\n\nThe corresponding `Hash` trait becomes:\n\n    trait Hash<H: Hasher> {\n        fn hash(&self, &mut H);\n    }\n\nThe old default of `SipState` was removed from this trait as it's not something\nthat we're willing to stabilize until the end of time, but the type parameter is\nalways required to implement `Hasher`. Note that the type parameter `H` remains\non the trait to enable multidispatch for specialization of hashing for\nparticular hashers.\n\nNote that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is\nsimply used as part `derive` and the implementations for all primitive types.\n\nWith these definitions, the old `Hasher` trait is realized as a new `HashState`\ntrait in the `collections::hash_state` module as an unstable addition for\nnow. The current definition looks like:\n\n    trait HashState {\n        type Hasher: Hasher;\n        fn hasher(&self) -> Hasher;\n    }\n\nThe purpose of this trait is to emphasize that the one piece of functionality\nfor implementors is that new instances of `Hasher` can be created.  This\nconceptually represents the two keys from which more instances of a\n`SipHasher` can be created, and a `HashState` is what's stored in a\n`HashMap`, not a `Hasher`.\n\nImplementors of custom hash algorithms should implement the `Hasher` trait, and\nonly hash algorithms intended for use in hash maps need to implement or worry\nabout the `HashState` trait.\n\nThe entire module and `HashState` infrastructure remains `#[unstable]` due to it\nbeing recently redesigned, but some other stability decision made for the\n`std::hash` module are:\n\n* The `Writer` trait remains `#[experimental]` as it's intended to be replaced\n  with an `io::Writer` (more details soon).\n* The top-level `hash` function is `#[unstable]` as it is intended to be generic\n  over the hashing algorithm instead of hardwired to `SipHasher`\n* The inner `sip` module is now private as its one export, `SipHasher` is\n  reexported in the `hash` module.\n\nAnd finally, a few changes were made to the default parameters on `HashMap`.\n\n* The `RandomSipHasher` default type parameter was renamed to `RandomState`.\n  This renaming emphasizes that it is not a hasher, but rather just state to\n  generate hashers. It also moves away from the name \"sip\" as it may not always\n  be implemented as `SipHasher`. This type lives in the\n  `std::collections::hash_map` module as `#[unstable]`\n\n* The associated `Hasher` type of `RandomState` is creatively called...\n  `Hasher`! This concrete structure lives next to `RandomState` as an\n  implemenation of the \"default hashing algorithm\" used for a `HashMap`. Under\n  the hood this is currently implemented as `SipHasher`, but it draws an\n  explicit interface for now and allows us to modify the implementation over\n  time if necessary.\n\nThere are many breaking changes outlined above, and as a result this commit is\na:\n\n[breaking-change]"
  },
  {
    "hash": "511f0b8a3de5a166fc96aba5170782c9abf92101",
    "author": "Alex Crichton",
    "date": 1420661888,
    "message": "std: Stabilize the std::hash module\n\nThis commit aims to prepare the `std::hash` module for alpha by formalizing its\ncurrent interface whileholding off on adding `#[stable]` to the new APIs.  The\ncurrent usage with the `HashMap` and `HashSet` types is also reconciled by\nseparating out composable parts of the design. The primary goal of this slight\nredesign is to separate the concepts of a hasher's state from a hashing\nalgorithm itself.\n\nThe primary change of this commit is to separate the `Hasher` trait into a\n`Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was\nactually just a factory for various states, but hashing had very little control\nover how these states were used. Additionally the old `Hasher` trait was\nactually fairly unrelated to hashing.\n\nThis commit redesigns the existing `Hasher` trait to match what the notion of a\n`Hasher` normally implies with the following definition:\n\n    trait Hasher {\n        type Output;\n        fn reset(&mut self);\n        fn finish(&self) -> Output;\n    }\n\nThis `Hasher` trait emphasizes that hashing algorithms may produce outputs other\nthan a `u64`, so the output type is made generic. Other than that, however, very\nlittle is assumed about a particular hasher. It is left up to implementors to\nprovide specific methods or trait implementations to feed data into a hasher.\n\nThe corresponding `Hash` trait becomes:\n\n    trait Hash<H: Hasher> {\n        fn hash(&self, &mut H);\n    }\n\nThe old default of `SipState` was removed from this trait as it's not something\nthat we're willing to stabilize until the end of time, but the type parameter is\nalways required to implement `Hasher`. Note that the type parameter `H` remains\non the trait to enable multidispatch for specialization of hashing for\nparticular hashers.\n\nNote that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is\nsimply used as part `derive` and the implementations for all primitive types.\n\nWith these definitions, the old `Hasher` trait is realized as a new `HashState`\ntrait in the `collections::hash_state` module as an unstable addition for\nnow. The current definition looks like:\n\n    trait HashState {\n        type Hasher: Hasher;\n        fn hasher(&self) -> Hasher;\n    }\n\nThe purpose of this trait is to emphasize that the one piece of functionality\nfor implementors is that new instances of `Hasher` can be created.  This\nconceptually represents the two keys from which more instances of a\n`SipHasher` can be created, and a `HashState` is what's stored in a\n`HashMap`, not a `Hasher`.\n\nImplementors of custom hash algorithms should implement the `Hasher` trait, and\nonly hash algorithms intended for use in hash maps need to implement or worry\nabout the `HashState` trait.\n\nThe entire module and `HashState` infrastructure remains `#[unstable]` due to it\nbeing recently redesigned, but some other stability decision made for the\n`std::hash` module are:\n\n* The `Writer` trait remains `#[experimental]` as it's intended to be replaced\n  with an `io::Writer` (more details soon).\n* The top-level `hash` function is `#[unstable]` as it is intended to be generic\n  over the hashing algorithm instead of hardwired to `SipHasher`\n* The inner `sip` module is now private as its one export, `SipHasher` is\n  reexported in the `hash` module.\n\nAnd finally, a few changes were made to the default parameters on `HashMap`.\n\n* The `RandomSipHasher` default type parameter was renamed to `RandomState`.\n  This renaming emphasizes that it is not a hasher, but rather just state to\n  generate hashers. It also moves away from the name \"sip\" as it may not always\n  be implemented as `SipHasher`. This type lives in the\n  `std::collections::hash_map` module as `#[unstable]`\n\n* The associated `Hasher` type of `RandomState` is creatively called...\n  `Hasher`! This concrete structure lives next to `RandomState` as an\n  implemenation of the \"default hashing algorithm\" used for a `HashMap`. Under\n  the hood this is currently implemented as `SipHasher`, but it draws an\n  explicit interface for now and allows us to modify the implementation over\n  time if necessary.\n\nThere are many breaking changes outlined above, and as a result this commit is\na:\n\n[breaking-change]"
  },
  {
    "hash": "6680c9c5c797101fc5e0608cb2c3657517333148",
    "author": "Corey Richardson",
    "date": 1420563792,
    "message": "syntax: implement 'macro input future proofing'\n\nSee RFC 550 (https://github.com/rust-lang/rfcs/pull/550) for the motivation\nand details.\n\nIf this breaks your code, add one of the listed tokens after the relevant\nnon-terminal in your matcher.\n\n[breaking-change]"
  },
  {
    "hash": "36f5d122b80682de473aeda2e20f14b6ceb86d74",
    "author": "Alex Crichton",
    "date": 1420587518,
    "message": "rollup merge of #20615: aturon/stab-2-thread\n\nThis commit takes a first pass at stabilizing `std::thread`:\n\n* It removes the `detach` method in favor of two constructors -- `spawn`\n  for detached threads, `scoped` for \"scoped\" (i.e., must-join)\n  threads. This addresses some of the surprise/frustrating debug\n  sessions with the previous API, in which `spawn` produced a guard that\n  on destruction joined the thread (unless `detach` was called).\n\n  The reason to have the division in part is that `Send` will soon not\n  imply `'static`, which means that `scoped` thread creation can take a\n  closure over *shared stack data* of the parent thread. On the other\n  hand, this means that the parent must not pop the relevant stack\n  frames while the child thread is running. The `JoinGuard` is used to\n  prevent this from happening by joining on drop (if you have not\n  already explicitly `join`ed.) The APIs around `scoped` are\n  future-proofed for the `Send` changes by taking an additional lifetime\n  parameter. With the current definition of `Send`, this is forced to be\n  `'static`, but when `Send` changes these APIs will gain their full\n  flexibility immediately.\n\n  Threads that are `spawn`ed, on the other hand, are detached from the\n  start and do not yield an RAII guard.\n\n  The hope is that, by making `scoped` an explicit opt-in with a very\n  suggestive name, it will be drastically less likely to be caught by a\n  surprising deadlock due to an implicit join at the end of a scope.\n\n* The module itself is marked stable.\n\n* Existing methods other than `spawn` and `scoped` are marked stable.\n\nThe migration path is:\n\n```rust\nThread::spawn(f).detached()\n```\n\nbecomes\n\n```rust\nThread::spawn(f)\n```\n\nwhile\n\n```rust\nlet res = Thread::spawn(f);\nres.join()\n```\n\nbecomes\n\n```rust\nlet res = Thread::scoped(f);\nres.join()\n```\n\n[breaking-change]"
  },
  {
    "hash": "f67b81e8d4dc198ad10ad50a7624e43cc1e25802",
    "author": "Aaron Turon",
    "date": 1420563888,
    "message": "Stabilize std::thread\n\nThis commit takes a first pass at stabilizing `std::thread`:\n\n* It removes the `detach` method in favor of two constructors -- `spawn`\n  for detached threads, `scoped` for \"scoped\" (i.e., must-join)\n  threads. This addresses some of the surprise/frustrating debug\n  sessions with the previous API, in which `spawn` produced a guard that\n  on destruction joined the thread (unless `detach` was called).\n\n  The reason to have the division in part is that `Send` will soon not\n  imply `'static`, which means that `scoped` thread creation can take a\n  closure over *shared stack data* of the parent thread. On the other\n  hand, this means that the parent must not pop the relevant stack\n  frames while the child thread is running. The `JoinGuard` is used to\n  prevent this from happening by joining on drop (if you have not\n  already explicitly `join`ed.) The APIs around `scoped` are\n  future-proofed for the `Send` changes by taking an additional lifetime\n  parameter. With the current definition of `Send`, this is forced to be\n  `'static`, but when `Send` changes these APIs will gain their full\n  flexibility immediately.\n\n  Threads that are `spawn`ed, on the other hand, are detached from the\n  start and do not yield an RAII guard.\n\n  The hope is that, by making `scoped` an explicit opt-in with a very\n  suggestive name, it will be drastically less likely to be caught by a\n  surprising deadlock due to an implicit join at the end of a scope.\n\n* The module itself is marked stable.\n\n* Existing methods other than `spawn` and `scoped` are marked stable.\n\nThe migration path is:\n\n```rust\nThread::spawn(f).detached()\n```\n\nbecomes\n\n```rust\nThread::spawn(f)\n```\n\nwhile\n\n```rust\nlet res = Thread::spawn(f);\nres.join()\n```\n\nbecomes\n\n```rust\nlet res = Thread::scoped(f);\nres.join()\n```\n\n[breaking-change]"
  },
  {
    "hash": "503709708c72401dbe091ed5c7e0494efabe0669",
    "author": "Nick Cameron",
    "date": 1420577128,
    "message": "Change `std::kinds` to `std::markers`; flatten `std::kinds::marker`\n\n[breaking-change]"
  },
  {
    "hash": "2375a79152b8a6554c3e97a3f127fedd75f7495f",
    "author": "Niko Matsakis",
    "date": 1420582668,
    "message": "Implement impl reachability rules. This is a [breaking-change]. Type\nparameters on impls must now also appear in the trait ref, self type,\nor some associated type declared on the impl. This ensures that they\nare constrianed in some way and that the semantics of the trait system\nare well-defined (always a good thing).\n\nThere are three major ways to fix this error:\n\n1. Convert the trait to use associated types; most often the type\n   parameters are not constrained because they are in fact outputs of\n   the impl.\n\n2. Move the type parameters to methods.\n\n3. Add an additional type parameter to the self type or trait so that\n   the unused parameter can appear there.\n\nIn some cases, it is not possible to fix the impl because the trait\ndefinition needs to be changed first (and that may be out of your\ncontrol). In that case, for the time being, you can opt out of these\nrules by using `#[old_impl_check]` on the impl and adding a\n`#![feature(old_impl_check)]` to your crate declaration."
  },
  {
    "hash": "44440e5c18a1dbcc9685866ffffe00c508929079",
    "author": "Sean McArthur",
    "date": 1420584582,
    "message": "core: split into fmt::Show and fmt::String\n\nfmt::Show is for debugging, and can and should be implemented for\nall public types. This trait is used with `{:?}` syntax. There still\nexists #[derive(Show)].\n\nfmt::String is for types that faithfully be represented as a String.\nBecause of this, there is no way to derive fmt::String, all\nimplementations must be purposeful. It is used by the default format\nsyntax, `{}`.\n\nThis will break most instances of `{}`, since that now requires the type\nto impl fmt::String. In most cases, replacing `{}` with `{:?}` is the\ncorrect fix. Types that were being printed specifically for users should\nreceive a fmt::String implementation to fix this.\n\nPart of #20013\n\n[breaking-change]"
  },
  {
    "hash": "ae4762761c995494726e8c9f41b05e99e6c7c81b",
    "author": "Huon Wilson",
    "date": 1420546887,
    "message": "Merge core::num::Float and std::num::FloatMath.\n\n`FloatMath` no longer exists and all functionality from both traits is\navailable under `Float`. Change from\n\n    use std::num::{Float, FloatMath};\n\nto\n\n    use std::num::Float;\n\n[breaking-change]"
  },
  {
    "hash": "cd4ed38404384bdb13500f1d2e782d32ece2b239",
    "author": "Huon Wilson",
    "date": 1420546861,
    "message": "Deprecate the constant-returning functions in Float.\n\nThese are replaced by the equivalent constants in `std::f32` and\n`std::f64` respectively.\n\n[breaking-change]"
  },
  {
    "hash": "48f50e1e98691d74427e23e82694f528b3fb4d56",
    "author": "Nick Cameron",
    "date": 1420507247,
    "message": "Obsolete `Sized? T`\n\n[breaking-change]\n\nUse `T: ?Sized`"
  },
  {
    "hash": "6e68fd09edc7ed37fd76f703247b5410cd338bfe",
    "author": "Niko Matsakis",
    "date": 1420496246,
    "message": "Implement new orphan rule that requires that impls of remote traits meet the following two criteria:\n\n- the self type includes some local type; and,\n- type parameters in the self type must be constrained by a local type.\n\nA type parameter is called *constrained* if it appears in some type-parameter of a local type.\n\nHere are some examples that are accepted. In all of these examples, I\nassume that `Foo` is a trait defined in another crate. If `Foo` were\ndefined in the local crate, then all the examples would be legal.\n\n- `impl Foo for LocalType`\n- `impl<T> Foo<T> for LocalType` -- T does not appear in Self, so it is OK\n- `impl<T> Foo<T> for LocalType<T>` -- T here is constrained by LocalType\n- `impl<T> Foo<T> for (LocalType<T>, T)` -- T here is constrained by LocalType\n\nHere are some illegal examples (again, these examples assume that\n`Foo` is not local to the current crate):\n\n- `impl Foo for int` -- the Self type is not local\n- `impl<T> Foo for T` -- T appears in Self unconstrained by a local type\n- `impl<T> Foo for (LocalType, T)` -- T appears in Self unconstrained by a local type\n\nThis is a [breaking-change]. For the time being, you can opt out of\nthe new rules by placing `#[old_orphan_check]` on the trait (and\nenabling the feature gate where the trait is defined). Longer term,\nyou should restructure your traits to avoid the problem. Usually this\nmeans changing the order of parameters so that the \"central\" type\nparameter is in the `Self` position.\n\nAs an example of that refactoring, consider the `BorrowFrom` trait:\n\n```rust\npub trait BorrowFrom<Sized? Owned> for Sized? {\n    fn borrow_from(owned: &Owned) -> &Self;\n}\n```\n\nAs defined, this trait is commonly implemented for custom pointer\ntypes, such as `Arc`. Those impls follow the pattern:\n\n```rust\nimpl<T> BorrowFrom<Arc<T>> for T {...}\n```\n\nUnfortunately, this impl is illegal because the self type `T` is not\nlocal to the current crate. Therefore, we are going to change the order of the parameters,\nso that `BorrowFrom` becomes `Borrow`:\n\n```rust\npub trait Borrow<Sized? Borrowed> for Sized? {\n    fn borrow_from(owned: &Self) -> &Borrowed;\n}\n```\n\nNow the `Arc` impl is written:\n\n```rust\nimpl<T> Borrow<T> for Arc<T> { ... }\n```\n\nThis impl is legal because the self type (`Arc<T>`) is local."
  },
  {
    "hash": "64ec47c9d2a75c8150d153450e7e7b7db60208dc",
    "author": "Aaron Turon",
    "date": 1420495265,
    "message": "Final alpha stabilization of core::iter\n\nThis commit wraps up the adjustments to the iterator for recent language\nchanges.\n\n* Moves `rposition` from `ExactSizeIterator` to `IteratorExt` using a\n  `where` clause, thereby removing the `ExactSizeIterator:\n  DoubleEndedIterator` constraint.\n\n* Merges `MutableDoubleEndedIterator` into `IteratorExt`, renaming\n  `reverse_` to `reverse_in_place`.\n\n* Merges `IteratorOrdExt`, `IteratorCloneExt` and `CloneIteratorExt`\n  into `IteratorExt` using `where` clauses.\n\nMarks as `#[stable]`:\n\n* the `iter` module itself\n* `FromIterator`, `Extend`\n* `Iterator`, `IteratorExt`\n* `map`\n* `filter`\n* `filter_map`\n* `skip_while`\n* `take_while`\n* `scan`\n* `flat_map`\n* `inspect`\n* `collect`\n* `fold`\n* `all`\n* `any`\n* `find`\n* `rposition`\n* `max`, `min`\n* Various adapter types related to the above methods\n\nBecause of the trait merging, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "bf6c007760169e9c382d3700fd1cdd20037e4343",
    "author": "Huon Wilson",
    "date": 1420434857,
    "message": "Change `&` pat to only work with &T, and `&mut` with &mut T.\n\nThis implements RFC 179 by making the pattern `&<pat>` require matching\nagainst a variable of type `&T`, and introducing the pattern `&mut\n<pat>` which only works with variables of type `&mut T`.\n\nThe pattern `&mut x` currently parses as `&(mut x)` i.e. a pattern match\nthrough a `&T` or a `&mut T` that binds the variable `x` to have type\n`T` and to be mutable. This should be rewritten as follows, for example,\n\n    for &mut x in slice.iter() {\n\nbecomes\n\n    for &x in slice.iter() {\n        let mut x = x;\n\nDue to this, this is a\n\n[breaking-change]\n\nCloses #20496."
  },
  {
    "hash": "25d5a3a19423fee01787de87a56d185dd4e0a4e7",
    "author": "Alex Crichton",
    "date": 1420511842,
    "message": "rollup merge of #20507: alexcrichton/issue-20444\n\nThis commit is an implementation of [RFC 494][rfc] which removes the entire\n`std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md\n\nThe interface of the new `CString` is outlined in the linked RFC, the primary\nchanges being:\n\n* The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods\n  are now gone. These two methods are replaced with a `CString::from_slice`\n  method.\n* The `CString` type is now just a wrapper around `Vec<u8>` with a static\n  guarantee that there is a trailing nul byte with no internal nul bytes. This\n  means that `CString` now implements `Deref<Target = [c_char]>`, which is where\n  it gains most of its methods from. A few helper methods are added to acquire a\n  slice of `u8` instead of `c_char`, as well as including a slice with the\n  trailing nul byte if necessary.\n* All usage of non-owned `CString` values is now done via two functions inside\n  of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These\n  functions are now the one method used to convert a `*const c_char` to a Rust\n  slice of `u8`.\n\nMany more details, including newly deprecated methods, can be found linked in\nthe RFC. This is a:\n\n[breaking-change]\nCloses #20444"
  },
  {
    "hash": "ec7a50d20dff416d9fec837a6492dfe244f5f3ab",
    "author": "Alex Crichton",
    "date": 1420473613,
    "message": "std: Redesign c_str and c_vec\n\nThis commit is an implementation of [RFC 494][rfc] which removes the entire\n`std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md\n\nThe interface of the new `CString` is outlined in the linked RFC, the primary\nchanges being:\n\n* The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods\n  are now gone. These two methods are replaced with a `CString::from_slice`\n  method.\n* The `CString` type is now just a wrapper around `Vec<u8>` with a static\n  guarantee that there is a trailing nul byte with no internal nul bytes. This\n  means that `CString` now implements `Deref<Target = [c_char]>`, which is where\n  it gains most of its methods from. A few helper methods are added to acquire a\n  slice of `u8` instead of `c_char`, as well as including a slice with the\n  trailing nul byte if necessary.\n* All usage of non-owned `CString` values is now done via two functions inside\n  of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These\n  functions are now the one method used to convert a `*const c_char` to a Rust\n  slice of `u8`.\n\nMany more details, including newly deprecated methods, can be found linked in\nthe RFC. This is a:\n\n[breaking-change]\nCloses #20444"
  },
  {
    "hash": "88b4c8e0d347921673e61bf1770ba0acd4c7d824",
    "author": "Alex Crichton",
    "date": 1420511794,
    "message": "rollup merge of #20465: nikomatsakis/assoc-types-regions-20303\n\nTreat associated types the same as type parameters when it comes to region bounding. Fixes #20303.\n\nStrictly speaking, this is a [breaking-change] (if you are using\nassociated types). You are no longer free to wantonly violate the type\nsystem rules by closing associated types into objects without any form\nof region bound. Instead you should add region bounds like `T::X :\n'a`, just as you would with a normal type parameter.\n\nr? @aturon"
  },
  {
    "hash": "c8868942e845254abfd3623a709847d65e015a2f",
    "author": "Niko Matsakis",
    "date": 1420470875,
    "message": "Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.\n\nStrictly speaking, this is a [breaking-change] (if you are using\nassociated types). You are no longer free to wantonly violate the type\nsystem rules by closing associated types into objects without any form\nof region bound. Instead you should add region bounds like `T::X :\n'a`, just as you would with a normal type parameter."
  },
  {
    "hash": "c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62",
    "author": "bors",
    "date": 1420501860,
    "message": "auto merge of #20578 : japaric/rust/no-more-bc, r=nmatsakis\n\nThis PR removes boxed closures from the language, the closure type syntax (`let f: |int| -> bool = /* ... */`) has been obsoleted. Move all your uses of closures to the new unboxed closure system (i.e. `Fn*` traits).\r\n\r\n[breaking-change] patterns\r\n\r\n- `lef f = || {}`\r\n\r\nThis binding used to type check to a boxed closure. Now that boxed closures are gone, you need to annotate the \"kind\" of the unboxed closure, i.e. you need pick one of these: `|&:| {}`, `|&mut:| {}` or `|:| {}`.\r\n\r\nIn the (near) future we'll have closure \"kind\" inference, so the compiler will infer which `Fn*` trait to use based on how the closure is used. Once this inference machinery is in place, we'll be able to remove the kind annotation from most closures.\r\n\r\n- `type Alias<'a> = |int|:'a -> bool`\r\n\r\nUse a trait object: `type Alias<'a> = Box<FnMut(int) -> bool + 'a>`. Use the `Fn*` trait that makes sense for your use case.\r\n\r\n- `fn foo(&self, f: |uint| -> bool)`\r\n\r\nIn this case you can use either a trait object or an unboxed closure:\r\n\r\n``` rust\r\nfn foo(&self, f: F) where F: FnMut(uint) -> bool;\r\n// or\r\nfn foo(&self, f: Box<FnMut(uint) -> bool>);\r\n```\r\n\r\n- `struct Struct<'a> { f: |uint|:'a -> bool }`\r\n\r\nAgain, you can use either a trait object or an unboxed closure:\r\n\r\n``` rust\r\nstruct Struct<F> where F: FnMut(uint) -> bool { f: F }\r\n// or\r\nstruct Struct<'a> { f: Box<FnMut(uint) -> bool + 'a> }\r\n```\r\n\r\n- Using `|x, y| f(x, y)` for closure \"borrows\"\r\n\r\nThis comes up in recursive functions, consider the following (contrived) example:\r\n\r\n``` rust\r\nfn foo(x: uint, f: |uint| -> bool) -> bool {\r\n    //foo(x / 2, f) && f(x)  // can't use this because `f` gets moved away in the `foo` call\r\n    foo(x / 2, |x| f(x)) && f(x)  // instead \"borrow\" `f` in the `foo` call\r\n}\r\n```\r\n\r\nIf you attempt to do the same with unboxed closures you'll hit \"\"error: reached the recursion limit during monomorphization\" (see #19596):\r\n\r\n``` rust\r\nfn foo<F>(x: uint, mut f: F) -> bool where F: FnMut(uint) -> bool {\r\n    foo(x / 2, |x| f(x)) && f(x)\r\n    //~^ error: reached the recursion limit during monomorphization\r\n}\r\n```\r\n\r\nInstead you *should* be able to write this:\r\n\r\n``` rust\r\nfn foo<F>(x: uint, mut f: F) -> bool where F: FnMut(uint) -> bool {\r\n    foo(x / 2, &mut f) && f(x)\r\n    //~^ error: the trait `FnMut` is not implemented for the type `&mut F`\r\n}\r\n```\r\n\r\nBut as you see above `&mut F` doesn't implement the `FnMut` trait. `&mut F` *should* implement the `FnMut` and the above code *should* work, but due to a bug (see #18835) it doesn't (for now).\r\n\r\nYou can work around the issue by rewriting the function to take `&mut F` instead of `F`:\r\n\r\n``` rust\r\nfn foo<F>(x: uint, f: &mut F) -> bool where F: FnMut(uint) -> bool {\r\n    foo(x / 2, f) && (*f)(x)\r\n}\r\n```\r\n\r\nThis finally works! However writing `foo(0, &mut |x| x == 0)` is unergonomic. So you can use a private helper function to avoid this:\r\n\r\n``` rust\r\n// public API function\r\npub fn foo<F>(x: uint, mut f: F) -> bool where F: FnMut(uint) -> bool {\r\n    foo_(x, &mut f)\r\n}\r\n\r\n// private helper function\r\nfn foo_<F>(x: uint, f: &mut F) -> bool where F: FnMut(uint) -> bool {\r\n    foo_(x / 2, f) && (*f)(x)\r\n}\r\n```\r\n\r\nCloses #14798\r\n\r\n---\r\n\r\nThere is more cleanup to do: like renaming functions/types from `unboxed_closure` to just `closure`, removing more dead code, simplify functions which now have unused arguments, update the documentation, etc. But that can be done in another PR.\r\n\r\nr? @nikomatsakis @aturon (You probably want to focus on the deleted/modified tests.)\r\ncc @eddyb"
  },
  {
    "hash": "03268bbf35d3ff2350d987fe7b60375839abdf2e",
    "author": "bors",
    "date": 1420469463,
    "message": "auto merge of #20514 : alexcrichton/rust/serialize-associated-type, r=aturon\n\nThis commit moves the libserialize crate (and will force the hand of the\r\nrustc-serialize crate) to not require the `old_orphan_check` feature gate as\r\nwell as using associated types wherever possible. Concretely, the following\r\nchanges were made:\r\n\r\n* The error type of `Encoder` and `Decoder` is now an associated type, meaning\r\n  that these traits have no type parameters.\r\n\r\n* The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`\r\n  traits have moved to the corresponding method of the trait. This movement\r\n  alleviates the dependency on `old_orphan_check` but implies that\r\n  implementations can no longer be specialized for the type of encoder/decoder\r\n  being implemented.\r\n\r\nDue to the trait definitions changing, this is a:\r\n\r\n[breaking-change]"
  },
  {
    "hash": "0cb7a4062a3c69bb0c54f0c9136889a1006e4f62",
    "author": "Alex Crichton",
    "date": 1420441166,
    "message": "serialize: Use assoc types + less old_orphan_check\n\nThis commit moves the libserialize crate (and will force the hand of the\nrustc-serialize crate) to not require the `old_orphan_check` feature gate as\nwell as using associated types wherever possible. Concretely, the following\nchanges were made:\n\n* The error type of `Encoder` and `Decoder` is now an associated type, meaning\n  that these traits have no type parameters.\n\n* The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`\n  traits have moved to the corresponding method of the trait. This movement\n  alleviates the dependency on `old_orphan_check` but implies that\n  implementations can no longer be specialized for the type of encoder/decoder\n  being implemented.\n\nDue to the trait definitions changing, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "0302d379776fca82d3eb693046239dc66998f691",
    "author": "Huon Wilson",
    "date": 1420421451,
    "message": "Merge `UnicodeChar` and `CharExt`.\n\nThis \"reexports\" all the functionality of `core::char::CharExt` as\nmethods on `unicode::u_char::UnicodeChar` (renamed to `CharExt`).\n\nImports may need to be updated (one now just imports\n`unicode::CharExt`, or `std::char::CharExt` rather than two traits from\neither), so this is a\n\n[breaking-change]"
  },
  {
    "hash": "19120209d8e532514203d16a2cff0ad3b44de3bb",
    "author": "Huon Wilson",
    "date": 1420421430,
    "message": "Rename `core::char::Char` to `CharExt` to match prelude guidelines.\n\nImports may need to be updated so this is a\n\n[breaking-change]"
  },
  {
    "hash": "f031285c3a76b86525695bbb5b46daa9e77df200",
    "author": "Corey Farwell",
    "date": 1420256156,
    "message": "Remove graphviz::LabelText::* public reexport\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "c6c786671d692d7b13c2e5c68a53001327b4b125",
    "author": "bors",
    "date": 1420332659,
    "message": "auto merge of #20490 : japaric/rust/assoc-types, r=aturon\n\ncloses #20486 \r\ncloses #20474 \r\ncloses #20441\r\n\r\n[breaking-change]\r\n\r\nThe `Index[Mut]` traits now have one less input parameter, as the return type of the indexing operation is an associated type. This breaks all existing implementations.\r\n\r\n---\r\n\r\nbinop traits (`Add`, `Sub`, etc) now have an associated type for their return type. Also, the RHS input parameter now defaults to `Self` (except for the `Shl` and `Shr` traits). For example, the `Add` trait now looks like this:\r\n\r\n``` rust\r\ntrait Add<Rhs=Self> {\r\n    type Output;\r\n\r\n    fn add(self, Rhs) -> Self::Output;\r\n}\r\n```\r\n\r\nThe `Neg` and `Not` traits now also have an associated type for their return type.\r\n\r\nThis breaks all existing implementations of these traits.\r\n\r\n---\r\nAffected traits:\r\n\r\n- `Iterator { type Item }`\r\n- `IteratorExt` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `DoubleEndedIterator` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `DoubleEndedIteratorExt` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `RandomAccessIterator` no input/output types\r\n- `ExactSizeIterator` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n\r\nThis breaks all the implementations of these traits."
  },
  {
    "hash": "9c3e6082e71618c088afd93f7a4a9a7708c9dcbd",
    "author": "bors",
    "date": 1420255521,
    "message": "auto merge of #20154 : P1start/rust/qualified-assoc-type-generics, r=nikomatsakis\n\nThis modifies `Parser::eat_lt` to always split up `<<`s, instead of doing so only when a lifetime name followed or the `force` parameter (now removed) was `true`. This is because `Foo<<TYPE` is now a valid start to a type, whereas previously only `Foo<<LIFETIME` was valid.\r\n\r\nThis is a [breaking-change]. Change code that looks like this:\r\n\r\n```rust\r\nlet x = foo as bar << 13;\r\n```\r\n\r\nto use parentheses, like this:\r\n\r\n```rust\r\nlet x = (foo as bar) << 13;\r\n```\r\n\r\nCloses #17362."
  },
  {
    "hash": "d9769ec3834b62318da892925dc24c8883bb1635",
    "author": "P1start",
    "date": 1419487127,
    "message": "Parse fully-qualified associated types in generics without whitespace\n\nThis breaks code that looks like this:\n\n    let x = foo as bar << 13;\n\nChange such code to look like this:\n\n    let x = (foo as bar) << 13;\n\nCloses #17362.\n\n[breaking-change]"
  },
  {
    "hash": "7506fe52696c5b3b628f173d74dc4a13b5ccc1f3",
    "author": "Nick Cameron",
    "date": 1420193122,
    "message": "Accept `derive` instead of `deriving`\n\n[breaking-change]\n\n`deriving is still accepted, but gives a deprecation warning"
  },
  {
    "hash": "74d11d26f4042ce04c56edfd6caafa003383147d",
    "author": "Nick Cameron",
    "date": 1420193122,
    "message": "Accept `self` in place of `mod` in use items\n\n[breaking-change]\n\n`mod` is still accepted, but gives a deprecated warning"
  },
  {
    "hash": "c61a0092bc236c4be4cb691fcd50ff50e91ab0d6",
    "author": "Niko Matsakis",
    "date": 1420189569,
    "message": "Fix orphan checking (cc #19470). (This is not a complete fix of #19470 because of the backwards compatibility feature gate.)\n\nThis is a [breaking-change]. The new rules require that, for an impl of a trait defined\nin some other crate, two conditions must hold:\n\n1. Some type must be local.\n2. Every type parameter must appear \"under\" some local type.\n\nHere are some examples that are legal:\n\n```rust\nstruct MyStruct<T> { ... }\n\n// Here `T` appears \"under' `MyStruct`.\nimpl<T> Clone for MyStruct<T> { }\n\n// Here `T` appears \"under' `MyStruct` as well. Note that it also appears\n// elsewhere.\nimpl<T> Iterator<T> for MyStruct<T> { }\n```\n\nHere is an illegal example:\n\n```rust\n// Here `U` does not appear \"under\" `MyStruct` or any other local type.\n// We call `U` \"uncovered\".\nimpl<T,U> Iterator<U> for MyStruct<T> { }\n```\n\nThere are a couple of ways to rewrite this last example so that it is\nlegal:\n\n1. In some cases, the uncovered type parameter (here, `U`) should be converted\n   into an associated type. This is however a non-local change that requires access\n   to the original trait. Also, associated types are not fully baked.\n2. Add `U` as a type parameter of `MyStruct`:\n   ```rust\n   struct MyStruct<T,U> { ... }\n   impl<T,U> Iterator<U> for MyStruct<T,U> { }\n   ```\n3. Create a newtype wrapper for `U`\n   ```rust\n   impl<T,U> Iterator<Wrapper<U>> for MyStruct<T,U> { }\n   ```\n\nBecause associated types are not fully baked, which in the case of the\n`Hash` trait makes adhering to this rule impossible, you can\ntemporarily disable this rule in your crate by using\n`#![feature(old_orphan_check)]`. Note that the `old_orphan_check`\nfeature will be removed before 1.0 is released."
  },
  {
    "hash": "9ca8076cb77a7d7738162c80e1d240ef2ad0b73a",
    "author": "Alex Crichton",
    "date": 1420219357,
    "message": "rollup merge of #20386: frewsxcv/rm-reexports\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "f9ce6f5ba458d6a3d4e63b282bac43a18e90aeb0",
    "author": "Corey Farwell",
    "date": 1420082881,
    "message": "Remove core::iter::MinMaxResult::* public reexport\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "f3a7ec7028c76b3a1c6051131328f372b068e33a",
    "author": "Alex Crichton",
    "date": 1420178579,
    "message": "std: Second pass stabilization of sync\n\nThis pass performs a second pass of stabilization through the `std::sync`\nmodule, avoiding modules/types that are being handled in other PRs (e.g.\nmutexes, rwlocks, condvars, and channels).\n\nThe following items are now stable\n\n* `sync::atomic`\n* `sync::atomic::ATOMIC_BOOL_INIT` (was `INIT_ATOMIC_BOOL`)\n* `sync::atomic::ATOMIC_INT_INIT` (was `INIT_ATOMIC_INT`)\n* `sync::atomic::ATOMIC_UINT_INIT` (was `INIT_ATOMIC_UINT`)\n* `sync::Once`\n* `sync::ONCE_INIT`\n* `sync::Once::call_once` (was `doit`)\n  * C == `pthread_once(..)`\n  * Boost == `call_once(..)`\n  * Windows == `InitOnceExecuteOnce`\n* `sync::Barrier`\n* `sync::Barrier::new`\n* `sync::Barrier::wait` (now returns a `bool`)\n* `sync::Semaphore::new`\n* `sync::Semaphore::acquire`\n* `sync::Semaphore::release`\n\nThe following items remain unstable\n\n* `sync::SemaphoreGuard`\n* `sync::Semaphore::access` - it's unclear how this relates to the poisoning\n                              story of mutexes.\n* `sync::TaskPool` - the semantics of a failing task and whether a thread is\n                     re-attached to a thread pool are somewhat unclear, and the\n                     utility of this type in `sync` is question with respect to\n                     the jobs of other primitives. This type will likely become\n                     stable or move out of the standard library over time.\n* `sync::Future` - futures as-is have yet to be deeply re-evaluated with the\n                   recent core changes to Rust's synchronization story, and will\n                   likely become stable in the future but are unstable until\n                   that time comes.\n\n[breaking-change]"
  },
  {
    "hash": "f2ccdfd8914b7b8f8f8f2053f9ecd98d54ef95a6",
    "author": "Alex Crichton",
    "date": 1420180313,
    "message": "std: Second pass stabilization for `boxed`\n\nThis commit performs a second pass over the `std::boxed` module, taking the\nfollowing actions:\n\n* `boxed` is now stable\n* `Box` is now stable\n* `BoxAny` is removed in favor of a direct `impl Box<Any>`\n* `Box::downcast` remains unstable while the name of the `downcast` family of\n  methods is determined.\n\nThis is a breaking change due to the removal of the `BoxAny` trait (note that\nthe `downcast` method still exists), and existing consumers of `BoxAny` simply\nneed to remove the import in their modules.\n\n[breaking-change]"
  },
  {
    "hash": "a6f5b980cc44621efeed847e8d359f3b90c29080",
    "author": "Alex Crichton",
    "date": 1420070700,
    "message": "rustc: Re-jigger -L and -l for MSYS compatibility\n\nAs discovered in #20376, the MSYS shell will silently rewrite arguemnts that\nlook like unix paths into their windows path counterparts for compatibility, but\nthe recently added `:kind` syntax added to the `-L` flag does not allow for this\nform of rewriting. This means that the syntax can be difficult to use at an MSYS\nprompt, as well as causing tests to fail when run manuall right now.\n\nThis commit takes the other option presented in the original issue to prefix the\npath with `kind=` instead of suffixing it with `:kind`. For consistence, the\n`-l` flag is also now migrating to `kind=name`.\n\nThis is a breaking change due to the *removal* of behavior with `-L`. All code\nusing `:kind` should now pass `kind=` for `-L` arguments. This is not currently,\nbut will become, a breaking change for `-l` flags. The old `name:kind` syntax is\nstill accepted, but all code should update to `kind=name`.\n\n[breaking-change]\nCloses #20376"
  },
  {
    "hash": "e423fcf0e0166da55f88233e0be5eacba55bc0bc",
    "author": "Alex Crichton",
    "date": 1420178686,
    "message": "std: Enforce Unicode in fmt::Writer\n\nThis commit is an implementation of [RFC 526][rfc] which is a change to alter\nthe definition of the old `fmt::FormatWriter`. The new trait, renamed to\n`Writer`, now only exposes one method `write_str` in order to guarantee that all\nimplementations of the formatting traits can only produce valid Unicode.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0526-fmt-text-writer.md\n\nOne of the primary improvements of this patch is the performance of the\n`.to_string()` method by avoiding an almost-always redundant UTF-8 check. This\nis a breaking change due to the renaming of the trait as well as the loss of the\n`write` method, but migration paths should be relatively easy:\n\n* All usage of `write` should move to `write_str`. If truly binary data was\n  being written in an implementation of `Show`, then it will need to use a\n  different trait or an altogether different code path.\n\n* All usage of `write!` should continue to work as-is with no modifications.\n\n* All usage of `Show` where implementations just delegate to another should\n  continue to work as-is.\n\n[breaking-change]\n\nCloses #20352"
  },
  {
    "hash": "bc83a009f655dd3896be4a7cd33cac8032a605f2",
    "author": "Alex Crichton",
    "date": 1419884209,
    "message": "std: Second pass stabilization for `comm`\n\nThis commit is a second pass stabilization for the `std::comm` module,\nperforming the following actions:\n\n* The entire `std::comm` module was moved under `std::sync::mpsc`. This movement\n  reflects that channels are just yet another synchronization primitive, and\n  they don't necessarily deserve a special place outside of the other\n  concurrency primitives that the standard library offers.\n* The `send` and `recv` methods have all been removed.\n* The `send_opt` and `recv_opt` methods have been renamed to `send` and `recv`.\n  This means that all send/receive operations return a `Result` now indicating\n  whether the operation was successful or not.\n* The error type of `send` is now a `SendError` to implement a custom error\n  message and allow for `unwrap()`. The error type contains an `into_inner`\n  method to extract the value.\n* The error type of `recv` is now `RecvError` for the same reasons as `send`.\n* The `TryRecvError` and `TrySendError` types have had public reexports removed\n  of their variants and the variant names have been tweaked with enum\n  namespacing rules.\n* The `Messages` iterator is renamed to `Iter`\n\nThis functionality is now all `#[stable]`:\n\n* `Sender`\n* `SyncSender`\n* `Receiver`\n* `std::sync::mpsc`\n* `channel`\n* `sync_channel`\n* `Iter`\n* `Sender::send`\n* `Sender::clone`\n* `SyncSender::send`\n* `SyncSender::try_send`\n* `SyncSender::clone`\n* `Receiver::recv`\n* `Receiver::try_recv`\n* `Receiver::iter`\n* `SendError`\n* `RecvError`\n* `TrySendError::{mod, Full, Disconnected}`\n* `TryRecvError::{mod, Empty, Disconnected}`\n* `SendError::into_inner`\n* `TrySendError::into_inner`\n\nThis is a breaking change due to the modification of where this module is\nlocated, as well as the changing of the semantics of `send` and `recv`. Most\nprograms just need to rename imports of `std::comm` to `std::sync::mpsc` and\nadd calls to `unwrap` after a send or a receive operation.\n\n[breaking-change]"
  },
  {
    "hash": "c32d03f4172580e3f33e4844ed3c01234dca2d53",
    "author": "Alex Crichton",
    "date": 1419872301,
    "message": "std: Stabilize the prelude module\n\nThis commit is an implementation of [RFC 503][rfc] which is a stabilization\nstory for the prelude. Most of the RFC was directly applied, removing reexports.\nSome reexports are kept around, however:\n\n* `range` remains until range syntax has landed to reduce churn.\n* `Path` and `GenericPath` remain until path reform lands. This is done to\n  prevent many imports of `GenericPath` which will soon be removed.\n* All `io` traits remain until I/O reform lands so imports can be rewritten all\n  at once to `std::io::prelude::*`.\n\nThis is a breaking change because many prelude reexports have been removed, and\nthe RFC can be consulted for the exact list of removed reexports, as well as to\nfind the locations of where to import them.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md\n[breaking-change]\n\nCloses #20068"
  },
  {
    "hash": "56290a004493a5d2e211f056601533253497df60",
    "author": "Alex Crichton",
    "date": 1420217646,
    "message": "std: Stabilize the prelude module\n\nThis commit is an implementation of [RFC 503][rfc] which is a stabilization\nstory for the prelude. Most of the RFC was directly applied, removing reexports.\nSome reexports are kept around, however:\n\n* `range` remains until range syntax has landed to reduce churn.\n* `Path` and `GenericPath` remain until path reform lands. This is done to\n  prevent many imports of `GenericPath` which will soon be removed.\n* All `io` traits remain until I/O reform lands so imports can be rewritten all\n  at once to `std::io::prelude::*`.\n\nThis is a breaking change because many prelude reexports have been removed, and\nthe RFC can be consulted for the exact list of removed reexports, as well as to\nfind the locations of where to import them.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md\n[breaking-change]\n\nCloses #20068"
  },
  {
    "hash": "71b46b18a274edc7f7fb60b490e5ebbb9c911462",
    "author": "bors",
    "date": 1420213885,
    "message": "auto merge of #20356 : Gankro/rust/stab, r=aturon\n\nThis stabilizes most of libcollections, carefully avoiding sections of API which are being managed in other PRs. APIs which are not stable are marked explicitly unstable with a reason.\r\n\r\nDeprecates:\r\n\r\n* DList\r\n  * rotate_forward\r\n  * rotate_backward\r\n  * prepend\r\n  * insert_when\r\n  * insert_ordered\r\n  * merge\r\n\r\n* VecMap\r\n  * update\r\n  * update_with_key\r\n\r\n* Renames and newtypes the Bitv and BitvSet iterators to match conventions.\r\n\r\n* Removes the Copy impl from DList's Iter.\r\n\r\nas such this is a\r\n\r\n[breaking-change]"
  },
  {
    "hash": "d45b5d2ed9b43b3ad573482fb8820a382f20289e",
    "author": "Nick Cameron",
    "date": 1420147699,
    "message": "Disallow [_, ..n] syntax for fixed length arrays and repeating array constructors\n\nCloses #19999\n\n[breaking-change]\n\nUse [_; n] instead."
  },
  {
    "hash": "39d74026663597a8d4ad0ab04e6d117bf9fd6ad4",
    "author": "bors",
    "date": 1420127468,
    "message": "auto merge of #20190 : cmr/rust/gate-macro-args, r=alexcrichton\n\nUses the same approach as https://github.com/rust-lang/rust/pull/17286 (and\r\nsubsequent changes making it more correct), where the visitor will skip any\r\npieces of the AST that are from \"foreign code\", where the spans don't line up,\r\nindicating that that piece of code is due to a macro expansion.\r\n\r\nIf this breaks your code, read the error message to determine which feature\r\ngate you should add to your crate.\r\n\r\nCloses #18102\r\n\r\n[breaking-change]"
  },
  {
    "hash": "41da99dff417eadf8f296a93529d9810f79e1d1b",
    "author": "Corey Richardson",
    "date": 1420114006,
    "message": "Feature gate macro arguments\n\nUses the same approach as https://github.com/rust-lang/rust/pull/17286 (and\nsubsequent changes making it more correct), where the visitor will skip any\npieces of the AST that are from \"foreign code\", where the spans don't line up,\nindicating that that piece of code is due to a macro expansion.\n\nIf this breaks your code, read the error message to determine which feature\ngate you should add to your crate, and bask in the knowledge that your code\nwon't mysteriously break should you try to use the 1.0 release.\n\nCloses #18102\n\n[breaking-change]"
  },
  {
    "hash": "47b8479e73e40395f1b1b2d0c6281f28f80301e4",
    "author": "bors",
    "date": 1420084862,
    "message": "auto merge of #20363 : japaric/rust/moar-uc, r=nmatsakis\n\nThe the last argument of the `ItemDecorator::expand` method has changed to `Box<FnMut>`. Syntax extensions will break.\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nThis PR removes pretty much all the remaining uses of boxed closures from the libraries. There are still boxed closures under the `test` directory, but I think those should be removed or replaced with unboxed closures at the same time we remove boxed closures from the language.\r\n\r\nIn a few places I had to do some contortions (see the first commit for an example) to work around issue #19596. I have marked those workarounds with FIXMEs. In the future when `&mut F where F: FnMut` implements the `FnMut` trait, we should be able to remove those workarounds. I've take care to avoid placing the workaround functions in the public API.\r\n\r\nSince `let f = || {}` always gets type checked as a boxed closure, I have explictly annotated those closures (with e.g. `|&:| {}`) to force the compiler to type check them as unboxed closures.\r\n\r\nInstead of removing the type aliases (like `GetCrateDataCb`), I could have replaced them with newtypes. But this seemed like overcomplicating things for little to no gain.\r\n\r\nI think we should be able to remove the boxed closures from the languge after this PR lands. (I'm being optimistic here)\r\n\r\nr? @alexcrichton or @aturon \r\ncc @nikomatsakis"
  },
  {
    "hash": "e91d810b9b36d6bb163970cd0e8bbf4692f704bb",
    "author": "Aaron Turon",
    "date": 1419969742,
    "message": "Libs: Unify concat and concat_vec\n\nWe've long had traits `StrVector` and `VectorVector` providing\n`concat`/`connect` and `concat_vec`/`connect_vec` respectively. The\nreason for the distinction is that coherence rules did not used to be\nrobust enough to allow impls on e.g. `Vec<String>` versus `Vec<&[T]>`.\n\nThis commit consolidates the traits into a single `SliceConcatExt` trait\nprovided by `slice` and the preldue (where it replaces `StrVector`,\nwhich is removed.)\n\n[breaking-change]"
  },
  {
    "hash": "4f863a338e0a7c33f81a8ac138103f1a0e8b33c5",
    "author": "Aaron Turon",
    "date": 1419969742,
    "message": "Second pass stabilization: slice\n\nThis commit takes a second pass through the `slice` module to\nstabilize its API. The changes are as follows:\n\n**Stable**:\n\n* `as_mut_slice`\n* `as_ptr`, `as_mut_ptr`\n* `binary_search_by` (was: `binary_search`)\n* `binary_search` (was: `binary_search_elem`)\n* `chunks`, `chunks_mut`\n* `contains`\n* `ends_with`\n* `first`, `first_mut` (was: `head`)\n* `get_unchecked`, `get_unchecked_mut` (was: `unsafe_get`)\n* `get`\n* `is_empty`\n* `iter`, `iter_mut`\n* `len`\n* `reverse`\n* `sort_by`\n* `sort`\n* `split_at`, `split_at_mut`\n* `split_mut`, `splitn_mut`, `rsplitn_mut`\n* `split`, `splitn`, `rsplitn`\n* `starts_with`\n* `swap`\n* `to_vec`\n* `windows`\n\n**Deprecated**:\n\n* `head`, `head_mut` (renamed as above)\n* `unsafe_get`, `unsafe_mut` (renamed as above)\n* `binary_search_elem` (renamed as above)\n* `partitioned`, deprecated in favor of a new, more\n  general iterator consumer called `partition`.\n* `BinarySearchResult`, deprecated in favor of `Result<uint, uint>`\n\n[breaking-change]"
  },
  {
    "hash": "9d919d2302b5df42e3bf8979560e0da21f4b2bad",
    "author": "Aaron Turon",
    "date": 1419969742,
    "message": "Second pass stabilization: vec\n\nThis commit takes a second pass through the `vec` module to\nstabilize its API. The changes are as follows:\n\n**Stable**:\n\n* `dedup`\n* `from_raw_parts`\n* `insert`\n* `into_iter`\n* `is_empty`\n* `remove`\n* `reserve_exact`\n* `reserve`\n* `retain`\n* `swap_remove`\n* `truncate`\n\n**Deprecated**:\n\n* `from_fn`, `from_elem`, `grow_fn` and `grow`, all deprecated in\n  favor of iterators. See https://github.com/rust-lang/rfcs/pull/509\n\n* `partition`, `partitioned`, deprecated in favor of a new, more\n  general iterator consumer called `partition`.\n\n* `unzip`, deprecated in favor of a new, more general iterator\n  consumer called `unzip`.\n\nA few remaining methods are left at experimental status.\n\n[breaking-change]"
  },
  {
    "hash": "38f9805f11721d854a59818e0ad7b8a0b6282301",
    "author": "Alex Crichton",
    "date": 1419985582,
    "message": "rollup merge of #20348: frewsxcv/rm-reexports\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "1d26fb9e07e664b312ca9d7b666f6d1dd52285ed",
    "author": "Corey Farwell",
    "date": 1419968631,
    "message": "Remove core::atomic::Ordering::* public reexport\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "b94bcbf56eab163517e8ffc93888284b8dbb6238",
    "author": "Aaron Turon",
    "date": 1419979466,
    "message": "Stabilize cmp\n\nThis patch marks `PartialEq`, `Eq`, `PartialOrd`, and `Ord` as\n`#[stable]`, as well as the majorify of manual implementaitons of these\ntraits. The traits match the [reform\nRFC](https://github.com/rust-lang/rfcs/pull/439).\n\nAlong the way, two changes are made:\n\n* The recently-added type parameters for `Ord` and `Eq` are\n  removed. These were mistakenly added while adding them to `PartialOrd`\n  and `PartialEq`, but they don't make sense given the laws that are\n  required for (and use cases for) `Ord` and `Eq`.\n\n* More explicit laws are added for `PartialEq` and `PartialOrd`,\n  connecting them to their associated mathematical concepts.\n\nIn the future, many of the impls should be generalized; see\nsince generalizing later is not a breaking change.\n\n[breaking-change]"
  },
  {
    "hash": "79db01a30d22950ad1597d495b76d2f58da859dc",
    "author": "Alex Crichton",
    "date": 1419899812,
    "message": "rollup merge of #20306: alexcrichton/second-pass-string\n\nThis commit performs a second pass over the `std::string` module, performing the\nfollowing actions:\n\n* The name `std::string` is now stable.\n* The `String::from_utf8` function is now stable after having been altered to\n  return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now\n  stable as well as its `into_bytes` and `utf8_error` methods.\n* The `String::from_utf8_lossy` function is now stable.\n* The `String::from_chars` method is now deprecated in favor of `.collect()`\n* The `String::from_raw_parts` method is now stable\n* The `String::from_str` function remains experimental\n* The `String::from_raw_buf` function remains experimental\n* The `String::from_raw_buf_len` function remains experimental\n* The `String::from_utf8_unchecked` function is now stable\n* The `String::from_char` function is now deprecated in favor of\n  `repeat(c).take(n).collect()`\n* The `String::grow` function is now deprecated in favor of\n  `.extend(repeat(c).take(n)`\n* The `String::capacity` method is now stable\n* The `String::reserve` method is now stable\n* The `String::reserve_exact` method is now stable\n* The `String::shrink_to_fit` method is now stable\n* The `String::pop` method is now stable\n* The `String::as_mut_vec` method is now stable\n* The `String::is_empty` method is now stable\n* The `IntoString` trait is now deprecated (there are no implementors)\n* The `String::truncate` method is now stable\n* The `String::insert` method is now stable\n* The `String::remove` method is now stable\n* The `String::push` method is now stable\n* The `String::push_str` method is now stable\n* The `String::from_utf16` function is now stable after its error type has now\n  become an opaque structure to carry more semantic information in the future.\n\nA number of these changes are breaking changes, but the migrations should be\nfairly straightforward on a case-by-case basis (outlined above where possible).\n\n[breaking-change]"
  },
  {
    "hash": "b26daf3a67a4e283a5e2c49227b60a2321434de0",
    "author": "Alex Crichton",
    "date": 1419891076,
    "message": "std: Second pass stabilization for `string`\n\nThis commit performs a second pass over the `std::string` module, performing the\nfollowing actions:\n\n* The name `std::string` is now stable.\n* The `String::from_utf8` function is now stable after having been altered to\n  return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now\n  stable as well as its `into_bytes` and `utf8_error` methods.\n* The `String::from_utf8_lossy` function is now stable.\n* The `String::from_chars` method is now deprecated in favor of `.collect()`\n* The `String::from_raw_parts` method is now stable\n* The `String::from_str` function remains experimental\n* The `String::from_raw_buf` function remains experimental\n* The `String::from_raw_buf_len` function remains experimental\n* The `String::from_utf8_unchecked` function is now stable\n* The `String::from_char` function is now deprecated in favor of\n  `repeat(c).take(n).collect()`\n* The `String::grow` function is now deprecated in favor of\n  `.extend(repeat(c).take(n)`\n* The `String::capacity` method is now stable\n* The `String::reserve` method is now stable\n* The `String::reserve_exact` method is now stable\n* The `String::shrink_to_fit` method is now stable\n* The `String::pop` method is now stable\n* The `String::as_mut_vec` method is now stable\n* The `String::is_empty` method is now stable\n* The `IntoString` trait is now deprecated (there are no implementors)\n* The `String::truncate` method is now stable\n* The `String::insert` method is now stable\n* The `String::remove` method is now stable\n* The `String::push` method is now stable\n* The `String::push_str` method is now stable\n* The `String::from_utf16` function is now stable after its error type has now\n  become an opaque structure to carry more semantic information in the future.\n\nA number of these changes are breaking changes, but the migrations should be\nfairly straightforward on a case-by-case basis (outlined above where possible).\n\n[breaking-change]"
  },
  {
    "hash": "f53314cd70dd194ea40c55a5d8ceae7b94409aea",
    "author": "Nick Cameron",
    "date": 1419830349,
    "message": "Remove the glob/shadowing exception bug\n\n[breaking-change]\n\nThis and the other commit in this PR change the rules for shadowing and globs to be\nstricter. There were previously bugs where some glob imports would not be checked\nfor shadowing. Those are now fixed and you may have to adjust your imports to use\nfewer globs."
  },
  {
    "hash": "1e89bbcb67020892bc0af5af218c35f0fd453fa4",
    "author": "Simonas Kazlauskas",
    "date": 1419767195,
    "message": "Rename TaskRng to ThreadRng\n\nSince runtime is removed, rust has no tasks anymore and everything is moving\nfrom being task-* to thread-*. Let‚Äôs rename TaskRng as well!\n\n* Rename TaskRng to ThreadRng\n* Rename task_rng to thread_rng\n\n[breaking-change]"
  },
  {
    "hash": "748440c5b3bad8a837918400973e9d6cbb58fa7a",
    "author": "Alex Crichton",
    "date": 1419899766,
    "message": "rollup merge of #20215: csouth3/hashmap-rename\n\nRename struct `Entries` to `Iter` in hash/table.rs and hash/map.rs, to match the naming convention of rust-lang/rfcs#344.\n\nThis is a [breaking-change]."
  }
]