[
  {
    "hash": "6d43fef3aaf64b2e7df14ca676a3a39b723ed7f3",
    "author": "bors",
    "date": 1446385009,
    "message": "Auto merge of #29486 - petrochenkov:multiwild, r=Manishearth\n\nMotivation:\r\n- It is not actually a pattern\r\n- It is not actually needed, except for...\r\n\r\nDrawback:\r\n- Slice patterns like `[a, _.., b]` are pretty-printed as `[a, .., b]`. Great loss :(\r\n\r\nplugin-[breaking-change], as always"
  },
  {
    "hash": "c44316d4a1ad0fe01ae366e163993aa3980c755f",
    "author": "bors",
    "date": 1445848079,
    "message": "Auto merge of #29303 - petrochenkov:unistrimp, r=eddyb\n\nAnd use `VariantData` instead of `P<VariantData>` in `Item_` and `Variant_`\r\n\r\nImprovements suggested by @eddyb in https://github.com/rust-lang/rust/pull/28816#discussion_r42483587 and https://github.com/rust-lang/rust/pull/28816#discussion_r42483648\r\n\r\nplugin-[breaking-change]\r\n\r\nr? @eddyb"
  },
  {
    "hash": "04e497c0056aed899cd6edbc98e7a68a9b391c5c",
    "author": "bors",
    "date": 1445689272,
    "message": "Auto merge of #29259 - arielb1:supertrait-self-2, r=eddyb\n\nâ€¦being it\r\n\r\nThis is a [breaking-change]:lang, but the broken code does not make\r\nmuch sense.\r\n\r\nFixes #26056\r\n\r\nr? @eddyb"
  },
  {
    "hash": "5d6d26c241b785daef873a0c6b9a0553c3a9451d",
    "author": "Ariel Ben-Yehuda",
    "date": 1445635349,
    "message": "object_safety: check whether a supertrait contains Self even without being it\n\nThis is a [breaking-change]:lang, but the broken code does not make\nmuch sense.\n\nFixes #26056"
  },
  {
    "hash": "97ba52ec379e17cc0984224b756282b68bc3a53b",
    "author": "bors",
    "date": 1445367747,
    "message": "Auto merge of #29148 - petrochenkov:noshow, r=alexcrichton\n\nCloses https://github.com/rust-lang/rust/issues/29145\r\n\r\n[breaking-change], needs a crater run."
  },
  {
    "hash": "d6bd8d8491e89277edbfc9a4e0f8953847abbdd6",
    "author": "Andrew Paseltiner",
    "date": 1445034931,
    "message": "Add `Shared` pointer and have `{Arc, Rc}` use it\n\nThis change has two consequences:\n\n1. It makes `Arc<T>` and `Rc<T>` covariant in `T`.\n\n2. It causes the compiler to reject code that was unsound with respect\nto dropck. See compile-fail/issue-29106.rs for an example of code that\nno longer compiles. Because of this, this is a [breaking-change].\n\nFixes #29037.\nFixes #29106."
  },
  {
    "hash": "130851e03046db41d555a401a08c87f187fd911a",
    "author": "bors",
    "date": 1443910057,
    "message": "Auto merge of #28669 - arielb1:well-formed-methods, r=nikomatsakis\n\nBy RFC1214:\r\n>    Before calling a fn, we check that its argument and return types are WF.\r\n    \r\nThe previous code only checked the trait-ref, which was not enough\r\nin several cases.\r\n    \r\nAs this is a soundness fix, it is a [breaking-change]. Some new annotations are needed, which I think are because of #18653 and the imperfection of `projection_must_outlive` (that can probably be worked around by moving the wf obligation later).\r\n    \r\nFixes #28609\r\n\r\nr? @nikomatsakis"
  },
  {
    "hash": "603a75c8eaa8ee168e4333e4fba5eb782ed7192b",
    "author": "Ariel Ben-Yehuda",
    "date": 1443818410,
    "message": "ensure that the types of methods are well-formed\n\nBy RFC1214:\nBefore calling a fn, we check that its argument and return types are WF. This check takes place after all higher-ranked lifetimes have been instantiated. Checking the argument types ensures that the implied bounds due to argument types are correct. Checking the return type ensures that the resulting type of the call is WF.\n\nThe previous code only checked the trait-ref, which was not enough\nin several cases.\n\nAs this is a soundness fix, it is a [breaking-change].\n\nFixes #28609"
  },
  {
    "hash": "ef07d7dd40e33d7af95c7b00717503730ce69c11",
    "author": "bors",
    "date": 1443813399,
    "message": "Auto merge of #28650 - sanxiyn:attr-usage, r=nrc\n\nThis is technically a [breaking-change].\r\n\r\nFix #2809.\r\nFix #22746."
  },
  {
    "hash": "e82faeb65594302897223b2ca4ee6927fb54625f",
    "author": "bors",
    "date": 1443716788,
    "message": "Auto merge of #28742 - nikomatsakis:def-id-encapsulate, r=eddyb\n\nAs described in https://github.com/rust-lang/rfcs/pull/1298, the idea here is to make DefIds independent of changes to the content of other items. They are also *mostly* independent from ordering, so e.g. reordering two functions will change the defids, but it will not change the paths that they expand into (but this is not the case for some things, such as impls).\r\n\r\nThis is a major refactoring, so I did it in slices. The final commit is in some sense The Big One where most of the work is done. The earlier commits just pave the way by gradually refactoring accesses to the `node` field.\r\n\r\nThis is a [breaking-change] for plugin authors. The things you need to do to migrate your code are as follows:\r\n\r\n1. For local def-ids, rather than do `def_id.node`, call `tcx.map.as_local_node_id(def_id)`.\r\n2. To construct a local def-id, call `tcx.map.local_def_id(node_id)`.\r\n3. Note that you cannot make def-ids for any node, but only for \"definitions\" -- which include all items, as well as a number of other things, but not e.g. arbitrary expressions.\r\n4. You can get the path to a def-id by calling `tcx.def_path(def_id)`.\r\n\r\nOne thing that is NOT part of this PR, but which I plan do in a follow-up, is converting uses of the existing `with_path` API to use `def_path`, which is basically the same.\r\n\r\nr? @eddyb (or @nrc)"
  },
  {
    "hash": "587be42d0bd318d6c2f41fe4716e040366dc8951",
    "author": "bors",
    "date": 1443673744,
    "message": "Auto merge of #28605 - alexcrichton:link-native-first, r=brson\n\nThis commit swaps the order of linking local native libraries and upstream\r\nnative libraries on the linker command line. Detail of bugs this can cause can\r\nbe found in #28595, and this change also invalidates the test case that was\r\nadded for #12446 which is now considered a bug because the downstream dependency\r\nwould need to declare that it depends on the native library somehow.\r\n\r\nCloses #28595\r\n[breaking-change]"
  },
  {
    "hash": "5ca60d94316bd56f412ef4c13292237e206babf1",
    "author": "bors",
    "date": 1443127376,
    "message": "Auto merge of #28608 - eddyb:no-place-for-an-old-box, r=pnkfelix\n\nWhile this is technically a [breaking-change], there is no excuse for touching `HEAP`.\r\nr? @pnkfelix"
  },
  {
    "hash": "6a2187414a8c25f485dc788088b4466f595a7dd9",
    "author": "bors",
    "date": 1443120900,
    "message": "Auto merge of #28538 - alevy:make_fixedsizearray_unsafe, r=alexcrichton\n\n[breaking-change]\r\n\r\n`FixedSizeArray` is meant to be implemented for arrays of fixed size only, but can be implemented for anything at the moment. Marking the trait unsafe would make it more reasonable to write unsafe code which operates on fixed size arrays of any size.\r\n\r\nFor example, using `uninitialized` to create a fixed size array and immediately filling it with a fixed value is externally safe:\r\n\r\n```\r\npub fn init_with_nones<T, A: FixedSizeArray<Option<T>>>() -> A {\r\n    let mut res = unsafe { mem::uninitialized() };\r\n    for elm in res.as_mut_slice().iter_mut() {\r\n        *elm = None;\r\n    }\r\n    res\r\n}\r\n```\r\n\r\nBut the same code is not safe if `FixedSizeArray` is implemented for other types:\r\n\r\n```\r\nstruct Foo { foo: usize }\r\nimpl FixedSizeArray<Option<usize>> for Foo {\r\n    fn as_slice(&self) -> &[usize] { &[] }\r\n    fn as_mut_slice(&self) -> &mut [usize] { &mut [] }\r\n}\r\n```\r\n\r\nnow `init_with_nones() : Foo` returns a `Foo` with an undefined value for the field `foo`."
  },
  {
    "hash": "920f32becd5d54864a966900963a376d74d09922",
    "author": "Sebastian Wicki",
    "date": 1442874820,
    "message": "Add `no_default_libraries` target linker option\n\nIf set to false, `-nodefaultlibs` is not passed to the linker. This\nwas the default behavior on Windows, but it should be configurable\nper target.\n\nThis is a [breaking-change] for target specifications that have\nthe `is_like_windows` option set to true. Such targets need to\nset `no_default_libraries` to false in order to restore the old\nbehavior."
  },
  {
    "hash": "a642d853aa29f8ec8486e736be551cf77f34e219",
    "author": "Nick Cameron",
    "date": 1442449006,
    "message": "Change to a multi-trait approach\n\n[breaking-change] for lint authors\n\nYou must now implement LateLintPass or EarlyLintPass as well as LintPass and use either register_late_lint_pass or register_early_lint_pass, rather than register_lint_pass."
  },
  {
    "hash": "76856e19ff3c7c699931d0acee8e61bc0dfec512",
    "author": "Nick Cameron",
    "date": 1442449006,
    "message": "Add an early lint pass for lints that operate on the AST\n\nThere is a minor [breaking-change] for lint authors - some functions which were previously defined on `lint::Context` have moved to a trait - `LintContext`, you may need to import that trait to avoid name resolution errors."
  },
  {
    "hash": "fc4d566b432d48933e27dd65a973c936b564d6e9",
    "author": "bors",
    "date": 1442363724,
    "message": "Auto merge of #28399 - nrc:attrs, r=nikomatsakis\n\nThis could be a [breaking-change] if your lint or syntax extension (is that even possible?) uses HIR attributes or literals."
  },
  {
    "hash": "e9f1b063295c48c97e239ce479b08f192a3eece4",
    "author": "Nick Cameron",
    "date": 1442357826,
    "message": "Use ast attributes every where (remove HIR attributes).\n\nThis could be a [breaking-change] if your lint or syntax extension (is that even possible?) uses HIR attributes or literals."
  },
  {
    "hash": "4d6dc7f9ba9fe61e38d737b29bfe490e835f6921",
    "author": "bors",
    "date": 1442213478,
    "message": "Auto merge of #28396 - arielb1:misplaced-binding, r=eddyb\n\nTechnically a [breaking-change], but the broken code is useless,\r\nlike `i32<Param=()>`.\r\n\r\nFixes #24682\r\n\r\nr? @eddyb"
  },
  {
    "hash": "5d4455510afe3b7f74e04d3125ef8536a63d9e60",
    "author": "Ariel Ben-Yehuda",
    "date": 1442177261,
    "message": "ensure projections are prohibited when type parameters are\n\nTechnically a [breaking-change], but the broken code is useless,\nlike `i32<Param=()>`.\n\nFixes #24682"
  },
  {
    "hash": "ae75ef9e62b7df8c46865cfb907c56cab1f29f81",
    "author": "bors",
    "date": 1441098772,
    "message": "Auto merge of #28137 - nrc:remove-non-multi, r=huonw\n\nThis is a [breaking-change] for syntax extension authors. The fix is to use MultiModifier or MultiDecorator, which have the same functionality but are more flexible. Users of syntax extensions are unaffected."
  },
  {
    "hash": "20e1ea2dd84d5b29414059a4e07ce7327d1bef19",
    "author": "Nick Cameron",
    "date": 1441070163,
    "message": "Remove the Modifier and Decorator kinds of syntax extensions.\n\nThis is a [breaking-change] for syntax extension authors. The fix is to use MultiModifier or MultiDecorator, which have the same functionality but are more flexible. Users of syntax extensions are unaffected."
  },
  {
    "hash": "1f81ef4d0f2547cacc316b01ad03603ad772e38e",
    "author": "Tobias Bucher",
    "date": 1440923045,
    "message": "Atomically set CLOEXEC on duplicated sockets\n\nFor Bitrig, NetBSD and OpenBSD the constant was incorrectly in posix01, when\nit's actually posix08, so we move it. This is a [breaking-change], but we\nalready had one in #27930.\n\nFix NetBSD's F_DUPFD_CLOEXEC constant.\n\nFor a similar feature detection, see this musl thread:\nhttp://comments.gmane.org/gmane.linux.lib.musl.general/2963\n\nThis assumes that an int literal has type `c_int` for varidic functions."
  },
  {
    "hash": "db67cbe43dfce043c664c53d709b91252d5afc9e",
    "author": "bors",
    "date": 1440410628,
    "message": "Auto merge of #27856 - nikomatsakis:move-def-id-to-rustc, r=eddyb\n\nIt doesn't really make sense for DefId to be in libsyntax -- it is concerned with a single crate only. It is the compiler that understands the idea of many crates. (At some point, there might be a useful intermediate point here.) This is a refactoring in support of incr. compilation, which will be adjusting the notion of a DefId to make it more durable across compilations.\r\n\r\nThis will probably be a [breaking-change] for every plugin ever. You need to adjust things as follows:\r\n\r\n    use rustc::middle::def_id::{DefId, LOCAL_CRATE}; // two most common definitions\r\n    ast_util::is_local(def_id) => def_id.is_local()\r\n    ast_util::local_def(node_id) => DefId::local(node_id)"
  },
  {
    "hash": "983d2b3d1a97846c90ea8f689774be8353b340be",
    "author": "bors",
    "date": 1440225053,
    "message": "Auto merge of #27826 - sfackler:wait-timeout-enum, r=alexcrichton\n\nReturning a primitive bool results in a somewhat confusing API - does\r\n`true` indicate success - i.e. no timeout, or that a timeout has\r\noccurred? An explicitly named enum makes it clearer.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton"
  },
  {
    "hash": "42a386fcf89a40e6c3a8806ccf381514c2a77c10",
    "author": "Steven Fackler",
    "date": 1440028815,
    "message": "Make Condvar::wait_timeout return an enum instead of a bool\n\nReturning a primitive bool results in a somewhat confusing API - does\n`true` indicate success - i.e. no timeout, or that a timeout has\noccurred? An explicitly named enum makes it clearer.\n\n[breaking-change]"
  },
  {
    "hash": "c66554cab3518a9f5c36eafd622ca4c8a3fda631",
    "author": "Huon Wilson",
    "date": 1439847697,
    "message": "switch core::simd to repr(simd) and deprecate it.\n\nThis functionality will be available out of tree in the `simd` crate on\ncrates.io.\n\n[breaking-change]"
  },
  {
    "hash": "bb954cfa75ec63b2cf28229ecc4aee7024381d0b",
    "author": "bors",
    "date": 1439472578,
    "message": "Auto merge of #27307 - rkruppe:dec2flt, r=pnkfelix\n\nCompletely rewrite the conversion of decimal strings to `f64` and `f32`. The code is intended to be absolutely positively completely 100% accurate (when it doesn't give up). To the best of my knowledge, it achieves that goal. Any input that is not rejected is converted to the floating point number that is closest to the true value of the input. This includes overflow, subnormal numbers, and underflow to zero. In other words, the rounding error is less than or equal to 0.5 units in the last place. Half-way cases (exactly 0.5 ULP error) are handled with half-to-even rounding, also known as banker's rounding.\r\n\r\nThis code implements the algorithms from the paper [How to Read Floating Point Numbers Accurately][paper] by William D. Clinger, with extensions to handle underflow, overflow and subnormals, as well as some algorithmic optimizations.\r\n\r\n# Correctness\r\n\r\nWith such a large amount of tricky code, many bugs are to be expected. Indeed tracking down the obscure causes of various rounding errors accounts for the bulk of the development time. Extensive tests (taking in the order of hours to run through to completion) are included in `src/etc/test-float-parse`: Though exhaustively testing all possible inputs is impossible, I've had good success with generating millions of instances from various \"classes\" of inputs. These tests take far too long to be run by @bors so contributors who touch this code need the discipline to run them. There are `#[test]`s, but they don't even cover every stupid mistake I made in course of writing this.\r\n\r\nAnother aspect is *integer* overflow. Extreme (or malicious) inputs could cause overflow both in the machine-sized integers used for bookkeeping throughout the algorithms (e.g., the decimal exponent) as well as the arbitrary-precision arithmetic. There is input validation to reject all such cases I know of, and I am quite sure nobody will *accidentally* cause this code to go out of range. Still, no guarantees.\r\n\r\n# Limitations\r\n\r\nNoticed the weasel words \"(when it doesn't give up)\" at the beginning? Some otherwise well-formed decimal strings are rejected because spelling out the value of the input requires too many digits, i.e., `digits * 10^abs(exp)` can't be stored in a bignum. This only applies if the value is not \"obviously\" zero or infinite, i.e., if you take a near-infinity or near-zero value and add many pointless fractional digits. At least with the algorithm used here, computing the precise value would require computing the full value as a fraction, which would overflow. The precise limit is `number_of_digits + abs(exp) > 375` but could be raised almost arbitrarily. In the future, another algorithm might lift this restriction entirely.\r\n\r\nThis should not be an issue for any realistic inputs. Still, the code does reject inputs that would result in a finite float when evaluated with unlimited precision. Some of these inputs are even regressions that the old code (mostly) handled, such as `0.333...333` with 400+ `3`s. Thus this might qualify as [breaking-change].\r\n\r\n# Performance\r\n\r\nBenchmarks results are... tolerable. Short numbers that hit the fast paths (`f64` multiplication or shortcuts to zero/inf) have performance in the same order of magnitude as the old code tens of nanoseconds. Numbers that are delegated to Algorithm Bellerophon (using floats with 64 bit significand, implemented in software) are slower, but not drastically so (couple hundred nanoseconds).\r\n\r\nNumbers that need the AlgorithmM fallback (for `f64`, roughly everything below 1e-305 and above 1e305) take far, far longer, hundreds of microseconds. Note that my implementation is not quite as naive as the expository version in the paper (it needs one to four division instead of ~1000), but division is fundamentally pretty expensive and my implementation of it is extremely simple and slow.\r\n\r\nAll benchmarks run on a mediocre laptop with a i5-4200U CPU under light load.\r\n\r\n# Binary size\r\n\r\nUnfortunately the implementation needs to duplicate almost all code: Once for `f32` and once for `f64`. Before you ask, no, this cannot be avoided, at least not completely (but see the Future Work section). There's also a precomputed table of powers of ten, weighing in at about six kilobytes.\r\n\r\nRunning a stage1 `rustc` over a stand-alone program that simply parses pi to `f32` and `f64` and outputs both results reveals that the overhead vs. the old parsing code is about 44 KiB normally and about 28 KiB with LTO. It's presumably half of that + 3 KiB when only one of the two code paths is exercised.\r\n\r\n| rustc options                 | old       | new       | delta         |\r\n|---------------------------    |---------  |---------  |-----------    |\r\n| [nothing]                     | 2588375   | 2633828   | 44.39 KiB     |\r\n| -O                            | 2585211   | 2630688   | 44.41 KiB     |\r\n| -O -C lto                     | 1026353   | 1054981   | 27.96 KiB     |\r\n| -O -C lto -C link-args=-s     | 414208    | 442368    | 27.5 KiB      |\r\n\r\n# Future Work\r\n\r\n## Directory layout\r\n\r\nThe `dec2flt` code uses some types embedded deeply in the `flt2dec` module hierarchy, even though nothing about them it formatting-specific. They should be moved to a more conversion-direction-agnostic location at some point.\r\n\r\n## Performance\r\n\r\nIt could be much better, especially for large inputs. Some low-hanging fruit has been picked but much more work could be done. Some specific ideas are jotted down in `FIXME`s all over the code.\r\n\r\n## Binary size\r\n\r\nOne could try to compress the table further, though I am skeptical. Another avenue would be reducing the code duplication from basically everything being generic over `T: RawFloat`. Perhaps one can reduce the magnitude of the duplication by pushing the parts that don't need to know the target type into separate functions, but this is finicky and probably makes some code read less naturally.\r\n\r\n## Other bases\r\n\r\nThis PR leaves `f{32,64}::from_str_radix` alone. It only replaces `FromStr` (and thus `.parse()`). I am convinced that `from_str_radix` should not exist, and have proposed its [deprecation and speedy removal][deprecate-radix]. Whatever the outcome of that discussion, it is independent from, and out of scope for, this PR.\r\n\r\nFixes #24557\r\nFixes #14353\r\n\r\nr? @pnkfelix\r\n\r\ncc @lifthrasiir @huonw \r\n\r\n[paper]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152\r\n[deprecate-radix]: https://internals.rust-lang.org/t/deprecate-f-32-64-from-str-radix/2405"
  },
  {
    "hash": "ba792a4baa856d83c3001afa181db91c5b4c9732",
    "author": "Robin Kruppe",
    "date": 1439046931,
    "message": "Accurate decimal-to-float parsing routines.\n\nThis commit primarily adds implementations of the algorithms from William\nClinger's paper \"How to Read Floating Point Numbers Accurately\". It also\nincludes a lot of infrastructure necessary for those algorithms, and some\nunit tests.\n\nSince these algorithms reject a few (extreme) inputs that were previously\naccepted, this could be seen as a [breaking-change]"
  },
  {
    "hash": "50141d7e1e5b1b539d45240dff709fa68e7472c2",
    "author": "bors",
    "date": 1439264836,
    "message": "Auto merge of #26818 - sfackler:duration-stabilization, r=aturon\n\nThis commit stabilizes the `std::time` module and the `Duration` type.\r\n`Duration::span` remains unstable, and the `Display` implementation for\r\n`Duration` has been removed as it is still being reworked and all trait\r\nimplementations for stable types are de facto stable.\r\n\r\nThis is a [breaking-change] to those using `Duration`'s `Display`\r\nimplementation.\r\n\r\nI'm opening this PR as a platform for discussion - there may be some method renaming to do as part of the stabilization process."
  },
  {
    "hash": "999bdeca88a06938ac1e1c608091d3afe4d7e173",
    "author": "Steven Fackler",
    "date": 1439251458,
    "message": "Stabilize the Duration API\n\nThis commit stabilizes the `std::time` module and the `Duration` type.\n`Duration::span` remains unstable, and the `Display` implementation for\n`Duration` has been removed as it is still being reworked and all trait\nimplementations for stable types are de facto stable.\n\nThis is a [breaking-change] to those using `Duration`'s `Display`\nimplementation."
  },
  {
    "hash": "87055a68c3194db212456f99ece080728a5fc2f8",
    "author": "bors",
    "date": 1438251923,
    "message": "Auto merge of #27371 - Gankro:str-clone, r=alexcrichton\n\nThis is a minor [breaking-change], as it changes what\r\n`boxed_str.to_owned()` does (previously it would deref to `&str` and\r\ncall `to_owned` on that to get a `String`). However `Box<str>` is such an\r\nexceptionally rare type that this is not expected to be a serious\r\nconcern. Also a `Box<str>` can be freely converted to a `String` to\r\nobtain the previous result anyway."
  },
  {
    "hash": "3e954a8cb2fd094d79713059d83d37b2daa7b396",
    "author": "Alexis Beingessner",
    "date": 1438220581,
    "message": "implement Clone for Box<str>, closes #27323\n\nThis is a minor [breaking-change], as it changes what\n`boxed_str.to_owned()` does (previously it would deref to `&str` and\ncall `to_owned` on that to get a `String`). However `Box<str>` is such an\nexceptionally rare type that this is not expected to be a serious\nconcern. Also a `Box<str>` can be freely converted to a `String` to\nobtain the previous behaviour anyway."
  },
  {
    "hash": "757b0c176fa185fda59283efaf0d8079b702ca69",
    "author": "Ariel Ben-Yehuda",
    "date": 1438102268,
    "message": "prohibit the lhs of an @-pattern being a constant\n\nas this breaks code that worked under some conditions, this is a\n[breaking-change]\n\nFixes #27033\nFixes #27077"
  },
  {
    "hash": "d576ef3d7be3efe28f902bbb3b2197f4553db412",
    "author": "bors",
    "date": 1438152475,
    "message": "Auto merge of #27261 - arielb1:drop-sanity-check, r=pnkfelix\n\nThis fixes multiple bugs, and as several of these are soundness issue, is a [breaking-change].\r\n\r\nr? @pnkfelix"
  },
  {
    "hash": "bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544",
    "author": "Ariel Ben-Yehuda",
    "date": 1437770777,
    "message": "handle all type variants correctly in dropck\n\nThis fixes a few soundness bugs in dropck, so to anyone who relied on them,\nthis is a\n[breaking-change]\n\nFixes #24086.\nFixes #25389.\nFixes #25598.\nFixes #25750.\nFixes #26641.\nFixes #26657.\nFixes #27240.\nFixes #27241."
  },
  {
    "hash": "55ede7ed8e4f3752c371f7d04da4695ba9aa1c26",
    "author": "bors",
    "date": 1438118068,
    "message": "Auto merge of #27234 - oli-obk:move_get_name_get_ident_to_impl, r=eddyb\n\nthis has quite some fallout. but also made lots of stuff more readable imo\r\n\r\n[breaking-change] for plugin authors"
  },
  {
    "hash": "661a5ad38e79f336976b529aa717871d177ab7ed",
    "author": "bors",
    "date": 1438096500,
    "message": "Auto merge of #26173 - pnkfelix:fsk-trans-nzmove-take3, r=nikomatsakis\n\nAdd dropflag hints (stack-local booleans) for unfragmented paths in trans.  Part of #5016.\r\n\r\nAdded code to maintain these hints at runtime, and to conditionalize drop-filling and calls to destructors.\r\n\r\nIn this early stage of my incremental implementation strategy, we are using hints, so we are always free to leave out a flag for a path -- then we just pass `None` as the dropflag hint in the corresponding schedule cleanup call. But, once a path has a hint, we must at least maintain it: i.e. if the hint exists, we must ensure it is never set to \"moved\" if the data in question might actually have been initialized. It remains sound to conservatively set the hint to \"initialized\" as long as the true drop-flag embedded in the value itself is up-to-date.\r\n\r\nI hope the commit series has been broken up to be readable; most of the commits in the series should build (though I did not always check this).\r\n\r\n----\r\n\r\nOh, I think this technically qualifies as a:\r\n[breaking-change]\r\nbecause it removes drop-filling in some cases where one could previously observe it. That should only affect `unsafe` code; no safe code should be able to inspect whether the drop-fill was present or not. For an example of code that needed to change to account for this, see commit a81c24ae0216ab47df59acd724f8a33124fb6d97 (a unit test of the `move_val_init` intrinsic).  I have not encountered actual code that needed to be updated to account for the change, since this should only be skipping the drop-filling on *moved* values, not on dropped one, and so even types that use `unsafe_no_drop_flag` should be unchanged by this particular PR. (Their time will come later.)"
  },
  {
    "hash": "18557500cb91596f3614d4cf65439f8c5f47b2e0",
    "author": "bors",
    "date": 1437410313,
    "message": "Auto merge of #27026 - nagisa:overflowing-unsigned, r=pnkfelix\n\nThis commit fixes the negate_unsigned feature gate to appropriately\r\naccount for inferred variables.\r\n\r\nThis is technically a [breaking-change], but Iâ€™d consider it a bug fix.\r\n\r\ncc @brson for your relnotes.\r\n\r\nFixes https://github.com/rust-lang/rust/issues/24676\r\nFixes #26840 \r\nFixes https://github.com/rust-lang/rust/issues/25206"
  },
  {
    "hash": "0c9e3dc75cf2b2d122af0596225594240ed254eb",
    "author": "Simonas Kazlauskas",
    "date": 1436899723,
    "message": "Fix negate_unsigned feature gate check\n\nThis commit fixes the negate_unsigned feature gate to appropriately\naccount for infered variables.\n\nThis is technically a [breaking-change]."
  },
  {
    "hash": "e05ac3938bcbdd616930bb010a3bbfa35f22850e",
    "author": "bors",
    "date": 1437158150,
    "message": "Auto merge of #27045 - nikomatsakis:better-object-defaults-error, r=pnkfelix\n\nTransition to the new object lifetime defaults, replacing the old defaults completely.\r\n\r\nr? @pnkfelix \r\n\r\nThis is a [breaking-change] as specified by [RFC 1156][1156] (though all cases that would break should have been receiving warnings starting in Rust 1.2). Types like `&'a Box<Trait>` (or `&'a Rc<Trait>`, etc) will change from being interpreted as `&'a Box<Trait+'a>` to `&'a Box<Trait+'static>`. To restore the old behavior, write the `+'a` explicitly. For example, the function:\r\n\r\n\r\n```rust\r\ntrait Trait { }\r\nfn foo(x: &Box<Trait>) { ... }\r\n```\r\n\r\nwould be rewritten as:\r\n\r\n```rust\r\ntrait Trait { }\r\nfn foo(x: &'a Box<Trait+'a>) { ... }\r\n```\r\n\r\nif one wanted to preserve the current typing.\r\n\r\n[1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md"
  },
  {
    "hash": "6b27005f2f8b20834838828588233b877a29d509",
    "author": "Ariel Ben-Yehuda",
    "date": 1436008166,
    "message": "require reimplementations of all items when a defaulted associated type is overriden\n\nThis is a\n[breaking-change]\nbut it follows the RFC (not sure whether it will be accepted)."
  },
  {
    "hash": "f027bdc1c8a133693651f333624b756abe21960f",
    "author": "bors",
    "date": 1435959106,
    "message": "Auto merge of #26378 - arielb1:unused-mut, r=pnkfelix\n\nThis makes it somewhat more aggressive, so this is kind-of a [breaking-change] for these compiling with `#[deny(unused_mut)]`.\r\n\r\nr? @pnkfelix"
  },
  {
    "hash": "31d9aee68499cba8d1a5332b841eca5c67991001",
    "author": "bors",
    "date": 1434931860,
    "message": "Auto merge of #26394 - arielb1:implement-rfc401-part2, r=nrc\n\nThis makes them compliant with the new version of RFC 401 (i.e.\r\n    RFC 1052).\r\n\r\nFixes #26391. I *hope* the tests I have are enough.\r\n\r\nThis is a [breaking-change]\r\n\r\nr? @nrc"
  },
  {
    "hash": "ea7637ebc0e5d325ccf0537a8013316c2ed78108",
    "author": "Ariel Ben-Yehuda",
    "date": 1434631866,
    "message": "Prohibit casts between fat pointers to different traits\n\nThis makes them compliant with the new version of RFC 401 (i.e.\n    RFC 1052).\n\nFixes #26391. I *hope* the tests I have are enough.\n\nThis is a [breaking-change]"
  },
  {
    "hash": "713d9176adc5072afdf0934dc95b868995e867c0",
    "author": "bors",
    "date": 1434581417,
    "message": "Auto merge of #26326 - nikomatsakis:optimize-fulfillment-cache-in-tcx, r=pcwalton\n\nWhen we successfully resolve a trait reference with no type/lifetime parameters, like `i32: Foo` or `Box<u32>: Sized`, this is in fact globally true. This patch adds a simple global to the tcx to cache such cases. The main advantage of this is really about caching things like `Box<Vec<Foo>>: Sized`. It also points to the need to revamp our caching infrastructure -- the current caches make selection cost cheaper, but we still wind up paying a high cost in the confirmation process, and in particular unrolling out dependent obligations. Moreover, we should probably do caching more uniformly and with a key that takes the where-clauses into account. But that's for later.\r\n\r\nFor me, this shows up as a reasonably nice win (20%) on Servo's script crate (when built in dev mode). This is not as big as my initial measurements suggested, I think because I was building my rustc with more debugging enabled at the time. I've not yet done follow-up profiling and so forth to see where the new hot spots are. Bootstrap times seem to be largely unaffected.\r\n\r\ncc @pcwalton \r\n\r\nThis is technically a [breaking-change] in that functions with unsatisfiable where-clauses may now yield errors where before they may have been accepted. Even before, these functions could never have been *called* by actual code. In the future, such functions will probably become illegal altogether, but in this commit they are still accepted, so long as they do not rely on the unsatisfiable where-clauses. As before, the functions still cannot be called in any case."
  },
  {
    "hash": "73fb19c04ac227fe2aad2c618f76b6eb05dd7ec9",
    "author": "bors",
    "date": 1434397935,
    "message": "Auto merge of #26275 - arielb1:unconstrained-projection, r=nikomatsakis\n\nFixes #26262\r\n\r\nBecause this rejects code that previously compiled, this is a [breaking-change]\r\n\r\nr? @nikomatsakis"
  },
  {
    "hash": "7517ecf4fc9cfe2adff8a38ecc2ef660692a4b5b",
    "author": "bors",
    "date": 1434350682,
    "message": "Auto merge of #26168 - sfackler:stdout-panic, r=alexcrichton\n\nCloses #25977\r\n\r\nThe various `stdfoo_raw` methods in std::io now return `io::Result`s,\r\nsince they may not exist on Windows. They will always return `Ok` on\r\nUnix-like platforms.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "a7bbd7da4eb98127104fdfd415ad6c746f7e2a12",
    "author": "Steven Fackler",
    "date": 1434338226,
    "message": "Implement RFC 1014\n\nCloses #25977\n\nThe various `stdfoo_raw` methods in std::io now return `io::Result`s,\nsince they may not exist on Windows. They will always return `Ok` on\nUnix-like platforms.\n\n[breaking-change]"
  },
  {
    "hash": "7648776503040b302fe0589311fb27afe7c1e6cc",
    "author": "bors",
    "date": 1434067227,
    "message": "Auto merge of #26225 - arielb1:raw-self, r=eddyb\n\nThis can't be made to work with the current setup.\r\n\r\nTechnically a [breaking-change], but a simple bug fix.\r\n\r\nFixes #26194."
  },
  {
    "hash": "b70f49b86fa4d8780f46e869880e84e1c24c2f19",
    "author": "bors",
    "date": 1433355669,
    "message": "Auto merge of #24910 - steveklabnik:remove_static_assert, r=alexcrichton\n\nThis was always a weird feature, and isn't being used in the compiler.\r\nStatic assertions should be done better than this.\r\n\r\nFixes #13951\r\nFixes #23008\r\nFixes #6676\r\n\r\nThis is behind a feature gate, but that's still a\r\n\r\n[breaking-change]\r\n\r\n(It's not entirely clear to me that this should or shouldn't have an RFC, but if it does, I'm fine blocking on such a thing.)"
  },
  {
    "hash": "5235065d740cad78ab55a89299fc1f5d32bf8f46",
    "author": "Steve Klabnik",
    "date": 1433338693,
    "message": "Remove #[static_assert]\n\nThis was always a weird feature, and isn't being used in the compiler.\nStatic assertions should be done better than this.\n\nThis implements RFC #1096.\n\nFixes #13951\nFixes #23008\nFixes #6676\n\nThis is behind a feature gate, but that's still a\n\n[breaking-change]"
  },
  {
    "hash": "32211e1d27c258c62cafb6ba357e67db932367bf",
    "author": "Ulrik Sverdrup",
    "date": 1433016940,
    "message": "Mark Arc function get_mut and method make_unique unsafe\n\nThis is a temporary mitigation for issue #24880 which points out that\nthese functions are racy in a particular situation where weak pointers\nexist.\n\nTo mitigate this, mark the functions unsafe until this can be fixed or\nanother decision is made.\n\nThis is a breaking change to unstable API, because the new version\nrequires an `unsafe` block. Review carefully if weak pointers may race\nfor any uses of this API and consider abandoning it.\n\n[breaking-change]"
  },
  {
    "hash": "bd85983d059151c9ef07dbd11a35f1d16463eb94",
    "author": "Steven Fackler",
    "date": 1431909209,
    "message": "Make debug builders take &mut self, add entries method\n\n[breaking-change]"
  },
  {
    "hash": "c23a9d42ea082830593a73d25821842baf9ccf33",
    "author": "bors",
    "date": 1431821134,
    "message": "Auto merge of #25387 - eddyb:syn-file-loader, r=nikomatsakis\n\nThis allows compiling entire crates from memory or preprocessing source files before they are tokenized.\r\n\r\nMinor API refactoring included, which is a [breaking-change] for libsyntax users:\r\n* `ParseSess::{next_node_id, reserve_node_ids}` moved to rustc's `Session`\r\n* `new_parse_sess` -> `ParseSess::new`\r\n* `new_parse_sess_special_handler` -> `ParseSess::with_span_handler`\r\n* `mk_span_handler` -> `SpanHandler::new`\r\n* `default_handler` -> `Handler::new`\r\n* `mk_handler` -> `Handler::with_emitter`\r\n* `string_to_filemap(sess source, path)` -> `sess.codemap().new_filemap(path, source)`"
  },
  {
    "hash": "2e07b0d6be3d2ffcfb154b5cbbe02bc166014172",
    "author": "Adolfo OchagavÃ­a",
    "date": 1422700727,
    "message": "Deprecate SyntaxExtension::Modifier\n\nReplaced by SyntaxExtension::MultiModifier\n\n[breaking-change]"
  },
  {
    "hash": "6f233aaa0c743cc6ca7e42d7dcd4b7d92ef4ad9a",
    "author": "Adolfo OchagavÃ­a",
    "date": 1422700727,
    "message": "Deprecate SyntaxExtension::Decorator\n\nIt has been replaced by SyntaxExtension::MultiDecorator\n\n[breaking-change]"
  },
  {
    "hash": "57690399a2ab6dd579ea1f97e9866b213f8b14d4",
    "author": "Adolfo OchagavÃ­a",
    "date": 1422700725,
    "message": "Deprecate ItemDecorator in favor of MultiItemDecorator\n\n[breaking-change]"
  },
  {
    "hash": "53579e6d866eea41f2d3d8d0ddff42c73e75cea1",
    "author": "Adolfo OchagavÃ­a",
    "date": 1422700724,
    "message": "Deprecate ItemModifier in favor of MultiItemModifier\n\n[breaking-change]"
  },
  {
    "hash": "67ba6dcf68860d8a20891faad88a33b35ed58df5",
    "author": "bors",
    "date": 1431183416,
    "message": "Auto merge of #24612 - lifthrasiir:flt2dec, r=pnkfelix\n\nThis is a direct port of my prior work on the float formatting. The detailed description is available [here](https://github.com/lifthrasiir/rust-strconv#flt2dec). In brief,\r\n\r\n* This adds a new hidden module `core::num::flt2dec` for testing from `libcoretest`. Why is it in `core::num` instead of `core::fmt`? Because I envision that the table used by `flt2dec` is directly applicable to `dec2flt` (cf. #24557) as well, which exceeds the realm of \"formatting\".\r\n* This contains both Dragon4 algorithm (exact, complete but slow) and Grisu3 algorithm (exact, fast but incomplete).\r\n* The code is accompanied with a large amount of self-tests and some exhaustive tests. In particular, `libcoretest` gets a new dependency on `librand`. For the external interface it relies on the existing test suite.\r\n* It is known that, in the best case, the entire formatting code has about 30 KBs of binary overhead (judged from strconv experiments). Not too bad but there might be a potential room for improvements.\r\n\r\nThis is rather large code. I did my best to comment and annotate the code, but you have been warned.\r\n\r\nFor the maximal availability the original code was licensed in CC0, but I've also dual-licensed it in MIT/Apache as well so there should be no licensing concern.\r\n\r\nThis is [breaking-change] as it changes the float output slightly (and it also affects the casing of `inf` and `nan`). I hope this is not a big deal though :)\r\n\r\nFixes #7030, #18038 and #24556. Also related to #6220 and #20870.\r\n\r\n## Known Issues\r\n\r\n- [x] I've yet to finish `make check-stage1`. It does pass main test suites including `run-pass` but there might be some unknown edges on the doctests.\r\n- [ ] Figure out how this PR affects rustc.\r\n- [ ] Determine which internal routine is mapped to the formatting specifier. Depending on the decision, some internal routine can be safely removed (for instance, currently `to_shortest_str` is unused)."
  },
  {
    "hash": "5aa9f38285b47e2eadaaac0e343da90b922994f1",
    "author": "Kang Seonghoon",
    "date": 1430889701,
    "message": "core: made the core formatter to use a new flt2dec.\n\nAs a side effect `core::fmt::float` is gone now. This also slightly\nchanges the float output, so this is:\n\n[breaking-change]"
  },
  {
    "hash": "3906edf41e8faa0610daea954ffbda39841fbc0d",
    "author": "bors",
    "date": 1431163243,
    "message": "Auto merge of #25212 - pnkfelix:dropck-box-trait, r=nikomatsakis\n\ndropck: must assume `Box<Trait + 'a>` has a destructor of interest.\r\n\r\nFix #25199.\r\n\r\nThis detail was documented in [RFC 769]; the implementation was just missing.\r\n\r\n[breaking-change]\r\n\r\nThe breakage here falls into both obvious and non-obvious cases.\r\n\r\nThe obvious case: if you were relying on the unsoundness this exposes (namely being able to reference dead storage from a destructor, by doing it via a boxed trait object bounded by the lifetime of the dead storage), then this change disallows that.\r\n\r\nThe non-obvious cases: The way dropck works, it causes lifetimes to be extended to longer extents than they covered before. I.e.  lifetimes that are attached as trait-bounds may become longer than they were previously.\r\n\r\n* This includes lifetimes that are only *implicitly* attached as trait-bounds (due to [RFC 599]). So you may have code that was e.g. taking a parameter of type `&'a Box<Trait>` (which expands to `&'a Box<Trait+'a>`), that now may need to be assigned type `&'a Box<Trait+'static>` to ensure that `'a` is not inadvertantly inferred to a region that is actually too long.  (See commit ee06263 for an example of this.)\r\n\r\n[RFC 769]: https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#the-drop-check-rule\r\n\r\n[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md"
  },
  {
    "hash": "b5b5a177588c0e8dfc6b9e79540bcbd1eeb9ef91",
    "author": "Felix S. Klock II",
    "date": 1431090376,
    "message": "dropck: must assume `Box<Trait + 'a>` has a destructor of interest.\n\nImplements this (previously overlooked) note from [RFC 769]:\n\n> (Note: When encountering a D of the form `Box<Trait+'b>`, we\n> conservatively assume that such a type has a Drop implementation\n> parametric in 'b.)\n\nFix #25199.\n\n[breaking-change]\n\nThe breakage here falls into both obvious and non-obvious cases.\n\nThe obvious case: if you were relying on the unsoundness this exposes\n(namely being able to reference dead storage from a destructor, by\ndoing it via a boxed trait object bounded by the lifetime of the dead\nstorage), then this change disallows that.\n\nThe non-obvious cases: The way dropck works, it causes lifetimes to be\nextended to longer extents than they covered before. I.e.  lifetimes\nthat are attached as trait-bounds may become longer than they were\npreviously.\n\n* This includes lifetimes that are only *implicitly* attached as\n  trait-bounds (due to [RFC 599]). So you may have code that was\n  e.g. taking a parameter of type `&'a Box<Trait>` (which expands to\n  `&'a Box<Trait+'a>`), that now may need to be assigned type `&'a\n  Box<Trait+'static>` to ensure that `'a` is not inadvertantly\n  inferred to a region that is actually too long.  (See earlier commit\n  in this PR for an example of this.)\n\n[RFC 769]: https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#the-drop-check-rule\n\n[RFC 599]: https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md"
  },
  {
    "hash": "5ae026e8923d71d16a4d2b9a592bbcab92d8723a",
    "author": "bors",
    "date": 1431035111,
    "message": "Auto merge of #25157 - alexcrichton:remove-vec-add, r=aturon\n\nIdeally this trait implementation would be unstable, requiring crates to opt-in\r\nif they would like the functionality, but that's not currently how stability\r\nworks so the implementation needs to be removed entirely.\r\n\r\nThis may come back at a future date, but for now the conservative option is to\r\nremove it.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "8d3f84e235b22688dd1592cfb86f31459a79ac5f",
    "author": "Alex Crichton",
    "date": 1430934754,
    "message": "std: Remove addition on vectors for now\n\nIdeally this trait implementation would be unstable, requiring crates to opt-in\nif they would like the functionality, but that's not currently how stability\nworks so the implementation needs to be removed entirely.\n\nThis may come back at a future date, but for now the conservative option is to\nremove it.\n\n[breaking-change]"
  },
  {
    "hash": "d131f335579b8c080a2416a65ca703169fae560b",
    "author": "Sean McArthur",
    "date": 1430889983,
    "message": "lint: deny transmuting from immutable to mutable, since it's undefined behavior\n\n[breaking-change] Technically breaking, since code that had been using\nthese transmutes before will no longer compile. However, it was\nundefined behavior, so really, it's a good thing. Fixing your code would\nrequire some re-working to use an UnsafeCell instead.\n\nCloses #13146"
  },
  {
    "hash": "eae692e375cec222803efb7175c79fedc228eea9",
    "author": "bors",
    "date": 1430849907,
    "message": "Auto merge of #25009 - alexcrichton:less-buffered-stream, r=aturon\n\nAs pointed out in #17136 the semantics of a `BufStream` aren't always what one\r\nexpects, and it looks like other [languages like C#][c-sharp] implement a\r\nbuffered stream with only one underlying buffer. For now this commit\r\ndestabilizes the primitive in the `std::io` module to give us some more time in\r\nfiguring out what to do with it.\r\n\r\n[c-sharp]: https://msdn.microsoft.com/en-us/library/system.io.bufferedstream%28v=vs.110%29.aspx\r\n\r\n[breaking-change]"
  },
  {
    "hash": "db477eef72924c7b34e9617627eaae37c71bdc1c",
    "author": "Alex Crichton",
    "date": 1430434978,
    "message": "std: Destabilize io::BufStream\n\nAs pointed out in #17136 the semantics of a `BufStream` aren't always what one\nexpects, and it looks like other [languages like C#][c-sharp] implement a\nbuffered stream with only one underlying buffer. For now this commit\ndestabilizes the primitive in the `std::io` module to give us some more time in\nfiguring out what to do with it.\n\n[c-sharp]: https://msdn.microsoft.com/en-us/library/system.io.bufferedstream%28v=vs.110%29.aspx\n\n[breaking-change]"
  },
  {
    "hash": "f6574c5b0404f55c4dd4056be47d37eff33684b5",
    "author": "bors",
    "date": 1430520849,
    "message": "Auto merge of #25006 - alexcrichton:unstable-indexing, r=aturon\n\nThese implementations were intended to be unstable, but currently the stability\r\nattributes cannot handle a stable trait with an unstable `impl` block. This\r\ncommit also audits the rest of the standard library for explicitly-`#[unstable]`\r\nimpl blocks. No others were removed but some annotations were changed to\r\n`#[stable]` as they're defacto stable anyway.\r\n\r\nOne particularly interesting `impl` marked `#[stable]` as part of this commit\r\nis the `Add<&[T]>` impl for `Vec<T>`, which uses `push_all` and implicitly\r\nclones all elements of the vector provided.\r\n\r\nCloses #24791\r\n\r\n[breaking-change]"
  },
  {
    "hash": "5c710b593b429d39ea01375172a9ce968f43ab26",
    "author": "bors",
    "date": 1430454173,
    "message": "Auto merge of #24793 - aturon:io-error-any, r=alexcrichton\n\nThis commit brings the `Error` trait in line with the [Error interoperation\r\nRFC](https://github.com/rust-lang/rfcs/pull/201) by adding downcasting,\r\nwhich has long been intended. This change means that for any `Error`\r\ntrait objects that are `'static`, you can downcast to concrete error\r\ntypes.\r\n\r\nTo make this work, it is necessary for `Error` to inherit from\r\n`Reflect` (which is currently used to mark concrete types as \"permitted\r\nfor reflection, aka downcasting\"). This is a breaking change: it means\r\nthat impls like\r\n\r\n```rust\r\nimpl<T> Error for MyErrorType<T> { ... }\r\n```\r\n\r\nmust change to\r\n\r\n```rust\r\nimpl<T: Reflect> Error for MyErrorType<T> { ... }\r\n```\r\n\r\nThis commit furthermore marks `Reflect` as stable, since we are already\r\nessentially committed to it via `Any`. Note that in the future, if we\r\ndetermine that the parametricity aspects of `Reflect` are not needed, we\r\ncan deprecate the trait and provide a blanket implementation for it\r\nfor *all* types (rather than by using OIBIT), which would allow all\r\nmentions of `Reflect` to be dropped over time. So there is not a strong\r\ncommitment here.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton"
  },
  {
    "hash": "a5762625a168f195afbc5b74d674a93f8c692a8e",
    "author": "Aaron Turon",
    "date": 1430443222,
    "message": "Add downcasting to std::error::Error\n\nThis commit brings the `Error` trait in line with the [Error interoperation\nRFC](https://github.com/rust-lang/rfcs/pull/201) by adding downcasting,\nwhich has long been intended. This change means that for any `Error`\ntrait objects that are `'static`, you can downcast to concrete error\ntypes.\n\nTo make this work, it is necessary for `Error` to inherit from\n`Reflect` (which is currently used to mark concrete types as \"permitted\nfor reflection, aka downcasting\"). This is a breaking change: it means\nthat impls like\n\n```rust\nimpl<T> Error for MyErrorType<T> { ... }\n```\n\nmust change to something like\n\n```rust\nimpl<T: Reflect> Error for MyErrorType<T> { ... }\n```\n\nexcept that `Reflect` is currently unstable (and should remain so for\nthe time being). For now, code can instead bound by `Any`:\n\n```rust\nimpl<T: Any> Error for MyErrorType<T> { ... }\n```\n\nwhich *is* stable and has `Reflect` as a super trait. The downside is\nthat this imposes a `'static` constraint, but that only\nconstrains *when* `Error` is implemented -- it does not actually\nconstrain the types that can implement `Error`.\n\n[breaking-change]"
  },
  {
    "hash": "b475fc7d6aa1cafa91790c273908fddfb669a82e",
    "author": "Ulrik Sverdrup",
    "date": 1430213913,
    "message": "collections: Implement vec::drain(range) according to RFC 574\n\nOld `.drain()` on vec is performed using `.drain(..)` now.\n\n`.drain(range)` is unstable and under feature(collections_drain)\n\n[breaking-change]"
  },
  {
    "hash": "441b3f0c26c2e30ddb012be968141da7ce7d9d62",
    "author": "bors",
    "date": 1430241156,
    "message": "Auto merge of #24906 - pnkfelix:fsk-fix-24895, r=alexcrichton\n\ndropck: Remove `Copy` from special-cased traits\r\n\r\nFix #24895.\r\n\r\n[breaking-change]\r\n\r\nWhat does this break?  Basically, code that implements `Drop` and is\r\nusing `T:Copy` for one of its type parameters and is relying on the\r\nDrop Check rule not applying to it.\r\n\r\nHere is an example:\r\n\r\n```rust\r\n#![allow(dead_code,unused_variables,unused_assignments)]\r\nstruct D<T:Copy>(T);\r\nimpl<T:Copy> Drop for D<T> { fn drop(&mut self) { } }\r\n\r\ntrait UserT { fn c(&self) { } }\r\nimpl<T:Copy> UserT for T { }\r\nstruct E<T:UserT>(T);\r\nimpl<T:UserT> Drop for E<T> { fn drop(&mut self) { } }\r\n\r\n// This one will start breaking.\r\nfn foo() { let (d2, d1); d1 = D(34); d2 = D(&d1); }\r\n\r\n#[cfg(this_one_does_and_should_always_break)]\r\nfn bar() { let (e2, e1); e1 = E(34); e2 = E(&e1); }\r\n\r\nfn main() {\r\n    foo();\r\n}\r\n```"
  },
  {
    "hash": "b892264ea4f048feb5f380d3e659d82ba463f5b7",
    "author": "Felix S. Klock II",
    "date": 1430236036,
    "message": "Fix #24895.\n\n[breaking-change]\n\nWhat does this break?  Basically, code that implements `Drop` and is\nusing `T:Copy` for one of its type parameters and is relying on the\nDrop Check rule not applying to it.\n\nHere is an example:\n\n```rust\n#![allow(dead_code,unused_variables,unused_assignments)]\nstruct D<T:Copy>(T);\nimpl<T:Copy> Drop for D<T> { fn drop(&mut self) { } }\n\ntrait UserT { fn c(&self) { } }\nimpl<T:Copy> UserT for T { }\nstruct E<T:UserT>(T);\nimpl<T:UserT> Drop for E<T> { fn drop(&mut self) { } }\n\n// This one will start breaking.\nfn foo() { let (d2, d1); d1 = D(34); d2 = D(&d1); }\n\n#[cfg(this_one_does_and_should_always_break)]\nfn bar() { let (e2, e1); e1 = E(34); e2 = E(&e1); }\n\nfn main() {\n    foo();\n}\n```"
  },
  {
    "hash": "9c88f3be126d0fe02a92c20e1d78192f4b648401",
    "author": "bors",
    "date": 1430167608,
    "message": "Auto merge of #24765 - pnkfelix:fsk-enum-swapindrop, r=nikomatsakis\n\nInspect enum discriminant *after* calling its destructor\r\n\r\nIncludes some drive-by cleanup (e.g. changed some field and method names to reflect fill-on-drop; added comments about zero-variant enums being classified as `_match::Single`).\r\n\r\nProbably the most invasive change was the expansion of the maps `available_drop_glues` and `drop_glues` to now hold two different kinds of drop glues; there is the (old) normal drop glue, and there is (new) drop-contents glue that jumps straight to dropping the contents of a struct or enum, skipping its destructor.\r\n\r\n * For all types that do not have user-defined Drop implementations, the normal glue is generated as usual (i.e. recursively dropping the fields of the data structure).\r\n\r\n  (And this actually is exactly what the newly-added drop-contents glue does as well.)\r\n\r\n * For types that have user-defined Drop implementations, the \"normal\" drop glue now schedules a cleanup before invoking the `Drop::drop` method that will call the drop-contents glue after that invocation returns.\r\n\r\nFix #23611.\r\n\r\n----\r\n\r\nIs this a breaking change?  The prior behavior was totally unsound, and it seems unreasonable that anyone was actually relying on it.\r\n\r\nNonetheless, since there is a user-visible change to the language semantics, I guess I will conservatively mark this as a:\r\n\r\n[breaking-change]\r\n\r\n(To see an example of what sort of user-visible change this causes, see the comments in the regression test.)"
  },
  {
    "hash": "6365080c5cd27b74ec87420c351a3e7bdcff988e",
    "author": "bors",
    "date": 1430041948,
    "message": "Auto merge of #23085 - goffrie:interpolating-quote, r=huonw\n\nThis changes the `ToTokens` implementations for expressions, statements, etc. with almost-trivial ones that produce `Interpolated(*Nt(...))` pseudo-tokens. In this way, quasiquote now works the same way as macros do: already-parsed AST fragments are used as-is, not reparsed.\r\n\r\nThe `ToSource` trait is removed. Quasiquote no longer involves pretty-printing at all, which removes the need for the `encode_with_hygiene` hack. All associated machinery is removed.\r\n\r\nNew `Nonterminal`s are added: NtArm, NtImplItem, and NtTraitItem. These are just for quasiquote, not macros.\r\n\r\n`ToTokens` is no longer implemented for `Arg` (although this could be added again) and `Generics` (which I don't think makes sense).\r\n\r\nThis breaks any compiler extensions that relied on the ability of `ToTokens` to turn AST fragments back into inspectable token trees. For this reason, this closes #16987.\r\n\r\nAs such, this is a [breaking-change].\r\n\r\nFixes #16472.\r\nFixes #15962.\r\nFixes #17397.\r\nFixes #16617."
  },
  {
    "hash": "2d9831dea598d8a45c69e8c799503e8a397aacc0",
    "author": "Geoffry Song",
    "date": 1430012530,
    "message": "Interpolate AST nodes in quasiquote.\n\nThis changes the `ToTokens` implementations for expressions, statements,\netc. with almost-trivial ones that produce `Interpolated(*Nt(...))`\npseudo-tokens. In this way, quasiquote now works the same way as macros\ndo: already-parsed AST fragments are used as-is, not reparsed.\n\nThe `ToSource` trait is removed. Quasiquote no longer involves\npretty-printing at all, which removes the need for the\n`encode_with_hygiene` hack. All associated machinery is removed.\n\nA new `Nonterminal` is added, NtArm, which the parser now interpolates.\nThis is just for quasiquote, not macros (although it could be in the\nfuture).\n\n`ToTokens` is no longer implemented for `Arg` (although this could be\nadded again) and `Generics` (which I don't think makes sense).\n\nThis breaks any compiler extensions that relied on the ability of\n`ToTokens` to turn AST fragments back into inspectable token trees. For\nthis reason, this closes #16987.\n\nAs such, this is a [breaking-change].\n\nFixes #16472.\nFixes #15962.\nFixes #17397.\nFixes #16617."
  },
  {
    "hash": "00c48d3779fb4c372d2dfe7a8654c6cd1e065511",
    "author": "bors",
    "date": 1429998290,
    "message": "Auto merge of #24547 - bombless:comma, r=pnkfelix\n\nCloses #20616 \r\nIt breaks code such as <https://github.com/rust-lang/rust/blob/c64feb63418fd05bd6e5adc6f9ad763aa6a594b1/src/librustc_typeck/check/method/suggest.rs#L367>, so this is a [breaking-change], you have to add missing comma after the last lifetime arguement now."
  },
  {
    "hash": "eeb94886adccb3f13003f92f117115d17846ce1f",
    "author": "Alex Crichton",
    "date": 1429641463,
    "message": "std: Remove deprecated/unstable num functionality\n\nThis commit removes all the old casting/generic traits from `std::num` that are\nno longer in use by the standard library. This additionally removes the old\n`strconv` module which has not seen much use in quite a long time. All generic\nfunctionality has been supplanted with traits in the `num` crate and the\n`strconv` module is supplanted with the [rust-strconv crate][rust-strconv].\n\n[rust-strconv]: https://github.com/lifthrasiir/rust-strconv\n\nThis is a breaking change due to the removal of these deprecated crates, and the\nalternative crates are listed above.\n\n[breaking-change]"
  },
  {
    "hash": "98e9765d973d46faa5c80fb37a48040ca9e87b28",
    "author": "Alex Crichton",
    "date": 1429655286,
    "message": "rollup merge of #24541: alexcrichton/issue-24538\n\nThis is an implementation of [RFC 1030][rfc] which adds these traits to the\nprelude and additionally removes all inherent `into_iter` methods on collections\nin favor of the trait implementation (which is now accessible by default).\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/1030\n\nThis is technically a breaking change due to the prelude additions and removal\nof inherent methods, but it is expected that essentially no code breaks in\npractice.\n\n[breaking-change]\nCloses #24538"
  },
  {
    "hash": "8f5b5f94dcdb9884737dfbc8efd893d1d70f0b14",
    "author": "Alex Crichton",
    "date": 1429313850,
    "message": "std: Add Default/IntoIterator/ToOwned to the prelude\n\nThis is an implementation of [RFC 1030][rfc] which adds these traits to the\nprelude and additionally removes all inherent `into_iter` methods on collections\nin favor of the trait implementation (which is now accessible by default).\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/1030\n\nThis is technically a breaking change due to the prelude additions and removal\nof inherent methods, but it is expected that essentially no code breaks in\npractice.\n\n[breaking-change]\nCloses #24538"
  },
  {
    "hash": "efa6a46a8eceb4ab792d5ec8e28cf3baaaa96491",
    "author": "bors",
    "date": 1429325633,
    "message": "Auto merge of #24133 - kballard:add-sync-to-io-error, r=alexcrichton\n\nThis allows `io::Error` values to be stored in `Arc` properly.\r\n\r\nBecause this requires `Sync` of any value passed to `io::Error::new()`\r\nand modifies the relevant `convert::From` impls, this is a\r\n\r\n[breaking-change]\r\n\r\nFixes #24049."
  },
  {
    "hash": "986852911464df87088007e64780165cc538f9b9",
    "author": "Kevin Ballard",
    "date": 1428366023,
    "message": "Add `Sync` to the bounds in `io::Error`\n\nThis allows `io::Error` values to be stored in `Arc` properly.\n\nBecause this requires `Sync` of any value passed to `io::Error::new()`\nand modifies the relevant `convert::From` impls, this is a\n\n[breaking-change]\n\nFixes #24049."
  },
  {
    "hash": "e40449e0d545561c73a9b9b324b5971b533a87b7",
    "author": "bors",
    "date": 1429147024,
    "message": "Auto merge of #24485 - brson:is, r=alexcrichton\n\nIt was an oversight that this was not done in the great int upheaval.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "5a3a599428f5af024857d19b5d360b148e885fa2",
    "author": "Brian Anderson",
    "date": 1429139606,
    "message": "Forbid is/us suffixes. Fixes #22496\n\nIt was an oversight that this was not done in the great int upheaval.\n\n[breaking-change]"
  },
  {
    "hash": "07f807d01f191ced1d7f4857c73fc57fbe31f421",
    "author": "bors",
    "date": 1429131916,
    "message": "Auto merge of #24330 - pnkfelix:issue-24267, r=nikomatsakis\n\nExtend rustc::middle::dataflow to allow filtering kills from flow-exits.\r\n\r\nFix borrowck analysis so that it will not treat a break that pops through an assignment\r\n```rust\r\nx = { ... break; ... }\r\n```\r\nas a kill of the \"moved-out\" bit for `x`.\r\n\r\nFix #24267.\r\n\r\n[breaking-change], but really, its only breaking code that was already buggy."
  },
  {
    "hash": "6e0fb70ff6effe7b7be2c5fe951e9161613e6707",
    "author": "Aaron Turon",
    "date": 1428961697,
    "message": "Generalize `spawn` beyond unit closures\n\n`thread::spawn` was previously restricted to closures that return `()`,\nwhich limited the utility of joining on a spawned thread. However, there\nis no reason for this restriction, and this commit allows arbitrary\nreturn types.\n\nSince it introduces a type parameter to `JoinHandle`, it's technically\na:\n\n[breaking-change]\n\nHowever, no code is actually expected to break."
  },
  {
    "hash": "6399bb425b3a82111cd554737f194c95b8f6bad5",
    "author": "Aaron Turon",
    "date": 1428952528,
    "message": "De-stabilize `thread::scoped` and friends\n\nIssue #24292 demonstrates that the `scoped` API as currently offered can\nbe memory-unsafe: the `JoinGuard` can be moved into a context that will\nfail to execute destructors prior to the stack frame being popped (for\nexample, by creating an `Rc` cycle).\n\nThis commit reverts the APIs to `unstable` status while a long-term\nsolution is worked out.\n\n(There are several possible ways to address this issue; it's not a\nfundamental problem with the `scoped` idea, but rather an indication\nthat Rust doesn't currently provide a good way to ensure that\ndestructors are run within a particular stack frame.)\n\n[breaking-change]"
  },
  {
    "hash": "e6a812402828f0f11b0de7a7e0c08c1d85a437f1",
    "author": "bors",
    "date": 1428970070,
    "message": "Auto merge of #24251 - alexcrichton:unsafe-from-raw-fd, r=aturon\n\nAs pointed out in [RFC issue 1043][rfc] it is quite useful to have the standard\r\nI/O types to provide the contract that they are the sole owner of the underlying\r\nobject they represent. This guarantee enables writing safe interfaces like the\r\n`MemoryMap` API sketched out in that issue.\r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/issues/1043\r\n\r\nAs constructing objects from these raw handles may end up violating these\r\nownership gurantees, the functions for construction are now marked unsafe.\r\n\r\n[breaking-change]\r\nCloses rust-lang/rfcs#1043"
  },
  {
    "hash": "2705051e2067e8f467b4cb9bc75e801a5cd4f0e7",
    "author": "Alex Crichton",
    "date": 1428621153,
    "message": "std: Make FromRawFd::from_raw_fd an unsafe method\n\nAs pointed out in [RFC issue 1043][rfc] it is quite useful to have the standard\nI/O types to provide the contract that they are the sole owner of the underlying\nobject they represent. This guarantee enables writing safe interfaces like the\n`MemoryMap` API sketched out in that issue.\n\n[rfc]: https://github.com/rust-lang/rfcs/issues/1043\n\nAs constructing objects from these raw handles may end up violating these\nownership gurantees, the functions for construction are now marked unsafe.\n\n[breaking-change]\nCloses rust-lang/rfcs#1043"
  },
  {
    "hash": "f55e66aaed42589dcda0221a4545dbaaec68e577",
    "author": "bors",
    "date": 1428946754,
    "message": "Auto merge of #24198 - alexcrichton:windows-readlink, r=aturon\n\nThe current implementation of using GetFinalPathNameByHandle actually reads all\r\nintermediate links instead of just looking at the current link. This commit\r\nalters the behavior of the function to use a different API which correctly reads\r\nonly one level of the soft link.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "f3f99fb44eea1d7037f94259aef6cbc39837ebee",
    "author": "Alex Crichton",
    "date": 1428514419,
    "message": "std: Fix fs::read_link behavior on Windows\n\nThe current implementation of using GetFinalPathNameByHandle actually reads all\nintermediate links instead of just looking at the current link. This commit\nalters the behavior of the function to use a different API which correctly reads\nonly one level of the soft link.\n\n[breaking-change]"
  },
  {
    "hash": "524547551cd6c9b33a9677e1a58e9a9d1e19c0fc",
    "author": "bors",
    "date": 1428912503,
    "message": "Auto merge of #24339 - lfairy:remove-regex-data, r=alexcrichton\n\nThe regex crate keeps its own tables now (rust-lang/regex#41) so we\r\ndon't need them here.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "5308ac939a330b74540bea5920b0086a2d954648",
    "author": "Chris Wong",
    "date": 1428877810,
    "message": "Remove regex module from libunicode\n\nThe regex crate keeps its own tables now (rust-lang/regex#41) so we\ndon't need them here.\n\n[breaking-change]"
  },
  {
    "hash": "5afa2704a6fdee62b267a5df9ca0934350dfc3d1",
    "author": "bors",
    "date": 1428802013,
    "message": "Auto merge of #23011 - nagisa:the-war-of-symbol-and-symbol, r=pnkfelix\n\nWe provide tools to tell what exact symbols to emit for any fn or static, but\r\ndonâ€™t quite check if that wonâ€™t cause any issues later on. Some of the issues\r\ninclude LLVM mangling our names again and our names pointing to wrong locations,\r\nus generating dumb foreign call wrappers, linker errors, extern functions\r\nresolving to different symbols altogether (`extern {fn fail();} fail();` in some\r\ncases calling `fail1()`), etc.\r\n\r\nBefore the commit we had a function called `note_unique_llvm_symbol`, so it is\r\nclear somebody was aware of the issue at some point, but the function was barely\r\nused, mostly in irrelevant locations.\r\n\r\nAlong with working on it I took liberty to start refactoring trans/base into\r\na few smaller modules. The refactoring is incomplete and I hope I will find some\r\nmotivation to carry on with it.\r\n\r\nThis is possibly a [breaking-change] because it makes dumbly written code\r\nproperly invalid.\r\n\r\nThis fixes all those issues about incorrect use of #[no_mangle] being not reported/misreported/ICEd by the compiler.\r\n\r\nNB. This PR does not attempt to tackle the parallel codegen issue that was mentioned in https://github.com/rust-lang/rust/pull/22811, but I believe it should be very straightforward in a follow up PR by modifying `trans::declare::get_defined_value` to look at all the contexts.\r\n\r\ncc @alexcrichton @huonw @nrc because you commented on the original RFC issue.\r\n\r\nEDIT: wow, this became much bigger than I initially intended."
  },
  {
    "hash": "f1dabed82bfed643fbbfc93203473e384c58d20a",
    "author": "Simonas Kazlauskas",
    "date": 1428065287,
    "message": "Introduce trans::declare\n\nWe provide tools to tell what exact symbols to emit for any fn or static, but\ndonâ€™t quite check if that wonâ€™t cause any issues later on. Some of the issues\ninclude LLVM mangling our names again and our names pointing to wrong locations,\nus generating dumb foreign call wrappers, linker errors, extern functions\nresolving to different symbols altogether (extern {fn fail();} fail(); in some\ncases calling fail1()), etc.\n\nBefore the commit we had a function called note_unique_llvm_symbol, so it is\nclear somebody was aware of the issue at some point, but the function was barely\nused, mostly in irrelevant locations.\n\nAlong with working on it I took liberty to start refactoring trans/base into\na few smaller modules. The refactoring is incomplete and I hope I will find some\nmotivation to carry on with it.\n\nThis is possibly a [breaking-change] because it makes dumbly written code\nproperly invalid."
  },
  {
    "hash": "93f7fe32d30b67baa6abf09c073c5862a978dc57",
    "author": "bors",
    "date": 1428709764,
    "message": "Auto merge of #24270 - pnkfelix:use-disr-val-for-derive-ord, r=brson\n\nUse `discriminant_value` intrinsic for `derive(PartialOrd)`\r\n\r\n[breaking-change]\r\n\r\nThis is a [breaking-change] because it can change the result of comparison operators when enum discriminants have been explicitly assigned.  Notably in a case like:\r\n```rust\r\n#[derive(PartialOrd)]\r\nenum E { A = 2, B = 1}\r\n```\r\n\r\nUnder the old deriving, `A < B` held, because `A` came before `B` in the order of declaration.  But now we use the ordering according to the provided values, and thus `A > B`.  (However, this change is very unlikely to break much, if any, code, since the orderings themselves should all remain well-defined, total, etc.)\r\n\r\nFix #15523"
  },
  {
    "hash": "d6c72306c8fc2ec0fd9d6e499c32f2bf52f0b8ba",
    "author": "Alex Crichton",
    "date": 1428624422,
    "message": "std: Set CLOEXEC for all fds opened on unix\n\nThis commit starts to set the CLOEXEC flag for all files and sockets opened by\nthe standard library by default on all unix platforms. There are a few points of\nnote in this commit:\n\n* The implementation is not 100% satisfactory in the face of threads. File\n  descriptors only have the `F_CLOEXEC` flag set *after* they are opened,\n  allowing for a fork/exec to happen in the middle and leak the descriptor.\n  Some platforms do support atomically opening a descriptor while setting the\n  `CLOEXEC` flag, and it is left as a future extension to bind these apis as it\n  is unclear how to do so nicely at this time.\n\n* The implementation does not offer a method of opting into the old behavior of\n  not setting `CLOEXEC`. This will possibly be added in the future through\n  extensions on `OpenOptions`, for example.\n\n* This change does not yet audit any Windows APIs to see if the handles are\n  inherited by default by accident.\n\nThis is a breaking change for users who call `fork` or `exec` outside of the\nstandard library itself and expect file descriptors to be inherted. All file\ndescriptors created by the standard library will no longer be inherited.\n\n[breaking-change]"
  },
  {
    "hash": "e3f324cd9d7b27eda6133c407a4751a8b0217631",
    "author": "Aaron Turon",
    "date": 1428594849,
    "message": "Improve bounds in Iterator API\n\nThis commit changes `Iterator`'s API by:\n\n* Generalizing bounds from `Iterator` to `IntoIterator` whenever\n  possible, matching the semantics and ergonomics of `for` loops.\n\n* Tightens up a few method-level bounds so that you get an error\n  earlier. For example, `rev` did not require `DoubleEndedIterator` even\n  though the result is only an `Iterator` when the original iterator was\n  double-ended.\n\nCloses #23587\n\nThe bound-tightening is technically a:\n\n[breaking-change]\n\nbut no code should break in practice."
  },
  {
    "hash": "5daee19eca622030c598042d9615df17d4ad035f",
    "author": "Manish Goregaokar",
    "date": 1428605683,
    "message": "Rollup merge of #24212 - alexcrichton:destabilize-begin-unwind, r=huonw\n\n Now that we have a `#[allow_internal_unstable]` attribute for macros there's no\nneed for these two `begin_unwind` functions to be stable. Right now the `panic!`\ninterface is the only one we wish to stabilize, so remove the stability markers\nfrom these functions.\n\nWhile this is a breaking change, it is highly unlikely to break any actual code.\nIt is recommended to use the `panic!` macro instead if it breaks explicit calls\ninto `std::rt`.\n\n[breaking-change]\ncc #24208"
  }
]
