[
  {
    "hash": "092ba6a8563b5c95f5aa53a705eaba6cc94e2da7",
    "author": "Aaron Turon",
    "date": 1421855145,
    "message": "Deprecate slicing methods in favor of notation\n\nThis commit deprecates `slice`, `slice_from`, `slice_to` and their\nmutable variants in favor of slice notation.\n\nThe `as_slice` methods are left intact, for now.\n\n[breaking-change]"
  },
  {
    "hash": "fba0bf63a90379e8825012a817167774e14a627f",
    "author": "Aaron Turon",
    "date": 1421855145,
    "message": "Stabilize Index traits and most range notation\n\nThis commit marks as `#[stable]`:\n\n* The `Index` and `IndexMut` traits. These are stabilized as taking the\n  index itself *by reference*; after extensive discussion it was\n  determined that this is a better match with our choices\n  elsewhere (e.g. making comparison operators auto-reference), and that\n  the use cases for by-value indices are better handled through\n  `IndexSet`.\n\n* The `Range`, `RangeFrom` and `RangeTo` structs, introduced for range\n  notation.\n\n* Various impls of `Index` and `IndexMut`.\n\nThe `FullRange` struct is left unstable as we may wish to rename it to\n`RangeFull` in the future.\n\nThis commit also *removes* the `Step` trait in favor of direct\nimplementation of iterator traits on ranges for integers. The `Step`\ntrait was not a terribly useful factoring internally, and it is likely\nthat external integer types are best off implementing range iterators\ndirectly. It was removed to simplify the API surface. We can always\nreintroduce `Step` later if it turns out to be useful.\n\nDue to this removal, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "3cb9fa26ef9905c00a29ea577fb55a12a91c8e7b",
    "author": "Alex Crichton",
    "date": 1421822173,
    "message": "std: Rename Show/String to Debug/Display\n\nThis commit is an implementation of [RFC 565][rfc] which is a stabilization of\nthe `std::fmt` module and the implementations of various formatting traits.\nSpecifically, the following changes were performed:\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0565-show-string-guidelines.md\n\n* The `Show` trait is now deprecated, it was renamed to `Debug`\n* The `String` trait is now deprecated, it was renamed to `Display`\n* Many `Debug` and `Display` implementations were audited in accordance with the\n  RFC and audited implementations now have the `#[stable]` attribute\n  * Integers and floats no longer print a suffix\n  * Smart pointers no longer print details that they are a smart pointer\n  * Paths with `Debug` are now quoted and escape characters\n* The `unwrap` methods on `Result` now require `Display` instead of `Debug`\n* The `Error` trait no longer has a `detail` method and now requires that\n  `Display` must be implemented. With the loss of `String`, this has moved into\n  libcore.\n* `impl<E: Error> FromError<E> for Box<Error>` now exists\n* `derive(Show)` has been renamed to `derive(Debug)`. This is not currently\n  warned about due to warnings being emitted on stage1+\n\nWhile backwards compatibility is attempted to be maintained with a blanket\nimplementation of `Display` for the old `String` trait (and the same for\n`Show`/`Debug`) this is still a breaking change due to primitives no longer\nimplementing `String` as well as modifications such as `unwrap` and the `Error`\ntrait. Most code is fairly straightforward to update with a rename or tweaks of\nmethod calls.\n\n[breaking-change]\nCloses #21436"
  },
  {
    "hash": "8d05f6c74c34c1d72fd91be3057fe7d4581aca3a",
    "author": "Barosl LEE",
    "date": 1421774211,
    "message": "Rollup merge of #21388 - aochagavia:collections, r=Gankro\n\n**Breaking change**: `VecMap::into_iter` now consumes the `VecMap`. To fix it you should pass the VecMap by value instead of by reference.\r\n\r\n[breaking-change]\r\n\r\nr? @Gankro"
  },
  {
    "hash": "2366dee8e9cb41d963900c8d5128f810a87fc6bb",
    "author": "Adolfo Ochagav√≠a",
    "date": 1421660881,
    "message": "Make VecMap::into_iter consume the VecMap\n\nThis is a breaking change. To fix it you should pass the VecMap by value\ninstead of by reference.\n\n[breaking-change]"
  },
  {
    "hash": "e63443d536a0e6157dce0cfb39dfcd2d614fb357",
    "author": "Barosl LEE",
    "date": 1421774207,
    "message": "Rollup merge of #21312 - michaelsproul:remove-error-send-bound, r=aturon\n\nAs discussed with @aturon, this PR removes the `Send` bound from `std::error::Error`, allowing us to implement `Error` for error types containing non-`Send` types. Current examples include `PoisonError` and `TryLockError` from `std::sync` which contain a Guard that we don't want sent between tasks.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "cda3490f8fb099a1ddd1f253a75c29110042dc01",
    "author": "bors",
    "date": 1421682281,
    "message": "Auto merge of #21269 - alexcrichton:issue-6936, r=pnkfelix\n\nThis commit modifies resolve to prevent conflicts with typedef names in the same\r\nmethod that conflits are prevented with enum names. This is a breaking change\r\ndue to the differing semantics in resolve, and any errors generated on behalf of\r\nthis change require that a conflicting typedef, module, or structure to be\r\nrenamed so they do not conflict.\r\n\r\n[breaking-change]\r\nCloses #6936"
  },
  {
    "hash": "2549cbec9dfe02cdc93a3cf3bfe9638e5a4c2948",
    "author": "Alex Crichton",
    "date": 1421634355,
    "message": "rustc_resolve: Do not allow mods to shadow types\n\nThis commit modifies resolve to prevent conflicts with typedef names in the same\nmethod that conflits are prevented with enum names. This is a breaking change\ndue to the differing semantics in resolve, and any errors generated on behalf of\nthis change require that a conflicting typedef, module, or structure to be\nrenamed so they do not conflict.\n\n[breaking-change]\nCloses #6936"
  },
  {
    "hash": "7b87900d72cf53037119e3bac1506a9786ca508a",
    "author": "bors",
    "date": 1421662763,
    "message": "Auto merge of #20874 - klutzy:windows-dynamic-lib, r=alexcrichton\n\nThis is a [breaking-change] since `std::dynamic_lib::dl` is now\r\nprivate.\r\n\r\nWhen `LoadLibraryW()` fails, original code called `errno()` to get error\r\ncode.  However, there was local allocation of `Vec` before\r\n`LoadLibraryW()`, and it drops before `errno()`, and the drop\r\n(deallocation) changed `errno`! Therefore `dynamic_lib::open()` thought\r\nit always succeeded.\r\nThis commit fixes the issue.\r\n\r\nThis commit also sets Windows error mode during `LoadLibrary()` to\r\nprevent \"dll load failed\" dialog."
  },
  {
    "hash": "d053ccb45fafc12a52629f209122c1ce9bbfabed",
    "author": "klutzy",
    "date": 1421593965,
    "message": "std::dynamic_lib: Fix Windows error handling\n\nThis is a [breaking-change] since `std::dynamic_lib::dl` is now\nprivate.\n\nWhen `LoadLibraryW()` fails, original code called `errno()` to get error\ncode.  However, there was local allocation of `Vec` before\n`LoadLibraryW()`, and it drops before `errno()`, and the drop\n(deallocation) changed `errno`! Therefore `dynamic_lib::open()` thought\nit always succeeded.\nThis commit fixes the issue.\n\nThis commit also sets Windows error mode during `LoadLibrary()` to\nprevent \"dll load failed\" dialog."
  },
  {
    "hash": "34fa70fba5425cbbb96bce783e9fd5c23dd9b471",
    "author": "Alex Crichton",
    "date": 1421509867,
    "message": "std: Move the bitflags! macro to a gated crate\n\nIn accordance with [collections reform part 2][rfc] this macro has been moved to\nan external [bitflags crate][crate] which is [available though\ncrates.io][cratesio]. Inside the standard distribution the macro has been moved\nto a crate called `rustc_bitflags` for current users to continue using.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0509-collections-reform-part-2.md\n[crate]: https://github.com/rust-lang/bitflags\n[cratesio]: http://crates.io/crates/bitflags\n\nThe major user of `bitflags!` in terms of a public-facing possibly-stable API\ntoday is the `FilePermissions` structure inside of `std::io`. This user,\nhowever, will likely no longer use `bitflags!` after I/O reform has landed. To\nprevent breaking APIs today, this structure remains as-is.\n\nCurrent users of the `bitflags!` macro should add this to their `Cargo.toml`:\n\n    bitflags = \"0.1\"\n\nand this to their crate root:\n\n    #[macro_use] extern crate bitflags;\n\nDue to the removal of a public macro, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "873ae555e9a42fd12b0a92134112ec000d749ab2",
    "author": "Simonas Kazlauskas",
    "date": 1421509789,
    "message": "Revert stability for Bitv and BitvSet\n\nThe collections were promoted to stable by mistake and do not match RFC 509.\nThis reverts the stability back to unstable.\n\n[breaking-change] since previously stable API became unstable.\n\nFixes #21193"
  },
  {
    "hash": "cbeb77ec7a42b988703fa0b0c857f26d464fdc2f",
    "author": "Alex Crichton",
    "date": 1421426896,
    "message": "rustc: Fix a leak in dependency= paths\n\nWith the addition of separate search paths to the compiler, it was intended that\napplications such as Cargo could require a `--extern` flag per `extern crate`\ndirective in the source. The system can currently be subverted, however, due to\nthe `existing_match()` logic in the crate loader.\n\nWhen loading crates we first attempt to match an `extern crate` directive\nagainst all previously loaded crates to avoid reading metadata twice. This \"hit\nthe cache if possible\" step was erroneously leaking crates across the search\npath boundaries, however. For example:\n\n    extern crate b;\n    extern crate a;\n\nIf `b` depends on `a`, then it will load crate `a` when the `extern crate b`\ndirective is being processed. When the compiler reaches `extern crate a` it will\nuse the previously loaded version no matter what. If the compiler was not\ninvoked with `-L crate=path/to/a`, it will still succeed.\n\nThis behavior is allowing `extern crate` declarations in Cargo without a\ncorresponding declaration in the manifest of a dependency, which is considered\na bug.\n\nThis commit fixes this problem by keeping track of the origin search path for a\ncrate. Crates loaded from the dependency search path are not candidates for\ncrates which are loaded from the crate search path.\n\nAs a result of this fix, this is a likely a breaking change for a number of\nCargo packages. If the compiler starts informing that a crate can no longer be\nfound, it likely means that the dependency was forgotten in your Cargo.toml.\n\n[breaking-change]"
  },
  {
    "hash": "ee2bfae011e368e224d6d4f4c9fad13606ee99da",
    "author": "bors",
    "date": 1421413859,
    "message": "auto merge of #20972 : FlaPer87/rust/oibit-send-and-friends, r=nikomatsakis\n\nThis PR adds rules for negative implementations. It follows pretty much what the [RFC](https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md) says with 1 main difference:\r\n\r\nInstead of positive implementations override negative implementations, this have been implemented in a way that a negative implementation of `Trait` for `T` will overlap with a positive implementation, causing a coherence error.\r\n\r\n@nikomatsakis r?\r\n\r\ncc #13231\r\n\r\n[breaking-change]"
  },
  {
    "hash": "0419b4ab1225595b022d8ed4e425526b4d850995",
    "author": "Alex Crichton",
    "date": 1421359920,
    "message": "rollup merge of #21167: FlaPer87/coherence-impls\n\nFixes #21080\n\nr? @nikomatsakis\n\n[breaking-change]"
  },
  {
    "hash": "3d0d9bb6fbdf6ead9396f0874cf38f3ef7c9be5c",
    "author": "bors",
    "date": 1421103380,
    "message": "auto merge of #20896 : sfackler/rust/atomic-rename, r=alexcrichton\n\nChange any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize\r\n\r\nCloses #20893\r\n\r\n[breaking-change]"
  },
  {
    "hash": "8b6cda3ce681d4d95c3097d12ed754975b4a07f6",
    "author": "Steven Fackler",
    "date": 1421005664,
    "message": "Rename AtomicInt and AtomicUint\n\nChange any use of AtomicInt to AtomicIsize and AtomicUint to AtomicUsize\n\nCloses #20893\n\n[breaking-change]"
  },
  {
    "hash": "2e4cef4e78253beb4c08ed35416fad076d978344",
    "author": "bors",
    "date": 1420994748,
    "message": "auto merge of #20910 : sfackler/rust/show-impls, r=alexcrichton\n\nA derived implementation would not be appropriate for the Buffered types\r\nsince the buffer is both huge (64k by default) and full of uninitialized\r\nmemory. Instead of printing the whole thing, we display how full it is.\r\n\r\nI also altered `MultiWriter` to make it generic over Writers instead of\r\ntaking `Box<Writer>` trait objects. `Box<Writer>` implements `Writer` so\r\nexisting use cases should continue to work, and this enables a more\r\nuseful Show implementation in applicable cases.\r\n\r\nThe change to `MultiWriter` may break code that uses it, but any fixes\r\nshould be easy.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton"
  },
  {
    "hash": "b4fae2fba99e713a6d6a8a59caaf1cfba847b50e",
    "author": "Steven Fackler",
    "date": 1420939974,
    "message": "Implement Show for types in std::io::{buffered,util}\n\nA derived implementation would not be appropriate for the Buffered types\nsince the buffer is both huge (64k by default) and full of uninitialized\nmemory. Instead of printing the whole thing, we display how full it is.\n\nI also altered MultiWriter to make it generic over Writers instead of\ntaking Box<Writer> trait objects. Box<Writer> implements Writer so\nexisting use cases should continue to work, and this enables a more\nuseful Show implementation in applicable cases.\n\nThe change to MultiWriter may break code that uses it, but any fixes\nshould be easy.\n\n[breaking-change]"
  },
  {
    "hash": "daee409b60cdb17040122343e0a184049c62180b",
    "author": "Alex Crichton",
    "date": 1420737726,
    "message": "rollup merge of #20740: FlaPer87/remove-opt-out-copy\n\n[breaking-change] code using this feature will break."
  },
  {
    "hash": "4a31aaddb364f5ab8280242a1016bdd3d10dcaed",
    "author": "Felix S. Klock II",
    "date": 1420674103,
    "message": "Added `box_syntax` feature gate; added to std and rustc crates for bootstrap.\n\nTo avoid using the feauture, change uses of `box <expr>` to\n`Box::new(<expr>)` alternative, as noted by the feature gate message.\n\n(Note that box patterns have no analogous trivial replacement, at\nleast not in general; you need to revise the code to do a partial\nmatch, deref, and then the rest of the match.)\n\n[breaking-change]"
  },
  {
    "hash": "63a9bd5e0adc03652e10506055564077aa00eeaa",
    "author": "Nick Cameron",
    "date": 1420669500,
    "message": "Fix precedence for ranges.\n\nTechnically this is a\n\n[breaking-change]\n\nbut it probably shouldn't affect your code.\n\nCloses #20256"
  },
  {
    "hash": "209c701bf9e95542aec69455bc12c7ca295109c4",
    "author": "Alex Crichton",
    "date": 1420664176,
    "message": "std: Stablize the macros module\n\nThis commit performs a pass over the `std::macros` module, applying stability\nattributes where necessary. In particular, this audits macros for patterns such\nas:\n\n* Standard use of forward-to-format-args via `$($arg:tt)*` (or `+`)\n* Prevent macro-defined identifiers from leaking into expression arguments as\n  hygiene is not perfectly implemented.\n* Wherever possible, `$crate` is used now.\n\nSpecifically, the following actions were taken:\n\n* The `std::macros` module itself is no longer public.\n* The `panic!` macro is stable\n* The `assert!` macro is stable\n* The `assert_eq!` macro is stable\n* The `debug_assert!` macro is stable\n* The `debug_assert_eq!` macro is stable\n* The `unreachable!` macro is stable after removing the extra forms to bring the\n  definition in line with the `unimplemented!` macro.\n* The `try!` macro is stable\n* The `vec!` macro is stable\n\n[breaking-change]"
  },
  {
    "hash": "92cd8ea96ad2a1da51863b7f089baec41ed10ce9",
    "author": "Huon Wilson",
    "date": 1420680448,
    "message": "Prohibit type parameter shadowing with a clunky hammer.\n\nThis is a [breaking-change].\n\nChange\n\n    impl<T> Foo<T> {\n        fn bar<T>(...\n\nto (for example)\n\n    impl<T> Foo<T> {\n        fn bar<U>(...\n\nPer RFC 459.\n\nCloses #19390."
  },
  {
    "hash": "7deb9abd1b45f3e56ca6b13432866ae89886f21f",
    "author": "Aaron Turon",
    "date": 1420659611,
    "message": "Add isize, usize modules, deprecate int, uint modules\n\nThis PR introduces `isize` and `usize` modules to `core` and `std`, and\ndeprecates the existing `int` and `uint` modules. The rustdoc primitive\ntype links now point to these new modules.\n\nDue to deprecation this is a:\n\n[breaking-change]"
  },
  {
    "hash": "6301c7878ebcaa45e77315db2a9afd8b5d1425c8",
    "author": "Alex Crichton",
    "date": 1420679843,
    "message": "rollup merge of #20680: nick29581/target-word\n\nCloses #20421\n\n[breaking-change]\n\nr? @brson"
  },
  {
    "hash": "dd3e89aaf25c667fa8207f8800c4b60d70d76c1b",
    "author": "Nick Cameron",
    "date": 1420661275,
    "message": "Rename `target_word_size` to `target_pointer_width`\n\nCloses #20421\n\n[breaking-change]"
  },
  {
    "hash": "8bf3ee7c5c44fa5aa0a1003e8fe61a0af1527927",
    "author": "Alex Crichton",
    "date": 1420679839,
    "message": "rollup merge of #20654: alexcrichton/stabilize-hash\n\nThis commit aims to prepare the `std::hash` module for alpha by formalizing its\ncurrent interface whileholding off on adding `#[stable]` to the new APIs.  The\ncurrent usage with the `HashMap` and `HashSet` types is also reconciled by\nseparating out composable parts of the design. The primary goal of this slight\nredesign is to separate the concepts of a hasher's state from a hashing\nalgorithm itself.\n\nThe primary change of this commit is to separate the `Hasher` trait into a\n`Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was\nactually just a factory for various states, but hashing had very little control\nover how these states were used. Additionally the old `Hasher` trait was\nactually fairly unrelated to hashing.\n\nThis commit redesigns the existing `Hasher` trait to match what the notion of a\n`Hasher` normally implies with the following definition:\n\n    trait Hasher {\n        type Output;\n        fn reset(&mut self);\n        fn finish(&self) -> Output;\n    }\n\nThis `Hasher` trait emphasizes that hashing algorithms may produce outputs other\nthan a `u64`, so the output type is made generic. Other than that, however, very\nlittle is assumed about a particular hasher. It is left up to implementors to\nprovide specific methods or trait implementations to feed data into a hasher.\n\nThe corresponding `Hash` trait becomes:\n\n    trait Hash<H: Hasher> {\n        fn hash(&self, &mut H);\n    }\n\nThe old default of `SipState` was removed from this trait as it's not something\nthat we're willing to stabilize until the end of time, but the type parameter is\nalways required to implement `Hasher`. Note that the type parameter `H` remains\non the trait to enable multidispatch for specialization of hashing for\nparticular hashers.\n\nNote that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is\nsimply used as part `derive` and the implementations for all primitive types.\n\nWith these definitions, the old `Hasher` trait is realized as a new `HashState`\ntrait in the `collections::hash_state` module as an unstable addition for\nnow. The current definition looks like:\n\n    trait HashState {\n        type Hasher: Hasher;\n        fn hasher(&self) -> Hasher;\n    }\n\nThe purpose of this trait is to emphasize that the one piece of functionality\nfor implementors is that new instances of `Hasher` can be created.  This\nconceptually represents the two keys from which more instances of a\n`SipHasher` can be created, and a `HashState` is what's stored in a\n`HashMap`, not a `Hasher`.\n\nImplementors of custom hash algorithms should implement the `Hasher` trait, and\nonly hash algorithms intended for use in hash maps need to implement or worry\nabout the `HashState` trait.\n\nThe entire module and `HashState` infrastructure remains `#[unstable]` due to it\nbeing recently redesigned, but some other stability decision made for the\n`std::hash` module are:\n\n* The `Writer` trait remains `#[experimental]` as it's intended to be replaced\n  with an `io::Writer` (more details soon).\n* The top-level `hash` function is `#[unstable]` as it is intended to be generic\n  over the hashing algorithm instead of hardwired to `SipHasher`\n* The inner `sip` module is now private as its one export, `SipHasher` is\n  reexported in the `hash` module.\n\nAnd finally, a few changes were made to the default parameters on `HashMap`.\n\n* The `RandomSipHasher` default type parameter was renamed to `RandomState`.\n  This renaming emphasizes that it is not a hasher, but rather just state to\n  generate hashers. It also moves away from the name \"sip\" as it may not always\n  be implemented as `SipHasher`. This type lives in the\n  `std::collections::hash_map` module as `#[unstable]`\n\n* The associated `Hasher` type of `RandomState` is creatively called...\n  `Hasher`! This concrete structure lives next to `RandomState` as an\n  implemenation of the \"default hashing algorithm\" used for a `HashMap`. Under\n  the hood this is currently implemented as `SipHasher`, but it draws an\n  explicit interface for now and allows us to modify the implementation over\n  time if necessary.\n\nThere are many breaking changes outlined above, and as a result this commit is\na:\n\n[breaking-change]"
  },
  {
    "hash": "511f0b8a3de5a166fc96aba5170782c9abf92101",
    "author": "Alex Crichton",
    "date": 1420661888,
    "message": "std: Stabilize the std::hash module\n\nThis commit aims to prepare the `std::hash` module for alpha by formalizing its\ncurrent interface whileholding off on adding `#[stable]` to the new APIs.  The\ncurrent usage with the `HashMap` and `HashSet` types is also reconciled by\nseparating out composable parts of the design. The primary goal of this slight\nredesign is to separate the concepts of a hasher's state from a hashing\nalgorithm itself.\n\nThe primary change of this commit is to separate the `Hasher` trait into a\n`Hasher` and a `HashState` trait. Conceptually the old `Hasher` trait was\nactually just a factory for various states, but hashing had very little control\nover how these states were used. Additionally the old `Hasher` trait was\nactually fairly unrelated to hashing.\n\nThis commit redesigns the existing `Hasher` trait to match what the notion of a\n`Hasher` normally implies with the following definition:\n\n    trait Hasher {\n        type Output;\n        fn reset(&mut self);\n        fn finish(&self) -> Output;\n    }\n\nThis `Hasher` trait emphasizes that hashing algorithms may produce outputs other\nthan a `u64`, so the output type is made generic. Other than that, however, very\nlittle is assumed about a particular hasher. It is left up to implementors to\nprovide specific methods or trait implementations to feed data into a hasher.\n\nThe corresponding `Hash` trait becomes:\n\n    trait Hash<H: Hasher> {\n        fn hash(&self, &mut H);\n    }\n\nThe old default of `SipState` was removed from this trait as it's not something\nthat we're willing to stabilize until the end of time, but the type parameter is\nalways required to implement `Hasher`. Note that the type parameter `H` remains\non the trait to enable multidispatch for specialization of hashing for\nparticular hashers.\n\nNote that `Writer` is not mentioned in either of `Hash` or `Hasher`, it is\nsimply used as part `derive` and the implementations for all primitive types.\n\nWith these definitions, the old `Hasher` trait is realized as a new `HashState`\ntrait in the `collections::hash_state` module as an unstable addition for\nnow. The current definition looks like:\n\n    trait HashState {\n        type Hasher: Hasher;\n        fn hasher(&self) -> Hasher;\n    }\n\nThe purpose of this trait is to emphasize that the one piece of functionality\nfor implementors is that new instances of `Hasher` can be created.  This\nconceptually represents the two keys from which more instances of a\n`SipHasher` can be created, and a `HashState` is what's stored in a\n`HashMap`, not a `Hasher`.\n\nImplementors of custom hash algorithms should implement the `Hasher` trait, and\nonly hash algorithms intended for use in hash maps need to implement or worry\nabout the `HashState` trait.\n\nThe entire module and `HashState` infrastructure remains `#[unstable]` due to it\nbeing recently redesigned, but some other stability decision made for the\n`std::hash` module are:\n\n* The `Writer` trait remains `#[experimental]` as it's intended to be replaced\n  with an `io::Writer` (more details soon).\n* The top-level `hash` function is `#[unstable]` as it is intended to be generic\n  over the hashing algorithm instead of hardwired to `SipHasher`\n* The inner `sip` module is now private as its one export, `SipHasher` is\n  reexported in the `hash` module.\n\nAnd finally, a few changes were made to the default parameters on `HashMap`.\n\n* The `RandomSipHasher` default type parameter was renamed to `RandomState`.\n  This renaming emphasizes that it is not a hasher, but rather just state to\n  generate hashers. It also moves away from the name \"sip\" as it may not always\n  be implemented as `SipHasher`. This type lives in the\n  `std::collections::hash_map` module as `#[unstable]`\n\n* The associated `Hasher` type of `RandomState` is creatively called...\n  `Hasher`! This concrete structure lives next to `RandomState` as an\n  implemenation of the \"default hashing algorithm\" used for a `HashMap`. Under\n  the hood this is currently implemented as `SipHasher`, but it draws an\n  explicit interface for now and allows us to modify the implementation over\n  time if necessary.\n\nThere are many breaking changes outlined above, and as a result this commit is\na:\n\n[breaking-change]"
  },
  {
    "hash": "6680c9c5c797101fc5e0608cb2c3657517333148",
    "author": "Corey Richardson",
    "date": 1420563792,
    "message": "syntax: implement 'macro input future proofing'\n\nSee RFC 550 (https://github.com/rust-lang/rfcs/pull/550) for the motivation\nand details.\n\nIf this breaks your code, add one of the listed tokens after the relevant\nnon-terminal in your matcher.\n\n[breaking-change]"
  },
  {
    "hash": "36f5d122b80682de473aeda2e20f14b6ceb86d74",
    "author": "Alex Crichton",
    "date": 1420587518,
    "message": "rollup merge of #20615: aturon/stab-2-thread\n\nThis commit takes a first pass at stabilizing `std::thread`:\n\n* It removes the `detach` method in favor of two constructors -- `spawn`\n  for detached threads, `scoped` for \"scoped\" (i.e., must-join)\n  threads. This addresses some of the surprise/frustrating debug\n  sessions with the previous API, in which `spawn` produced a guard that\n  on destruction joined the thread (unless `detach` was called).\n\n  The reason to have the division in part is that `Send` will soon not\n  imply `'static`, which means that `scoped` thread creation can take a\n  closure over *shared stack data* of the parent thread. On the other\n  hand, this means that the parent must not pop the relevant stack\n  frames while the child thread is running. The `JoinGuard` is used to\n  prevent this from happening by joining on drop (if you have not\n  already explicitly `join`ed.) The APIs around `scoped` are\n  future-proofed for the `Send` changes by taking an additional lifetime\n  parameter. With the current definition of `Send`, this is forced to be\n  `'static`, but when `Send` changes these APIs will gain their full\n  flexibility immediately.\n\n  Threads that are `spawn`ed, on the other hand, are detached from the\n  start and do not yield an RAII guard.\n\n  The hope is that, by making `scoped` an explicit opt-in with a very\n  suggestive name, it will be drastically less likely to be caught by a\n  surprising deadlock due to an implicit join at the end of a scope.\n\n* The module itself is marked stable.\n\n* Existing methods other than `spawn` and `scoped` are marked stable.\n\nThe migration path is:\n\n```rust\nThread::spawn(f).detached()\n```\n\nbecomes\n\n```rust\nThread::spawn(f)\n```\n\nwhile\n\n```rust\nlet res = Thread::spawn(f);\nres.join()\n```\n\nbecomes\n\n```rust\nlet res = Thread::scoped(f);\nres.join()\n```\n\n[breaking-change]"
  },
  {
    "hash": "f67b81e8d4dc198ad10ad50a7624e43cc1e25802",
    "author": "Aaron Turon",
    "date": 1420563888,
    "message": "Stabilize std::thread\n\nThis commit takes a first pass at stabilizing `std::thread`:\n\n* It removes the `detach` method in favor of two constructors -- `spawn`\n  for detached threads, `scoped` for \"scoped\" (i.e., must-join)\n  threads. This addresses some of the surprise/frustrating debug\n  sessions with the previous API, in which `spawn` produced a guard that\n  on destruction joined the thread (unless `detach` was called).\n\n  The reason to have the division in part is that `Send` will soon not\n  imply `'static`, which means that `scoped` thread creation can take a\n  closure over *shared stack data* of the parent thread. On the other\n  hand, this means that the parent must not pop the relevant stack\n  frames while the child thread is running. The `JoinGuard` is used to\n  prevent this from happening by joining on drop (if you have not\n  already explicitly `join`ed.) The APIs around `scoped` are\n  future-proofed for the `Send` changes by taking an additional lifetime\n  parameter. With the current definition of `Send`, this is forced to be\n  `'static`, but when `Send` changes these APIs will gain their full\n  flexibility immediately.\n\n  Threads that are `spawn`ed, on the other hand, are detached from the\n  start and do not yield an RAII guard.\n\n  The hope is that, by making `scoped` an explicit opt-in with a very\n  suggestive name, it will be drastically less likely to be caught by a\n  surprising deadlock due to an implicit join at the end of a scope.\n\n* The module itself is marked stable.\n\n* Existing methods other than `spawn` and `scoped` are marked stable.\n\nThe migration path is:\n\n```rust\nThread::spawn(f).detached()\n```\n\nbecomes\n\n```rust\nThread::spawn(f)\n```\n\nwhile\n\n```rust\nlet res = Thread::spawn(f);\nres.join()\n```\n\nbecomes\n\n```rust\nlet res = Thread::scoped(f);\nres.join()\n```\n\n[breaking-change]"
  },
  {
    "hash": "503709708c72401dbe091ed5c7e0494efabe0669",
    "author": "Nick Cameron",
    "date": 1420577128,
    "message": "Change `std::kinds` to `std::markers`; flatten `std::kinds::marker`\n\n[breaking-change]"
  },
  {
    "hash": "2375a79152b8a6554c3e97a3f127fedd75f7495f",
    "author": "Niko Matsakis",
    "date": 1420582668,
    "message": "Implement impl reachability rules. This is a [breaking-change]. Type\nparameters on impls must now also appear in the trait ref, self type,\nor some associated type declared on the impl. This ensures that they\nare constrianed in some way and that the semantics of the trait system\nare well-defined (always a good thing).\n\nThere are three major ways to fix this error:\n\n1. Convert the trait to use associated types; most often the type\n   parameters are not constrained because they are in fact outputs of\n   the impl.\n\n2. Move the type parameters to methods.\n\n3. Add an additional type parameter to the self type or trait so that\n   the unused parameter can appear there.\n\nIn some cases, it is not possible to fix the impl because the trait\ndefinition needs to be changed first (and that may be out of your\ncontrol). In that case, for the time being, you can opt out of these\nrules by using `#[old_impl_check]` on the impl and adding a\n`#![feature(old_impl_check)]` to your crate declaration."
  },
  {
    "hash": "44440e5c18a1dbcc9685866ffffe00c508929079",
    "author": "Sean McArthur",
    "date": 1420584582,
    "message": "core: split into fmt::Show and fmt::String\n\nfmt::Show is for debugging, and can and should be implemented for\nall public types. This trait is used with `{:?}` syntax. There still\nexists #[derive(Show)].\n\nfmt::String is for types that faithfully be represented as a String.\nBecause of this, there is no way to derive fmt::String, all\nimplementations must be purposeful. It is used by the default format\nsyntax, `{}`.\n\nThis will break most instances of `{}`, since that now requires the type\nto impl fmt::String. In most cases, replacing `{}` with `{:?}` is the\ncorrect fix. Types that were being printed specifically for users should\nreceive a fmt::String implementation to fix this.\n\nPart of #20013\n\n[breaking-change]"
  },
  {
    "hash": "ae4762761c995494726e8c9f41b05e99e6c7c81b",
    "author": "Huon Wilson",
    "date": 1420546887,
    "message": "Merge core::num::Float and std::num::FloatMath.\n\n`FloatMath` no longer exists and all functionality from both traits is\navailable under `Float`. Change from\n\n    use std::num::{Float, FloatMath};\n\nto\n\n    use std::num::Float;\n\n[breaking-change]"
  },
  {
    "hash": "cd4ed38404384bdb13500f1d2e782d32ece2b239",
    "author": "Huon Wilson",
    "date": 1420546861,
    "message": "Deprecate the constant-returning functions in Float.\n\nThese are replaced by the equivalent constants in `std::f32` and\n`std::f64` respectively.\n\n[breaking-change]"
  },
  {
    "hash": "48f50e1e98691d74427e23e82694f528b3fb4d56",
    "author": "Nick Cameron",
    "date": 1420507247,
    "message": "Obsolete `Sized? T`\n\n[breaking-change]\n\nUse `T: ?Sized`"
  },
  {
    "hash": "6e68fd09edc7ed37fd76f703247b5410cd338bfe",
    "author": "Niko Matsakis",
    "date": 1420496246,
    "message": "Implement new orphan rule that requires that impls of remote traits meet the following two criteria:\n\n- the self type includes some local type; and,\n- type parameters in the self type must be constrained by a local type.\n\nA type parameter is called *constrained* if it appears in some type-parameter of a local type.\n\nHere are some examples that are accepted. In all of these examples, I\nassume that `Foo` is a trait defined in another crate. If `Foo` were\ndefined in the local crate, then all the examples would be legal.\n\n- `impl Foo for LocalType`\n- `impl<T> Foo<T> for LocalType` -- T does not appear in Self, so it is OK\n- `impl<T> Foo<T> for LocalType<T>` -- T here is constrained by LocalType\n- `impl<T> Foo<T> for (LocalType<T>, T)` -- T here is constrained by LocalType\n\nHere are some illegal examples (again, these examples assume that\n`Foo` is not local to the current crate):\n\n- `impl Foo for int` -- the Self type is not local\n- `impl<T> Foo for T` -- T appears in Self unconstrained by a local type\n- `impl<T> Foo for (LocalType, T)` -- T appears in Self unconstrained by a local type\n\nThis is a [breaking-change]. For the time being, you can opt out of\nthe new rules by placing `#[old_orphan_check]` on the trait (and\nenabling the feature gate where the trait is defined). Longer term,\nyou should restructure your traits to avoid the problem. Usually this\nmeans changing the order of parameters so that the \"central\" type\nparameter is in the `Self` position.\n\nAs an example of that refactoring, consider the `BorrowFrom` trait:\n\n```rust\npub trait BorrowFrom<Sized? Owned> for Sized? {\n    fn borrow_from(owned: &Owned) -> &Self;\n}\n```\n\nAs defined, this trait is commonly implemented for custom pointer\ntypes, such as `Arc`. Those impls follow the pattern:\n\n```rust\nimpl<T> BorrowFrom<Arc<T>> for T {...}\n```\n\nUnfortunately, this impl is illegal because the self type `T` is not\nlocal to the current crate. Therefore, we are going to change the order of the parameters,\nso that `BorrowFrom` becomes `Borrow`:\n\n```rust\npub trait Borrow<Sized? Borrowed> for Sized? {\n    fn borrow_from(owned: &Self) -> &Borrowed;\n}\n```\n\nNow the `Arc` impl is written:\n\n```rust\nimpl<T> Borrow<T> for Arc<T> { ... }\n```\n\nThis impl is legal because the self type (`Arc<T>`) is local."
  },
  {
    "hash": "64ec47c9d2a75c8150d153450e7e7b7db60208dc",
    "author": "Aaron Turon",
    "date": 1420495265,
    "message": "Final alpha stabilization of core::iter\n\nThis commit wraps up the adjustments to the iterator for recent language\nchanges.\n\n* Moves `rposition` from `ExactSizeIterator` to `IteratorExt` using a\n  `where` clause, thereby removing the `ExactSizeIterator:\n  DoubleEndedIterator` constraint.\n\n* Merges `MutableDoubleEndedIterator` into `IteratorExt`, renaming\n  `reverse_` to `reverse_in_place`.\n\n* Merges `IteratorOrdExt`, `IteratorCloneExt` and `CloneIteratorExt`\n  into `IteratorExt` using `where` clauses.\n\nMarks as `#[stable]`:\n\n* the `iter` module itself\n* `FromIterator`, `Extend`\n* `Iterator`, `IteratorExt`\n* `map`\n* `filter`\n* `filter_map`\n* `skip_while`\n* `take_while`\n* `scan`\n* `flat_map`\n* `inspect`\n* `collect`\n* `fold`\n* `all`\n* `any`\n* `find`\n* `rposition`\n* `max`, `min`\n* Various adapter types related to the above methods\n\nBecause of the trait merging, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "bf6c007760169e9c382d3700fd1cdd20037e4343",
    "author": "Huon Wilson",
    "date": 1420434857,
    "message": "Change `&` pat to only work with &T, and `&mut` with &mut T.\n\nThis implements RFC 179 by making the pattern `&<pat>` require matching\nagainst a variable of type `&T`, and introducing the pattern `&mut\n<pat>` which only works with variables of type `&mut T`.\n\nThe pattern `&mut x` currently parses as `&(mut x)` i.e. a pattern match\nthrough a `&T` or a `&mut T` that binds the variable `x` to have type\n`T` and to be mutable. This should be rewritten as follows, for example,\n\n    for &mut x in slice.iter() {\n\nbecomes\n\n    for &x in slice.iter() {\n        let mut x = x;\n\nDue to this, this is a\n\n[breaking-change]\n\nCloses #20496."
  },
  {
    "hash": "25d5a3a19423fee01787de87a56d185dd4e0a4e7",
    "author": "Alex Crichton",
    "date": 1420511842,
    "message": "rollup merge of #20507: alexcrichton/issue-20444\n\nThis commit is an implementation of [RFC 494][rfc] which removes the entire\n`std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md\n\nThe interface of the new `CString` is outlined in the linked RFC, the primary\nchanges being:\n\n* The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods\n  are now gone. These two methods are replaced with a `CString::from_slice`\n  method.\n* The `CString` type is now just a wrapper around `Vec<u8>` with a static\n  guarantee that there is a trailing nul byte with no internal nul bytes. This\n  means that `CString` now implements `Deref<Target = [c_char]>`, which is where\n  it gains most of its methods from. A few helper methods are added to acquire a\n  slice of `u8` instead of `c_char`, as well as including a slice with the\n  trailing nul byte if necessary.\n* All usage of non-owned `CString` values is now done via two functions inside\n  of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These\n  functions are now the one method used to convert a `*const c_char` to a Rust\n  slice of `u8`.\n\nMany more details, including newly deprecated methods, can be found linked in\nthe RFC. This is a:\n\n[breaking-change]\nCloses #20444"
  },
  {
    "hash": "ec7a50d20dff416d9fec837a6492dfe244f5f3ab",
    "author": "Alex Crichton",
    "date": 1420473613,
    "message": "std: Redesign c_str and c_vec\n\nThis commit is an implementation of [RFC 494][rfc] which removes the entire\n`std::c_vec` module and redesigns the `std::c_str` module as `std::ffi`.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0494-c_str-and-c_vec-stability.md\n\nThe interface of the new `CString` is outlined in the linked RFC, the primary\nchanges being:\n\n* The `ToCStr` trait is gone, meaning the `with_c_str` and `to_c_str` methods\n  are now gone. These two methods are replaced with a `CString::from_slice`\n  method.\n* The `CString` type is now just a wrapper around `Vec<u8>` with a static\n  guarantee that there is a trailing nul byte with no internal nul bytes. This\n  means that `CString` now implements `Deref<Target = [c_char]>`, which is where\n  it gains most of its methods from. A few helper methods are added to acquire a\n  slice of `u8` instead of `c_char`, as well as including a slice with the\n  trailing nul byte if necessary.\n* All usage of non-owned `CString` values is now done via two functions inside\n  of `std::ffi`, called `c_str_to_bytes` and `c_str_to_bytes_with_nul`. These\n  functions are now the one method used to convert a `*const c_char` to a Rust\n  slice of `u8`.\n\nMany more details, including newly deprecated methods, can be found linked in\nthe RFC. This is a:\n\n[breaking-change]\nCloses #20444"
  },
  {
    "hash": "88b4c8e0d347921673e61bf1770ba0acd4c7d824",
    "author": "Alex Crichton",
    "date": 1420511794,
    "message": "rollup merge of #20465: nikomatsakis/assoc-types-regions-20303\n\nTreat associated types the same as type parameters when it comes to region bounding. Fixes #20303.\n\nStrictly speaking, this is a [breaking-change] (if you are using\nassociated types). You are no longer free to wantonly violate the type\nsystem rules by closing associated types into objects without any form\nof region bound. Instead you should add region bounds like `T::X :\n'a`, just as you would with a normal type parameter.\n\nr? @aturon"
  },
  {
    "hash": "c8868942e845254abfd3623a709847d65e015a2f",
    "author": "Niko Matsakis",
    "date": 1420470875,
    "message": "Treat associated types the same as type parameters when it comes to region bounding. Fixes #20303.\n\nStrictly speaking, this is a [breaking-change] (if you are using\nassociated types). You are no longer free to wantonly violate the type\nsystem rules by closing associated types into objects without any form\nof region bound. Instead you should add region bounds like `T::X :\n'a`, just as you would with a normal type parameter."
  },
  {
    "hash": "c7dd3c4d69aee1c4ad8cc220c194b176bba2ab62",
    "author": "bors",
    "date": 1420501860,
    "message": "auto merge of #20578 : japaric/rust/no-more-bc, r=nmatsakis\n\nThis PR removes boxed closures from the language, the closure type syntax (`let f: |int| -> bool = /* ... */`) has been obsoleted. Move all your uses of closures to the new unboxed closure system (i.e. `Fn*` traits).\r\n\r\n[breaking-change] patterns\r\n\r\n- `lef f = || {}`\r\n\r\nThis binding used to type check to a boxed closure. Now that boxed closures are gone, you need to annotate the \"kind\" of the unboxed closure, i.e. you need pick one of these: `|&:| {}`, `|&mut:| {}` or `|:| {}`.\r\n\r\nIn the (near) future we'll have closure \"kind\" inference, so the compiler will infer which `Fn*` trait to use based on how the closure is used. Once this inference machinery is in place, we'll be able to remove the kind annotation from most closures.\r\n\r\n- `type Alias<'a> = |int|:'a -> bool`\r\n\r\nUse a trait object: `type Alias<'a> = Box<FnMut(int) -> bool + 'a>`. Use the `Fn*` trait that makes sense for your use case.\r\n\r\n- `fn foo(&self, f: |uint| -> bool)`\r\n\r\nIn this case you can use either a trait object or an unboxed closure:\r\n\r\n``` rust\r\nfn foo(&self, f: F) where F: FnMut(uint) -> bool;\r\n// or\r\nfn foo(&self, f: Box<FnMut(uint) -> bool>);\r\n```\r\n\r\n- `struct Struct<'a> { f: |uint|:'a -> bool }`\r\n\r\nAgain, you can use either a trait object or an unboxed closure:\r\n\r\n``` rust\r\nstruct Struct<F> where F: FnMut(uint) -> bool { f: F }\r\n// or\r\nstruct Struct<'a> { f: Box<FnMut(uint) -> bool + 'a> }\r\n```\r\n\r\n- Using `|x, y| f(x, y)` for closure \"borrows\"\r\n\r\nThis comes up in recursive functions, consider the following (contrived) example:\r\n\r\n``` rust\r\nfn foo(x: uint, f: |uint| -> bool) -> bool {\r\n    //foo(x / 2, f) && f(x)  // can't use this because `f` gets moved away in the `foo` call\r\n    foo(x / 2, |x| f(x)) && f(x)  // instead \"borrow\" `f` in the `foo` call\r\n}\r\n```\r\n\r\nIf you attempt to do the same with unboxed closures you'll hit \"\"error: reached the recursion limit during monomorphization\" (see #19596):\r\n\r\n``` rust\r\nfn foo<F>(x: uint, mut f: F) -> bool where F: FnMut(uint) -> bool {\r\n    foo(x / 2, |x| f(x)) && f(x)\r\n    //~^ error: reached the recursion limit during monomorphization\r\n}\r\n```\r\n\r\nInstead you *should* be able to write this:\r\n\r\n``` rust\r\nfn foo<F>(x: uint, mut f: F) -> bool where F: FnMut(uint) -> bool {\r\n    foo(x / 2, &mut f) && f(x)\r\n    //~^ error: the trait `FnMut` is not implemented for the type `&mut F`\r\n}\r\n```\r\n\r\nBut as you see above `&mut F` doesn't implement the `FnMut` trait. `&mut F` *should* implement the `FnMut` and the above code *should* work, but due to a bug (see #18835) it doesn't (for now).\r\n\r\nYou can work around the issue by rewriting the function to take `&mut F` instead of `F`:\r\n\r\n``` rust\r\nfn foo<F>(x: uint, f: &mut F) -> bool where F: FnMut(uint) -> bool {\r\n    foo(x / 2, f) && (*f)(x)\r\n}\r\n```\r\n\r\nThis finally works! However writing `foo(0, &mut |x| x == 0)` is unergonomic. So you can use a private helper function to avoid this:\r\n\r\n``` rust\r\n// public API function\r\npub fn foo<F>(x: uint, mut f: F) -> bool where F: FnMut(uint) -> bool {\r\n    foo_(x, &mut f)\r\n}\r\n\r\n// private helper function\r\nfn foo_<F>(x: uint, f: &mut F) -> bool where F: FnMut(uint) -> bool {\r\n    foo_(x / 2, f) && (*f)(x)\r\n}\r\n```\r\n\r\nCloses #14798\r\n\r\n---\r\n\r\nThere is more cleanup to do: like renaming functions/types from `unboxed_closure` to just `closure`, removing more dead code, simplify functions which now have unused arguments, update the documentation, etc. But that can be done in another PR.\r\n\r\nr? @nikomatsakis @aturon (You probably want to focus on the deleted/modified tests.)\r\ncc @eddyb"
  },
  {
    "hash": "03268bbf35d3ff2350d987fe7b60375839abdf2e",
    "author": "bors",
    "date": 1420469463,
    "message": "auto merge of #20514 : alexcrichton/rust/serialize-associated-type, r=aturon\n\nThis commit moves the libserialize crate (and will force the hand of the\r\nrustc-serialize crate) to not require the `old_orphan_check` feature gate as\r\nwell as using associated types wherever possible. Concretely, the following\r\nchanges were made:\r\n\r\n* The error type of `Encoder` and `Decoder` is now an associated type, meaning\r\n  that these traits have no type parameters.\r\n\r\n* The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`\r\n  traits have moved to the corresponding method of the trait. This movement\r\n  alleviates the dependency on `old_orphan_check` but implies that\r\n  implementations can no longer be specialized for the type of encoder/decoder\r\n  being implemented.\r\n\r\nDue to the trait definitions changing, this is a:\r\n\r\n[breaking-change]"
  },
  {
    "hash": "0cb7a4062a3c69bb0c54f0c9136889a1006e4f62",
    "author": "Alex Crichton",
    "date": 1420441166,
    "message": "serialize: Use assoc types + less old_orphan_check\n\nThis commit moves the libserialize crate (and will force the hand of the\nrustc-serialize crate) to not require the `old_orphan_check` feature gate as\nwell as using associated types wherever possible. Concretely, the following\nchanges were made:\n\n* The error type of `Encoder` and `Decoder` is now an associated type, meaning\n  that these traits have no type parameters.\n\n* The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`\n  traits have moved to the corresponding method of the trait. This movement\n  alleviates the dependency on `old_orphan_check` but implies that\n  implementations can no longer be specialized for the type of encoder/decoder\n  being implemented.\n\nDue to the trait definitions changing, this is a:\n\n[breaking-change]"
  },
  {
    "hash": "0302d379776fca82d3eb693046239dc66998f691",
    "author": "Huon Wilson",
    "date": 1420421451,
    "message": "Merge `UnicodeChar` and `CharExt`.\n\nThis \"reexports\" all the functionality of `core::char::CharExt` as\nmethods on `unicode::u_char::UnicodeChar` (renamed to `CharExt`).\n\nImports may need to be updated (one now just imports\n`unicode::CharExt`, or `std::char::CharExt` rather than two traits from\neither), so this is a\n\n[breaking-change]"
  },
  {
    "hash": "19120209d8e532514203d16a2cff0ad3b44de3bb",
    "author": "Huon Wilson",
    "date": 1420421430,
    "message": "Rename `core::char::Char` to `CharExt` to match prelude guidelines.\n\nImports may need to be updated so this is a\n\n[breaking-change]"
  },
  {
    "hash": "f031285c3a76b86525695bbb5b46daa9e77df200",
    "author": "Corey Farwell",
    "date": 1420256156,
    "message": "Remove graphviz::LabelText::* public reexport\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "c6c786671d692d7b13c2e5c68a53001327b4b125",
    "author": "bors",
    "date": 1420332659,
    "message": "auto merge of #20490 : japaric/rust/assoc-types, r=aturon\n\ncloses #20486 \r\ncloses #20474 \r\ncloses #20441\r\n\r\n[breaking-change]\r\n\r\nThe `Index[Mut]` traits now have one less input parameter, as the return type of the indexing operation is an associated type. This breaks all existing implementations.\r\n\r\n---\r\n\r\nbinop traits (`Add`, `Sub`, etc) now have an associated type for their return type. Also, the RHS input parameter now defaults to `Self` (except for the `Shl` and `Shr` traits). For example, the `Add` trait now looks like this:\r\n\r\n``` rust\r\ntrait Add<Rhs=Self> {\r\n    type Output;\r\n\r\n    fn add(self, Rhs) -> Self::Output;\r\n}\r\n```\r\n\r\nThe `Neg` and `Not` traits now also have an associated type for their return type.\r\n\r\nThis breaks all existing implementations of these traits.\r\n\r\n---\r\nAffected traits:\r\n\r\n- `Iterator { type Item }`\r\n- `IteratorExt` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `DoubleEndedIterator` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `DoubleEndedIteratorExt` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `RandomAccessIterator` no input/output types\r\n- `ExactSizeIterator` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n\r\nThis breaks all the implementations of these traits."
  },
  {
    "hash": "9c3e6082e71618c088afd93f7a4a9a7708c9dcbd",
    "author": "bors",
    "date": 1420255521,
    "message": "auto merge of #20154 : P1start/rust/qualified-assoc-type-generics, r=nikomatsakis\n\nThis modifies `Parser::eat_lt` to always split up `<<`s, instead of doing so only when a lifetime name followed or the `force` parameter (now removed) was `true`. This is because `Foo<<TYPE` is now a valid start to a type, whereas previously only `Foo<<LIFETIME` was valid.\r\n\r\nThis is a [breaking-change]. Change code that looks like this:\r\n\r\n```rust\r\nlet x = foo as bar << 13;\r\n```\r\n\r\nto use parentheses, like this:\r\n\r\n```rust\r\nlet x = (foo as bar) << 13;\r\n```\r\n\r\nCloses #17362."
  },
  {
    "hash": "d9769ec3834b62318da892925dc24c8883bb1635",
    "author": "P1start",
    "date": 1419487127,
    "message": "Parse fully-qualified associated types in generics without whitespace\n\nThis breaks code that looks like this:\n\n    let x = foo as bar << 13;\n\nChange such code to look like this:\n\n    let x = (foo as bar) << 13;\n\nCloses #17362.\n\n[breaking-change]"
  },
  {
    "hash": "7506fe52696c5b3b628f173d74dc4a13b5ccc1f3",
    "author": "Nick Cameron",
    "date": 1420193122,
    "message": "Accept `derive` instead of `deriving`\n\n[breaking-change]\n\n`deriving is still accepted, but gives a deprecation warning"
  },
  {
    "hash": "74d11d26f4042ce04c56edfd6caafa003383147d",
    "author": "Nick Cameron",
    "date": 1420193122,
    "message": "Accept `self` in place of `mod` in use items\n\n[breaking-change]\n\n`mod` is still accepted, but gives a deprecated warning"
  },
  {
    "hash": "c61a0092bc236c4be4cb691fcd50ff50e91ab0d6",
    "author": "Niko Matsakis",
    "date": 1420189569,
    "message": "Fix orphan checking (cc #19470). (This is not a complete fix of #19470 because of the backwards compatibility feature gate.)\n\nThis is a [breaking-change]. The new rules require that, for an impl of a trait defined\nin some other crate, two conditions must hold:\n\n1. Some type must be local.\n2. Every type parameter must appear \"under\" some local type.\n\nHere are some examples that are legal:\n\n```rust\nstruct MyStruct<T> { ... }\n\n// Here `T` appears \"under' `MyStruct`.\nimpl<T> Clone for MyStruct<T> { }\n\n// Here `T` appears \"under' `MyStruct` as well. Note that it also appears\n// elsewhere.\nimpl<T> Iterator<T> for MyStruct<T> { }\n```\n\nHere is an illegal example:\n\n```rust\n// Here `U` does not appear \"under\" `MyStruct` or any other local type.\n// We call `U` \"uncovered\".\nimpl<T,U> Iterator<U> for MyStruct<T> { }\n```\n\nThere are a couple of ways to rewrite this last example so that it is\nlegal:\n\n1. In some cases, the uncovered type parameter (here, `U`) should be converted\n   into an associated type. This is however a non-local change that requires access\n   to the original trait. Also, associated types are not fully baked.\n2. Add `U` as a type parameter of `MyStruct`:\n   ```rust\n   struct MyStruct<T,U> { ... }\n   impl<T,U> Iterator<U> for MyStruct<T,U> { }\n   ```\n3. Create a newtype wrapper for `U`\n   ```rust\n   impl<T,U> Iterator<Wrapper<U>> for MyStruct<T,U> { }\n   ```\n\nBecause associated types are not fully baked, which in the case of the\n`Hash` trait makes adhering to this rule impossible, you can\ntemporarily disable this rule in your crate by using\n`#![feature(old_orphan_check)]`. Note that the `old_orphan_check`\nfeature will be removed before 1.0 is released."
  },
  {
    "hash": "9ca8076cb77a7d7738162c80e1d240ef2ad0b73a",
    "author": "Alex Crichton",
    "date": 1420219357,
    "message": "rollup merge of #20386: frewsxcv/rm-reexports\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "f9ce6f5ba458d6a3d4e63b282bac43a18e90aeb0",
    "author": "Corey Farwell",
    "date": 1420082881,
    "message": "Remove core::iter::MinMaxResult::* public reexport\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "f3a7ec7028c76b3a1c6051131328f372b068e33a",
    "author": "Alex Crichton",
    "date": 1420178579,
    "message": "std: Second pass stabilization of sync\n\nThis pass performs a second pass of stabilization through the `std::sync`\nmodule, avoiding modules/types that are being handled in other PRs (e.g.\nmutexes, rwlocks, condvars, and channels).\n\nThe following items are now stable\n\n* `sync::atomic`\n* `sync::atomic::ATOMIC_BOOL_INIT` (was `INIT_ATOMIC_BOOL`)\n* `sync::atomic::ATOMIC_INT_INIT` (was `INIT_ATOMIC_INT`)\n* `sync::atomic::ATOMIC_UINT_INIT` (was `INIT_ATOMIC_UINT`)\n* `sync::Once`\n* `sync::ONCE_INIT`\n* `sync::Once::call_once` (was `doit`)\n  * C == `pthread_once(..)`\n  * Boost == `call_once(..)`\n  * Windows == `InitOnceExecuteOnce`\n* `sync::Barrier`\n* `sync::Barrier::new`\n* `sync::Barrier::wait` (now returns a `bool`)\n* `sync::Semaphore::new`\n* `sync::Semaphore::acquire`\n* `sync::Semaphore::release`\n\nThe following items remain unstable\n\n* `sync::SemaphoreGuard`\n* `sync::Semaphore::access` - it's unclear how this relates to the poisoning\n                              story of mutexes.\n* `sync::TaskPool` - the semantics of a failing task and whether a thread is\n                     re-attached to a thread pool are somewhat unclear, and the\n                     utility of this type in `sync` is question with respect to\n                     the jobs of other primitives. This type will likely become\n                     stable or move out of the standard library over time.\n* `sync::Future` - futures as-is have yet to be deeply re-evaluated with the\n                   recent core changes to Rust's synchronization story, and will\n                   likely become stable in the future but are unstable until\n                   that time comes.\n\n[breaking-change]"
  },
  {
    "hash": "f2ccdfd8914b7b8f8f8f2053f9ecd98d54ef95a6",
    "author": "Alex Crichton",
    "date": 1420180313,
    "message": "std: Second pass stabilization for `boxed`\n\nThis commit performs a second pass over the `std::boxed` module, taking the\nfollowing actions:\n\n* `boxed` is now stable\n* `Box` is now stable\n* `BoxAny` is removed in favor of a direct `impl Box<Any>`\n* `Box::downcast` remains unstable while the name of the `downcast` family of\n  methods is determined.\n\nThis is a breaking change due to the removal of the `BoxAny` trait (note that\nthe `downcast` method still exists), and existing consumers of `BoxAny` simply\nneed to remove the import in their modules.\n\n[breaking-change]"
  },
  {
    "hash": "a6f5b980cc44621efeed847e8d359f3b90c29080",
    "author": "Alex Crichton",
    "date": 1420070700,
    "message": "rustc: Re-jigger -L and -l for MSYS compatibility\n\nAs discovered in #20376, the MSYS shell will silently rewrite arguemnts that\nlook like unix paths into their windows path counterparts for compatibility, but\nthe recently added `:kind` syntax added to the `-L` flag does not allow for this\nform of rewriting. This means that the syntax can be difficult to use at an MSYS\nprompt, as well as causing tests to fail when run manuall right now.\n\nThis commit takes the other option presented in the original issue to prefix the\npath with `kind=` instead of suffixing it with `:kind`. For consistence, the\n`-l` flag is also now migrating to `kind=name`.\n\nThis is a breaking change due to the *removal* of behavior with `-L`. All code\nusing `:kind` should now pass `kind=` for `-L` arguments. This is not currently,\nbut will become, a breaking change for `-l` flags. The old `name:kind` syntax is\nstill accepted, but all code should update to `kind=name`.\n\n[breaking-change]\nCloses #20376"
  },
  {
    "hash": "e423fcf0e0166da55f88233e0be5eacba55bc0bc",
    "author": "Alex Crichton",
    "date": 1420178686,
    "message": "std: Enforce Unicode in fmt::Writer\n\nThis commit is an implementation of [RFC 526][rfc] which is a change to alter\nthe definition of the old `fmt::FormatWriter`. The new trait, renamed to\n`Writer`, now only exposes one method `write_str` in order to guarantee that all\nimplementations of the formatting traits can only produce valid Unicode.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0526-fmt-text-writer.md\n\nOne of the primary improvements of this patch is the performance of the\n`.to_string()` method by avoiding an almost-always redundant UTF-8 check. This\nis a breaking change due to the renaming of the trait as well as the loss of the\n`write` method, but migration paths should be relatively easy:\n\n* All usage of `write` should move to `write_str`. If truly binary data was\n  being written in an implementation of `Show`, then it will need to use a\n  different trait or an altogether different code path.\n\n* All usage of `write!` should continue to work as-is with no modifications.\n\n* All usage of `Show` where implementations just delegate to another should\n  continue to work as-is.\n\n[breaking-change]\n\nCloses #20352"
  },
  {
    "hash": "bc83a009f655dd3896be4a7cd33cac8032a605f2",
    "author": "Alex Crichton",
    "date": 1419884209,
    "message": "std: Second pass stabilization for `comm`\n\nThis commit is a second pass stabilization for the `std::comm` module,\nperforming the following actions:\n\n* The entire `std::comm` module was moved under `std::sync::mpsc`. This movement\n  reflects that channels are just yet another synchronization primitive, and\n  they don't necessarily deserve a special place outside of the other\n  concurrency primitives that the standard library offers.\n* The `send` and `recv` methods have all been removed.\n* The `send_opt` and `recv_opt` methods have been renamed to `send` and `recv`.\n  This means that all send/receive operations return a `Result` now indicating\n  whether the operation was successful or not.\n* The error type of `send` is now a `SendError` to implement a custom error\n  message and allow for `unwrap()`. The error type contains an `into_inner`\n  method to extract the value.\n* The error type of `recv` is now `RecvError` for the same reasons as `send`.\n* The `TryRecvError` and `TrySendError` types have had public reexports removed\n  of their variants and the variant names have been tweaked with enum\n  namespacing rules.\n* The `Messages` iterator is renamed to `Iter`\n\nThis functionality is now all `#[stable]`:\n\n* `Sender`\n* `SyncSender`\n* `Receiver`\n* `std::sync::mpsc`\n* `channel`\n* `sync_channel`\n* `Iter`\n* `Sender::send`\n* `Sender::clone`\n* `SyncSender::send`\n* `SyncSender::try_send`\n* `SyncSender::clone`\n* `Receiver::recv`\n* `Receiver::try_recv`\n* `Receiver::iter`\n* `SendError`\n* `RecvError`\n* `TrySendError::{mod, Full, Disconnected}`\n* `TryRecvError::{mod, Empty, Disconnected}`\n* `SendError::into_inner`\n* `TrySendError::into_inner`\n\nThis is a breaking change due to the modification of where this module is\nlocated, as well as the changing of the semantics of `send` and `recv`. Most\nprograms just need to rename imports of `std::comm` to `std::sync::mpsc` and\nadd calls to `unwrap` after a send or a receive operation.\n\n[breaking-change]"
  },
  {
    "hash": "c32d03f4172580e3f33e4844ed3c01234dca2d53",
    "author": "Alex Crichton",
    "date": 1419872301,
    "message": "std: Stabilize the prelude module\n\nThis commit is an implementation of [RFC 503][rfc] which is a stabilization\nstory for the prelude. Most of the RFC was directly applied, removing reexports.\nSome reexports are kept around, however:\n\n* `range` remains until range syntax has landed to reduce churn.\n* `Path` and `GenericPath` remain until path reform lands. This is done to\n  prevent many imports of `GenericPath` which will soon be removed.\n* All `io` traits remain until I/O reform lands so imports can be rewritten all\n  at once to `std::io::prelude::*`.\n\nThis is a breaking change because many prelude reexports have been removed, and\nthe RFC can be consulted for the exact list of removed reexports, as well as to\nfind the locations of where to import them.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md\n[breaking-change]\n\nCloses #20068"
  },
  {
    "hash": "56290a004493a5d2e211f056601533253497df60",
    "author": "Alex Crichton",
    "date": 1420217646,
    "message": "std: Stabilize the prelude module\n\nThis commit is an implementation of [RFC 503][rfc] which is a stabilization\nstory for the prelude. Most of the RFC was directly applied, removing reexports.\nSome reexports are kept around, however:\n\n* `range` remains until range syntax has landed to reduce churn.\n* `Path` and `GenericPath` remain until path reform lands. This is done to\n  prevent many imports of `GenericPath` which will soon be removed.\n* All `io` traits remain until I/O reform lands so imports can be rewritten all\n  at once to `std::io::prelude::*`.\n\nThis is a breaking change because many prelude reexports have been removed, and\nthe RFC can be consulted for the exact list of removed reexports, as well as to\nfind the locations of where to import them.\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0503-prelude-stabilization.md\n[breaking-change]\n\nCloses #20068"
  },
  {
    "hash": "71b46b18a274edc7f7fb60b490e5ebbb9c911462",
    "author": "bors",
    "date": 1420213885,
    "message": "auto merge of #20356 : Gankro/rust/stab, r=aturon\n\nThis stabilizes most of libcollections, carefully avoiding sections of API which are being managed in other PRs. APIs which are not stable are marked explicitly unstable with a reason.\r\n\r\nDeprecates:\r\n\r\n* DList\r\n  * rotate_forward\r\n  * rotate_backward\r\n  * prepend\r\n  * insert_when\r\n  * insert_ordered\r\n  * merge\r\n\r\n* VecMap\r\n  * update\r\n  * update_with_key\r\n\r\n* Renames and newtypes the Bitv and BitvSet iterators to match conventions.\r\n\r\n* Removes the Copy impl from DList's Iter.\r\n\r\nas such this is a\r\n\r\n[breaking-change]"
  },
  {
    "hash": "d45b5d2ed9b43b3ad573482fb8820a382f20289e",
    "author": "Nick Cameron",
    "date": 1420147699,
    "message": "Disallow [_, ..n] syntax for fixed length arrays and repeating array constructors\n\nCloses #19999\n\n[breaking-change]\n\nUse [_; n] instead."
  },
  {
    "hash": "39d74026663597a8d4ad0ab04e6d117bf9fd6ad4",
    "author": "bors",
    "date": 1420127468,
    "message": "auto merge of #20190 : cmr/rust/gate-macro-args, r=alexcrichton\n\nUses the same approach as https://github.com/rust-lang/rust/pull/17286 (and\r\nsubsequent changes making it more correct), where the visitor will skip any\r\npieces of the AST that are from \"foreign code\", where the spans don't line up,\r\nindicating that that piece of code is due to a macro expansion.\r\n\r\nIf this breaks your code, read the error message to determine which feature\r\ngate you should add to your crate.\r\n\r\nCloses #18102\r\n\r\n[breaking-change]"
  },
  {
    "hash": "41da99dff417eadf8f296a93529d9810f79e1d1b",
    "author": "Corey Richardson",
    "date": 1420114006,
    "message": "Feature gate macro arguments\n\nUses the same approach as https://github.com/rust-lang/rust/pull/17286 (and\nsubsequent changes making it more correct), where the visitor will skip any\npieces of the AST that are from \"foreign code\", where the spans don't line up,\nindicating that that piece of code is due to a macro expansion.\n\nIf this breaks your code, read the error message to determine which feature\ngate you should add to your crate, and bask in the knowledge that your code\nwon't mysteriously break should you try to use the 1.0 release.\n\nCloses #18102\n\n[breaking-change]"
  },
  {
    "hash": "47b8479e73e40395f1b1b2d0c6281f28f80301e4",
    "author": "bors",
    "date": 1420084862,
    "message": "auto merge of #20363 : japaric/rust/moar-uc, r=nmatsakis\n\nThe the last argument of the `ItemDecorator::expand` method has changed to `Box<FnMut>`. Syntax extensions will break.\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nThis PR removes pretty much all the remaining uses of boxed closures from the libraries. There are still boxed closures under the `test` directory, but I think those should be removed or replaced with unboxed closures at the same time we remove boxed closures from the language.\r\n\r\nIn a few places I had to do some contortions (see the first commit for an example) to work around issue #19596. I have marked those workarounds with FIXMEs. In the future when `&mut F where F: FnMut` implements the `FnMut` trait, we should be able to remove those workarounds. I've take care to avoid placing the workaround functions in the public API.\r\n\r\nSince `let f = || {}` always gets type checked as a boxed closure, I have explictly annotated those closures (with e.g. `|&:| {}`) to force the compiler to type check them as unboxed closures.\r\n\r\nInstead of removing the type aliases (like `GetCrateDataCb`), I could have replaced them with newtypes. But this seemed like overcomplicating things for little to no gain.\r\n\r\nI think we should be able to remove the boxed closures from the languge after this PR lands. (I'm being optimistic here)\r\n\r\nr? @alexcrichton or @aturon \r\ncc @nikomatsakis"
  },
  {
    "hash": "e91d810b9b36d6bb163970cd0e8bbf4692f704bb",
    "author": "Aaron Turon",
    "date": 1419969742,
    "message": "Libs: Unify concat and concat_vec\n\nWe've long had traits `StrVector` and `VectorVector` providing\n`concat`/`connect` and `concat_vec`/`connect_vec` respectively. The\nreason for the distinction is that coherence rules did not used to be\nrobust enough to allow impls on e.g. `Vec<String>` versus `Vec<&[T]>`.\n\nThis commit consolidates the traits into a single `SliceConcatExt` trait\nprovided by `slice` and the preldue (where it replaces `StrVector`,\nwhich is removed.)\n\n[breaking-change]"
  },
  {
    "hash": "4f863a338e0a7c33f81a8ac138103f1a0e8b33c5",
    "author": "Aaron Turon",
    "date": 1419969742,
    "message": "Second pass stabilization: slice\n\nThis commit takes a second pass through the `slice` module to\nstabilize its API. The changes are as follows:\n\n**Stable**:\n\n* `as_mut_slice`\n* `as_ptr`, `as_mut_ptr`\n* `binary_search_by` (was: `binary_search`)\n* `binary_search` (was: `binary_search_elem`)\n* `chunks`, `chunks_mut`\n* `contains`\n* `ends_with`\n* `first`, `first_mut` (was: `head`)\n* `get_unchecked`, `get_unchecked_mut` (was: `unsafe_get`)\n* `get`\n* `is_empty`\n* `iter`, `iter_mut`\n* `len`\n* `reverse`\n* `sort_by`\n* `sort`\n* `split_at`, `split_at_mut`\n* `split_mut`, `splitn_mut`, `rsplitn_mut`\n* `split`, `splitn`, `rsplitn`\n* `starts_with`\n* `swap`\n* `to_vec`\n* `windows`\n\n**Deprecated**:\n\n* `head`, `head_mut` (renamed as above)\n* `unsafe_get`, `unsafe_mut` (renamed as above)\n* `binary_search_elem` (renamed as above)\n* `partitioned`, deprecated in favor of a new, more\n  general iterator consumer called `partition`.\n* `BinarySearchResult`, deprecated in favor of `Result<uint, uint>`\n\n[breaking-change]"
  },
  {
    "hash": "9d919d2302b5df42e3bf8979560e0da21f4b2bad",
    "author": "Aaron Turon",
    "date": 1419969742,
    "message": "Second pass stabilization: vec\n\nThis commit takes a second pass through the `vec` module to\nstabilize its API. The changes are as follows:\n\n**Stable**:\n\n* `dedup`\n* `from_raw_parts`\n* `insert`\n* `into_iter`\n* `is_empty`\n* `remove`\n* `reserve_exact`\n* `reserve`\n* `retain`\n* `swap_remove`\n* `truncate`\n\n**Deprecated**:\n\n* `from_fn`, `from_elem`, `grow_fn` and `grow`, all deprecated in\n  favor of iterators. See https://github.com/rust-lang/rfcs/pull/509\n\n* `partition`, `partitioned`, deprecated in favor of a new, more\n  general iterator consumer called `partition`.\n\n* `unzip`, deprecated in favor of a new, more general iterator\n  consumer called `unzip`.\n\nA few remaining methods are left at experimental status.\n\n[breaking-change]"
  },
  {
    "hash": "38f9805f11721d854a59818e0ad7b8a0b6282301",
    "author": "Alex Crichton",
    "date": 1419985582,
    "message": "rollup merge of #20348: frewsxcv/rm-reexports\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "1d26fb9e07e664b312ca9d7b666f6d1dd52285ed",
    "author": "Corey Farwell",
    "date": 1419968631,
    "message": "Remove core::atomic::Ordering::* public reexport\n\nPart of #19253\n\n[breaking-change]"
  },
  {
    "hash": "b94bcbf56eab163517e8ffc93888284b8dbb6238",
    "author": "Aaron Turon",
    "date": 1419979466,
    "message": "Stabilize cmp\n\nThis patch marks `PartialEq`, `Eq`, `PartialOrd`, and `Ord` as\n`#[stable]`, as well as the majorify of manual implementaitons of these\ntraits. The traits match the [reform\nRFC](https://github.com/rust-lang/rfcs/pull/439).\n\nAlong the way, two changes are made:\n\n* The recently-added type parameters for `Ord` and `Eq` are\n  removed. These were mistakenly added while adding them to `PartialOrd`\n  and `PartialEq`, but they don't make sense given the laws that are\n  required for (and use cases for) `Ord` and `Eq`.\n\n* More explicit laws are added for `PartialEq` and `PartialOrd`,\n  connecting them to their associated mathematical concepts.\n\nIn the future, many of the impls should be generalized; see\nsince generalizing later is not a breaking change.\n\n[breaking-change]"
  },
  {
    "hash": "79db01a30d22950ad1597d495b76d2f58da859dc",
    "author": "Alex Crichton",
    "date": 1419899812,
    "message": "rollup merge of #20306: alexcrichton/second-pass-string\n\nThis commit performs a second pass over the `std::string` module, performing the\nfollowing actions:\n\n* The name `std::string` is now stable.\n* The `String::from_utf8` function is now stable after having been altered to\n  return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now\n  stable as well as its `into_bytes` and `utf8_error` methods.\n* The `String::from_utf8_lossy` function is now stable.\n* The `String::from_chars` method is now deprecated in favor of `.collect()`\n* The `String::from_raw_parts` method is now stable\n* The `String::from_str` function remains experimental\n* The `String::from_raw_buf` function remains experimental\n* The `String::from_raw_buf_len` function remains experimental\n* The `String::from_utf8_unchecked` function is now stable\n* The `String::from_char` function is now deprecated in favor of\n  `repeat(c).take(n).collect()`\n* The `String::grow` function is now deprecated in favor of\n  `.extend(repeat(c).take(n)`\n* The `String::capacity` method is now stable\n* The `String::reserve` method is now stable\n* The `String::reserve_exact` method is now stable\n* The `String::shrink_to_fit` method is now stable\n* The `String::pop` method is now stable\n* The `String::as_mut_vec` method is now stable\n* The `String::is_empty` method is now stable\n* The `IntoString` trait is now deprecated (there are no implementors)\n* The `String::truncate` method is now stable\n* The `String::insert` method is now stable\n* The `String::remove` method is now stable\n* The `String::push` method is now stable\n* The `String::push_str` method is now stable\n* The `String::from_utf16` function is now stable after its error type has now\n  become an opaque structure to carry more semantic information in the future.\n\nA number of these changes are breaking changes, but the migrations should be\nfairly straightforward on a case-by-case basis (outlined above where possible).\n\n[breaking-change]"
  },
  {
    "hash": "b26daf3a67a4e283a5e2c49227b60a2321434de0",
    "author": "Alex Crichton",
    "date": 1419891076,
    "message": "std: Second pass stabilization for `string`\n\nThis commit performs a second pass over the `std::string` module, performing the\nfollowing actions:\n\n* The name `std::string` is now stable.\n* The `String::from_utf8` function is now stable after having been altered to\n  return a new `FromUtf8Error` structure. The `FromUtf8Error` structure is now\n  stable as well as its `into_bytes` and `utf8_error` methods.\n* The `String::from_utf8_lossy` function is now stable.\n* The `String::from_chars` method is now deprecated in favor of `.collect()`\n* The `String::from_raw_parts` method is now stable\n* The `String::from_str` function remains experimental\n* The `String::from_raw_buf` function remains experimental\n* The `String::from_raw_buf_len` function remains experimental\n* The `String::from_utf8_unchecked` function is now stable\n* The `String::from_char` function is now deprecated in favor of\n  `repeat(c).take(n).collect()`\n* The `String::grow` function is now deprecated in favor of\n  `.extend(repeat(c).take(n)`\n* The `String::capacity` method is now stable\n* The `String::reserve` method is now stable\n* The `String::reserve_exact` method is now stable\n* The `String::shrink_to_fit` method is now stable\n* The `String::pop` method is now stable\n* The `String::as_mut_vec` method is now stable\n* The `String::is_empty` method is now stable\n* The `IntoString` trait is now deprecated (there are no implementors)\n* The `String::truncate` method is now stable\n* The `String::insert` method is now stable\n* The `String::remove` method is now stable\n* The `String::push` method is now stable\n* The `String::push_str` method is now stable\n* The `String::from_utf16` function is now stable after its error type has now\n  become an opaque structure to carry more semantic information in the future.\n\nA number of these changes are breaking changes, but the migrations should be\nfairly straightforward on a case-by-case basis (outlined above where possible).\n\n[breaking-change]"
  },
  {
    "hash": "f53314cd70dd194ea40c55a5d8ceae7b94409aea",
    "author": "Nick Cameron",
    "date": 1419830349,
    "message": "Remove the glob/shadowing exception bug\n\n[breaking-change]\n\nThis and the other commit in this PR change the rules for shadowing and globs to be\nstricter. There were previously bugs where some glob imports would not be checked\nfor shadowing. Those are now fixed and you may have to adjust your imports to use\nfewer globs."
  },
  {
    "hash": "1e89bbcb67020892bc0af5af218c35f0fd453fa4",
    "author": "Simonas Kazlauskas",
    "date": 1419767195,
    "message": "Rename TaskRng to ThreadRng\n\nSince runtime is removed, rust has no tasks anymore and everything is moving\nfrom being task-* to thread-*. Let‚Äôs rename TaskRng as well!\n\n* Rename TaskRng to ThreadRng\n* Rename task_rng to thread_rng\n\n[breaking-change]"
  },
  {
    "hash": "748440c5b3bad8a837918400973e9d6cbb58fa7a",
    "author": "Alex Crichton",
    "date": 1419899766,
    "message": "rollup merge of #20215: csouth3/hashmap-rename\n\nRename struct `Entries` to `Iter` in hash/table.rs and hash/map.rs, to match the naming convention of rust-lang/rfcs#344.\n\nThis is a [breaking-change]."
  },
  {
    "hash": "625697354db8a13450f6d56c7a384c202a79c9db",
    "author": "Chase Southwood",
    "date": 1419473988,
    "message": "Rename remaining hashmap and hashtable iterators to match naming\nconventions.\n\nThis is a [breaking-change]."
  },
  {
    "hash": "cc20d6009ebf46b7ec75020ebfe35ff0ef064d1b",
    "author": "Alex Crichton",
    "date": 1419899750,
    "message": "rollup merge of #19661: alexcrichton/mutex-result\n\nAll of the current std::sync primitives have poisoning enable which means that\nwhen a task fails inside of a write-access lock then all future attempts to\nacquire the lock will fail. This strategy ensures that stale data whose\ninvariants are possibly not upheld are never viewed by other tasks to help\npropagate unexpected panics (bugs in a program) among tasks.\n\nCurrently there is no way to test whether a mutex or rwlock is poisoned. One\nmethod would be to duplicate all the methods with a sister foo_catch function,\nfor example. This pattern is, however, against our [error guidelines][errors].\nAs a result, this commit exposes the fact that a task has failed internally\nthrough the return value of a `Result`.\n\n[errors]: https://github.com/rust-lang/rfcs/blob/master/text/0236-error-conventions.md#do-not-provide-both-result-and-fail-variants\n\nAll methods now return a `LockResult<T>` or a `TryLockResult<T>` which\ncommunicates whether the lock was poisoned or not. In a `LockResult`, both the\n`Ok` and `Err` variants contains the `MutexGuard<T>` that is being returned in\norder to allow access to the data if poisoning is not desired. This also means\nthat the lock is *always* held upon returning from `.lock()`.\n\nA new type, `PoisonError`, was added with one method `into_guard` which can\nconsume the assertion that a lock is poisoned to gain access to the underlying\ndata.\n\nThis is a breaking change because the signatures of these methods have changed,\noften incompatible ways. One major difference is that the `wait` methods on a\ncondition variable now consume the guard and return it in as a `LockResult` to\nindicate whether the lock was poisoned while waiting. Most code can be updated\nby calling `.unwrap()` on the return value of `.lock()`.\n\n[breaking-change]"
  },
  {
    "hash": "76e5ed655c762b812c3da4749a55f1bb1b52c787",
    "author": "Alex Crichton",
    "date": 1419873489,
    "message": "std: Return Result from RWLock/Mutex methods\n\nAll of the current std::sync primitives have poisoning enable which means that\nwhen a task fails inside of a write-access lock then all future attempts to\nacquire the lock will fail. This strategy ensures that stale data whose\ninvariants are possibly not upheld are never viewed by other tasks to help\npropagate unexpected panics (bugs in a program) among tasks.\n\nCurrently there is no way to test whether a mutex or rwlock is poisoned. One\nmethod would be to duplicate all the methods with a sister foo_catch function,\nfor example. This pattern is, however, against our [error guidelines][errors].\nAs a result, this commit exposes the fact that a task has failed internally\nthrough the return value of a `Result`.\n\n[errors]: https://github.com/rust-lang/rfcs/blob/master/text/0236-error-conventions.md#do-not-provide-both-result-and-fail-variants\n\nAll methods now return a `LockResult<T>` or a `TryLockResult<T>` which\ncommunicates whether the lock was poisoned or not. In a `LockResult`, both the\n`Ok` and `Err` variants contains the `MutexGuard<T>` that is being returned in\norder to allow access to the data if poisoning is not desired. This also means\nthat the lock is *always* held upon returning from `.lock()`.\n\nA new type, `PoisonError`, was added with one method `into_guard` which can\nconsume the assertion that a lock is poisoned to gain access to the underlying\ndata.\n\nThis is a breaking change because the signatures of these methods have changed,\noften incompatible ways. One major difference is that the `wait` methods on a\ncondition variable now consume the guard and return it in as a `LockResult` to\nindicate whether the lock was poisoned while waiting. Most code can be updated\nby calling `.unwrap()` on the return value of `.lock()`.\n\n[breaking-change]"
  },
  {
    "hash": "4e2afb0052618ca3d758fffd0cf50559be774391",
    "author": "Nick Cameron",
    "date": 1419897985,
    "message": "Remove ExprSlice by hacking the compiler\n\n[breaking-change]\n\nThe `mut` in slices is now redundant. Mutability is 'inferred' from position. This means that if mutability is only obvious from the type, you will need to use explicit calls to the slicing methods."
  },
  {
    "hash": "19f73b4ef6fb1d24f19738a8665889396fc1b0c8",
    "author": "bors",
    "date": 1419876150,
    "message": "auto merge of #20058 : Kimundi/rust/str_pattern_pre, r=alexcrichton\n\nThis stabilizes most methods on `&str` working with patterns in a way that is forwards-compatible with a generic string pattern matching API:\r\n- Methods that are using the primary name for their operation are marked as `#[stable]`, as they can be upgraded to a full `Pattern` API later without existing code breaking. Example: `contains(&str)`\r\n- Methods that are using a more specific name in order to not clash with the primary one are marked as `#[unstable]`, as they will likely be removed once their functionality is merged into the primary one. Example: `contains_char<C: CharEq>(C)`\r\n- The method docs got changed to consistently refer to the pattern types as a pattern.\r\n- Methods whose names do not match in the context of the more generic API got renamed. Example: `trim_chars -> trim_matches` \r\n\r\nAdditionally, all methods returning iterators got changed to return unique new types with changed names in accordance with the new naming guidelines.\r\n\r\nSee also https://github.com/rust-lang/rfcs/pull/528\r\n\r\nDue to some deprecations and type changes, this is a \r\n\r\n[breaking-change]"
  },
  {
    "hash": "3e6b29f8ad1ddfcb134d743a66ee5f467e16c350",
    "author": "bors",
    "date": 1419736308,
    "message": "auto merge of #20136 : eddyb/rust/format-args, r=alexcrichton\n\nWe have the technology: no longer do you need to write closures to use `format_args!`.\r\nThis is a `[breaking-change]`, as it forces you to clean up old hacks - if you had code like this:\r\n```rust\r\nformat_args!(fmt::format, \"{} {} {}\", a, b, c)\r\nformat_args!(|args| { w.write_fmt(args) }, \"{} {} {}\", x, y, z)\r\n```\r\nchange it to this: \r\n```rust\r\nfmt::format(format_args!(\"{} {} {}\", a, b, c))\r\nw.write_fmt(format_args!(\"{} {} {}\", x, y, z))\r\n```\r\nTo allow them to be called with `format_args!(...)` directly, several functions were modified to\r\ntake `fmt::Arguments` by value instead of by reference. Also, `fmt::Arguments` derives `Copy`\r\nnow in order to preserve all usecases that were previously possible."
  },
  {
    "hash": "070ab63807dc80fa6a6c5ee80531284761ab42de",
    "author": "bors",
    "date": 1419717103,
    "message": "auto merge of #19916 : SimonSapin/rust/ascii-reform, r=sfackler\n\nImplements [RFC 486](https://github.com/rust-lang/rfcs/pull/486). Fixes #19908.\r\n\r\n* Rename `to_ascii_{lower,upper}` to `to_ascii_{lower,upper}case`, per #14401\r\n* Remove the `Ascii` type and associated traits: `AsciiCast`, `OwnedAsciiCast`, `AsciiStr`, `IntoBytes`, and `IntoString`.\r\n* As a replacement, add `.is_ascii()` to `AsciiExt`, and implement `AsciiExt` for `u8` and `char`.\r\n\r\n[breaking-change]"
  },
  {
    "hash": "3a6ccdc263d9a169c2d317a6f78664e1f18d3b15",
    "author": "Simon Sapin",
    "date": 1419506377,
    "message": "Remove Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, IntoBytes, IntoString.\n\nAs a replacement, add is_ascii() to AsciiExt, and implement AsciiExt for u8 and char.\n\n[breaking-change]"
  },
  {
    "hash": "1e5811ef9271644db0d0ddaae351976b0d4abdd2",
    "author": "Simon Sapin",
    "date": 1419445984,
    "message": "Rename to_ascii_{lower,upper} to to_ascii_{lower,upper}case, per #14401\n\n[breaking-change]"
  },
  {
    "hash": "df0c6d93852c51b6936d4b72b6b4be5f1932fb8a",
    "author": "Nick Cameron",
    "date": 1419627325,
    "message": "save-analysis: emit names of items that a glob import actually imports.\n\nThere is also some work here to make resolve a bit more stable - it no longer overwrites a specific import with a glob import.\n\n[breaking-change]\n\nImport shadowing of single/list imports by globs is now forbidden. An interesting case is where a glob import imports a re-export (`pub use`) of a single import. This still counts as a single import for the purposes of shadowing .You can usually fix any bustage by re-ordering such imports. A single import may still shadow (override) a glob import or the prelude."
  },
  {
    "hash": "7e11b22713aebd28ceaaa2ecef937c9b9d247c2f",
    "author": "bors",
    "date": 1419454032,
    "message": "auto merge of #20117 : lfairy/rust/rename-include-bin, r=alexcrichton\n\nAccording to [RFC 344][], methods that return `&[u8]` should have names ending in `bytes`. Though `include_bin!` is a macro not a method, it seems reasonable to follow the convention anyway.\r\n\r\nWe keep the old name around for now, but trigger a deprecation warning when it is used.\r\n\r\n[RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md\r\n\r\n[breaking-change]"
  },
  {
    "hash": "85c1a4b1ba09dae786b3554e0ab596814efabe0e",
    "author": "Chris Wong",
    "date": 1419325592,
    "message": "Rename include_bin! to include_bytes!\n\nAccording to [RFC 344][], methods that return `&[u8]` should have names\nending in `bytes`. Though `include_bin!` is a macro not a method, it\nseems reasonable to follow the convention anyway.\n\nWe keep the old name around for now, but trigger a deprecation warning\nwhen it is used.\n\n[RFC 344]: https://github.com/rust-lang/rfcs/blob/master/text/0344-conventions-galore.md\n\n[breaking-change]"
  },
  {
    "hash": "96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61",
    "author": "bors",
    "date": 1419373270,
    "message": "auto merge of #19758 : tbu-/rust/pr_fp_name, r=alexcrichton\n\nThis is a [breaking-change]."
  },
  {
    "hash": "16f01cc13f6a092873096c44eed546561b88d245",
    "author": "Tobias Bucher",
    "date": 1419338529,
    "message": "Rename and namespace `FPCategory`\n\nRename `FPCategory` to `FpCategory` and `Fp* to `*` in order to adhere to the\nnaming convention\n\nThis is a [breaking-change].\n\nExisting code like this:\n```\nuse std::num::{FPCategory, FPNaN};\n```\nshould be adjusted to this:\n```\nuse std::num::FpCategory as Fp\n```\n\nIn the following code you can use the constants `Fp::Nan`, `Fp::Normal`, etc."
  },
  {
    "hash": "22050e3ed44d9b4d79edced506b470a425e0d302",
    "author": "Florian Wilkens",
    "date": 1419266734,
    "message": "Added missing renames:\n\nlibcollections:\n    AbsEntries -> AbsIter, Entries -> Iter, MoveEntries -> IntoIter, MutEntries -> IterMut\n    DifferenceItems -> Difference, SymDifferenceItems -> SymmetricDifference, IntersectionItems -> Intersection, UnionItems -> Union\n\nlibstd/hash/{table, map}:\n    Entries -> Iter, MoveItems -> IntoIter, MutEntries -> IterMut\n\nAlso a [breaking-change]."
  },
  {
    "hash": "f8cfd2480b69a1cc266fc91d0b60c825a9dc18a7",
    "author": "Florian Wilkens",
    "date": 1419249535,
    "message": "Renaming of the Iter types as in RFC #344\n\nlibcore: slice::Items -> slice::Iter, slice::MutItems -> slice::IterMut\nlibcollections: *::Items -> *::Iter, *::MoveItems -> *::IntoIter, *::MutItems -> *::IterMut\n\nThis is of course a [breaking-change]."
  },
  {
    "hash": "fac17defcb8d0642c25bf8f791e1dc5b4e110be8",
    "author": "Alex Crichton",
    "date": 1419281296,
    "message": "rollup merge of #20140: frewsxcv/rm-reexports\n\nPart of #19253\n\nI would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time\n\nIn #19407, I changed the codebase to stop utilizing this reexport\n\n[breaking-change]"
  },
  {
    "hash": "02feaf2a804e4e810d5a3adbedbcbe3905692286",
    "author": "Corey Farwell",
    "date": 1419276503,
    "message": "Remove cmp::Ordering::* public reexport\n\nPart of #19253\n\nI would have removed this public reexport in #19842, but #19812 hadn't merged (and snapshotted) at the time\n\nIn #19407, I changed the codebase to stop utilizing this reexport\n\n[breaking-change]"
  }
]