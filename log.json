[
  {
    "hash": "7d2f75a953b5645d3a336b2978b48b60d310bf54",
    "author": "bors",
    "date": 1465512517,
    "message": "Auto merge of #34095 - petrochenkov:pathir2, r=jseyfried\n\nImprovements to pattern resolution + some refactoring\n\nContinuation of https://github.com/rust-lang/rust/pull/33929\nFirst commit is a careful rewrite of `resolve_pattern`, pattern path resolution and new binding creation logic is factored out in separate functions, some minor bugs are fixed. Also, `resolve_possibly_assoc_item` doesn't swallow modules now.\nLater commits are refactorings, see the comment descriptions.\n\nI intend to continue this work later with better support for `Def::Err` in patterns in post-resolve stages and cleanup of pattern resolution code in type checker.\n\nFixes https://github.com/rust-lang/rust/issues/32086\nFixes https://github.com/rust-lang/rust/issues/34047 ([breaking-change])\nFixes https://github.com/rust-lang/rust/issues/34074\n\ncc @jseyfried\nr? @eddyb"
  },
  {
    "hash": "dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf",
    "author": "bors",
    "date": 1465451135,
    "message": "Auto merge of #34032 - jseyfried:load_macros_in_expansion, r=nrc\n\nSupport `#[macro_use]` on macro-expanded crates\n\nThis PR loads macros from `#[macro_use]` crates during expansion so that\n - macro-expanded `#[macro_use]` crates work (fixes #33936, fixes #28071), and\n - macros imported from crates have the same scope as macros imported from modules.\n\nThis is a [breaking-change]. For example, this will break:\n```rust\nmacro_rules! m {\n    () => { #[macro_use(foo)] extern crate core; } //~ ERROR imported macro not found\n}\nm!();\n```\nAlso, this will break:\n```rust\nmacro_rules! try { () => {} }\n// #[macro_use] mod bar { macro_rules! try { ... } } //< ... just like this would ...\nfn main() { try!(); } //< ... making this an error\n```\n\nr? @nrc"
  },
  {
    "hash": "bb4b3fb7f97924919f072ec9a360bdf943218dbf",
    "author": "bors",
    "date": 1465439433,
    "message": "Auto merge of #32202 - arielb1:slice-patterns, r=nikomatsakis\n\nImplement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns.\n\n[RFC 495 text](https://github.com/rust-lang/rfcs/blob/master/text/0495-array-pattern-changes.md)"
  },
  {
    "hash": "5c717a6fc21594569d9e64968cdcf2e88e372a07",
    "author": "Ariel Ben-Yehuda",
    "date": 1465421918,
    "message": "implement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns."
  },
  {
    "hash": "814f685df21439ab6eab83f421d4b60cab026a0b",
    "author": "Steve Klabnik",
    "date": 1465310638,
    "message": "Rollup merge of #34124 - jonas-schievink:remove-useless-optns, r=sanxiyn\n\nRemove old -Z options that do nothing\n\nTechnically, this is a [breaking-change], but I'm not sure what the policy for -Z flags is (especially unused ones)."
  },
  {
    "hash": "6e2f966f729821ebc85fdca6a426493d6d2178ce",
    "author": "Jonas Schievink",
    "date": 1465249424,
    "message": "Remove old -Z options that do nothing\n\nTechnically, this is a [breaking-change], but I'm not sure what the\npolicy for -Z flags is (especially unused ones)."
  },
  {
    "hash": "12d16599d84c25899f02a6e53110d1e70cdcbd8a",
    "author": "bors",
    "date": 1464801715,
    "message": "Auto merge of #33814 - lambda:rtabort-use-platform-abort, r=alexcrichton\n\nOpen code the __fastfail intrinsic for rtabort! on windows\n\nAs described https://msdn.microsoft.com/en-us/library/dn774154.aspx\n\nThis is a Windows 8+ mechanism for terminating the process quickly,\nwhich degrades to either an access violation or bugcheck in older versions.\n\nI'm not sure this is better the the current mechanism of terminating\nwith an illegal instruction, but we recently converted unix to\nterminate more correctly with SIGABORT, and this *seems* more correct\nfor windows.\n\n[breaking-change]"
  },
  {
    "hash": "696a570a00db2528b7934be32da7d8334738a997",
    "author": "Brian Anderson",
    "date": 1464094563,
    "message": "Open code the __fastfail intrinsic for rtabort! on windows\n\nAs described https://msdn.microsoft.com/en-us/library/dn774154.aspx\n\nThis is a Windows 8+ mechanism for terminating the process quickly,\nwhich degrades to either an access violation or bugcheck in older versions.\n\nI'm not sure this is better the the current mechanism of terminating\nwith an illegal instruction, but we recently converted unix to\nterminate more correctly with SIGABORT, and this *seems* more correct\nfor windows.\n\n[breaking-change]"
  },
  {
    "hash": "c2cab1fd58d6373582da189bd2c20ed3f6a7042a",
    "author": "bors",
    "date": 1464787313,
    "message": "Auto merge of #33794 - petrochenkov:sanity, r=nrc\n\nAdd AST validation pass and move some checks to it\n\nThe purpose of this pass is to catch constructions that fit into AST data structures, but not permitted by the language. As an example, `impl`s don't have visibilities, but for convenience and uniformity with other items they are represented with a structure `Item` which has `Visibility` field.\n\nThis pass is intended to run after expansion of macros and syntax extensions (and before lowering to HIR), so it can catch erroneous constructions that were generated by them. This pass allows to remove ad hoc semantic checks from the parser, which can be overruled by syntax extensions and occasionally macros.\n\nThe checks can be put here if they are simple, local, don't require results of any complex analysis like name resolution or type checking and maybe don't logically fall into other passes. I expect most of errors generated by this pass to be non-fatal and allowing the compilation to proceed.\n\nI intend to move some more checks to this pass later and maybe extend it with new checks, like, for example, identifier validity. Given that syntax extensions are going to be stabilized in the measurable future, it's important that they would not be able to subvert usual language rules.\n\nIn this patch I've added two new checks - a check for labels named `'static` and a check for lifetimes and labels named `'_`. The first one gives a hard error, the second one - a future compatibility warning.\nFixes https://github.com/rust-lang/rust/issues/33059 ([breaking-change])\ncc https://github.com/rust-lang/rfcs/pull/1177\n\nr? @nrc"
  },
  {
    "hash": "8b012ed142f03c9082773f5091c58c82d47cae79",
    "author": "bors",
    "date": 1464396374,
    "message": "Auto merge of #33706 - jseyfried:refactor_cfg, r=nrc\n\nPerform `cfg` attribute processing during macro expansion and fix bugs\n\nThis PR refactors `cfg` attribute processing and fixes bugs. More specifically:\n - It merges gated feature checking for stmt/expr attributes, `cfg_attr` processing, and `cfg` processing into a single fold.\n  - This allows feature gated `cfg` variables to be used in `cfg_attr` on unconfigured items. All other feature gated attributes can already be used on unconfigured items.\n - It performs `cfg` attribute processing during macro expansion instead of after expansion so that macro-expanded items are configured the same as ordinary items. In particular, to match their non-expanded counterparts,\n  - macro-expanded unconfigured macro invocations are no longer expanded,\n  - macro-expanded unconfigured macro definitions are no longer usable, and\n  - feature gated `cfg` variables on macro-expanded macro definitions/invocations are now errors.\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m {\n    () => {\n        #[cfg(attr)]\n        macro_rules! foo { () => {} }\n        foo!(); // This will be an error\n\n        macro_rules! bar { () => { fn f() {} } }\n        #[cfg(attr)] bar!(); // This will no longer be expanded ...\n        fn g() { f(); } // ... so that `f` will be unresolved.\n\n        #[cfg(target_thread_local)] // This will be a gated feature error\n        macro_rules! baz { () => {} }\n    }\n}\n\nm!();\n```\n\nr? @nrc"
  },
  {
    "hash": "7905452f083ab5ac3008dfe6727048e70bbeb142",
    "author": "Manish Goregaokar",
    "date": 1464323231,
    "message": "Rollup merge of #33644 - petrochenkov:selfast, r=nrc\n\n The AST part of https://github.com/rust-lang/rust/pull/33505.\nhttps://github.com/rust-lang/rust/pull/33505 isn't landed yet, so this PR is based on top of it.\n\nr? @nrc\n\nplugin-[breaking-change] cc #31645 @Manishearth"
  },
  {
    "hash": "35785712cd5e1acbfebd168c045b2e184ae979cc",
    "author": "Manish Goregaokar",
    "date": 1464323220,
    "message": "Rollup merge of #33639 - petrochenkov:dotdot, r=nmatsakis\n\n cc https://github.com/rust-lang/rust/issues/33627\nr? @nikomatsakis\n\nplugin-[breaking-change] cc https://github.com/rust-lang/rust/issues/31645 @Manishearth"
  },
  {
    "hash": "6e455640950c4e8cb8bff919edb4854fcf7773ca",
    "author": "bors",
    "date": 1463984051,
    "message": "Auto merge of #31457 - lambda:rtabort-use-libc-abort, r=alexcrichton\n\nUse libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333"
  },
  {
    "hash": "cfc386583291c8868d093d07431a57a20e69c944",
    "author": "Brian Campbell",
    "date": 1463977361,
    "message": "Use libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333"
  },
  {
    "hash": "b711734a5f7280cc3ceb99e09551a7b7691c7d0b",
    "author": "Niko Matsakis",
    "date": 1463580645,
    "message": "thread the DepGraph to session/crate-store\n\nThis is a [breaking-change] for plugin authors.\nYou must now create a dep-graph earlier."
  },
  {
    "hash": "2237e899084f16f61e4a74c191a74c7bb2fd3727",
    "author": "Niko Matsakis",
    "date": 1463580645,
    "message": "remove the `Any` bound from `CrateStore`\n\nThis is a [breaking-change] for plugins, which\nought by now to have stopped relying on downcasting."
  },
  {
    "hash": "1ec22171e6053c640293067418ea1901cb1c7df1",
    "author": "bors",
    "date": 1462692700,
    "message": "Auto merge of #33130 - eddyb:mir-const, r=nikomatsakis\n\nImplement constant support in MIR.\n\nAll of the intended features in `trans::consts` are now supported by `mir::constant`.\nThe implementation is considered a temporary measure until `miri` replaces it.\n\nA `-Z orbit` bootstrap build will only translate LLVM IR from AST for `#[rustc_no_mir]` functions.\n\nFurthermore, almost all checks of constant expressions have been moved to MIR.\nIn non-`const` functions, trees of temporaries are promoted, as per RFC 1414 (rvalue promotion).\nPromotion before MIR borrowck would allow reasoning about promoted values' lifetimes.\n\nThe improved checking comes at the cost of four `[breaking-change]`s:\n* repeat counts must contain a constant expression, e.g.:\n`let arr = [0; { println!(\"foo\"); 5 }];` used to be allowed (it behaved like `let arr = [0; 5];`)\n* dereference of a reference to a `static` cannot be used in another `static`, e.g.:\n`static X: [u8; 1] = [1]; static Y: u8 = (&X)[0];` was unintentionally allowed before\n* the type of a `static` *must* be `Sync`, irrespective of the initializer, e.g.\n`static FOO: *const T = &BAR;` worked as `&T` is `Sync`, but it shouldn't because `*const T` isn't\n* a `static` cannot wrap `UnsafeCell` around a type that *may* need drop, e.g.\n`static X: MakeSync<UnsafeCell<Option<String>>> = MakeSync(UnsafeCell::new(None));`\nwas previously allowed based on the fact `None` alone doesn't need drop, but in `UnsafeCell`\nit can be later changed to `Some(String)` which *does* need dropping\n\nThe drop restrictions are relaxed by RFC 1440 (#33156), which is implemented, but feature-gated.\nHowever, creating `UnsafeCell` from constants is unstable, so users can just enable the feature gate."
  },
  {
    "hash": "2f8f256cef42350af2f0376891fd020b6b1c37de",
    "author": "Ariel Ben-Yehuda",
    "date": 1462289410,
    "message": "require the existential bounds of an object type to be object-safe\n\nThis is required, as Copy and Sized are object-unsafe.\n\nAs a soundness fix, this is a [breaking-change]\n\nFixes #32963"
  },
  {
    "hash": "0a6dfc51777eb388b6e795399bf1d3f8aac57db8",
    "author": "Ariel Ben-Yehuda",
    "date": 1462289410,
    "message": "require the non-last elements of a tuple to be Sized\n\nThis requirement appears to be missing from RFC1214, but is clearly\nnecessary for translation. The last field of a tuple/enum remains in\na state of limbo, compiling but causing an ICE when it is used - we\nshould eventually fix that somehow.\n\nthis is a [breaking-change] - a soundness fix - and requires a\ncrater run."
  },
  {
    "hash": "c1c6e99bfd3296954a192d9fe3151a222dd9045c",
    "author": "Nick Cameron",
    "date": 1462230909,
    "message": "rebasing\n\nNote that this whole PR is a [breaking-change] for clients of the Compiler API."
  },
  {
    "hash": "a31658de51444d1b5193ac203a1bd7ace5621f93",
    "author": "Manish Goregaokar",
    "date": 1461525464,
    "message": "Rollup merge of #33041 - petrochenkov:path, r=nrc,Manishearth\n\n Paths are mostly parsed without taking whitespaces into account, e.g. `std :: vec :: Vec :: new ()` parses successfully, however, there are some special cases involving keywords `super`, `self` and `Self`. For example, `self::` is considered a path start only if there are no spaces between `self` and `::`. These restrictions probably made sense when `self` and friends weren't keywords, but now they are unnecessary.\n\nThe first two commits remove this special treatment of whitespaces by removing `token::IdentStyle` entirely and therefore fix https://github.com/rust-lang/rust/issues/14109.\nThis change also affects naked `self` and `super` (which are not tightly followed by `::`, obviously) they can now be parsed as paths, however they are still not resolved correctly in imports (cc @jseyfried, see `compile-fail/use-keyword.rs`), so https://github.com/rust-lang/rust/issues/29036 is not completely fixed.\n\nThe third commit also makes `super`, `self`, `Self` and `static` keywords nominally (before this they acted as keywords for all purposes) and removes most of remaining \\\"special idents\\\".\n\nThe last commit (before tests) contains some small improvements - some qualified paths with type parameters are parsed correctly, `parse_path` is not used for parsing single identifiers, imports are sanity checked for absence of type parameters - such type parameters can be generated by syntax extensions or by macros when https://github.com/rust-lang/rust/issues/10415 is fixed (~~soon!~~already!).\n\nThis patch changes some pretty basic things in `libsyntax`, like `token::Token` and the keyword list, so it's a plugin-[breaking-change].\n\nr? @eddyb"
  },
  {
    "hash": "23ccaddaa7d1cb71e49ef1b1f423b3245fa3a879",
    "author": "bors",
    "date": 1461447606,
    "message": "Auto merge of #33124 - sfackler:kill-ipv6-only, r=alexcrichton\n\nRemove IPV6_V6ONLY functionality\n\nThese settings can only be adjusted before bind time, which doesn't make\nsense in the current set of functionality. These methods are stable, but\nhaven't hit a stable release yet.\n\nCloses #33052\n\n[breaking-change]\n\nr? @alexcrichton\n\nWill also need a backport to the beta."
  },
  {
    "hash": "c6480e8b6b13401030c52f3c2b4fcc4e80c14481",
    "author": "Steven Fackler",
    "date": 1461213739,
    "message": "Remove IPV6_V6ONLY functionality\n\nThese settings can only be adjusted before bind time, which doesn't make\nsense in the current set of functionality. These methods are stable, but\nhaven't hit a stable release yet.\n\nCloses #33052\n\n[breaking-change]"
  },
  {
    "hash": "6ece1447f02b2310e5f4c7ef1efd1312476cae80",
    "author": "bors",
    "date": 1461162479,
    "message": "Auto merge of #32939 - eddyb:layout, r=nikomatsakis\n\nCompute LLVM-agnostic type layouts in rustc.\n\nLayout for monomorphic types, and some polymorphic ones (e.g. `&T` where `T: Sized`),\ncan now be computed by rustc without involving LLVM in the actual process.\n\nThis gives rustc the ability to evaluate `size_of` or `align_of`, as well as obtain field offsets.\nMIR-based CTFE will eventually make use of these layouts, as will MIR trans, shortly.\n\nLayout computation also comes with a `[breaking-change]`, or two:\n* `\"data-layout\"` is now mandatory in custom target specifications, reverting the decision from #27076.\nThis string is needed because it describes endianness, pointer size and alignments for various types.\nWe have the first two and we could allow tweaking alignments in target specifications.\nOr we could also extract the data layout from LLVM and feed it back into rustc.\nHowever, that can vary with the LLVM version, which is fragile and undermines stability.\nFor built-in targets, I've added a check that the hardcoded data-layout matches LLVM defaults.\n* `transmute` calls are checked in a stricter fashion, which fixes #32377\n\nTo expand on `transmute`, there are only 2 allowed patterns: between types with statically known sizes and between pointers with the same potentially-unsized \"tail\" (which determines the type of unsized metadata they use, if any).\nIf you're affected, my suggestions are:\n* try to use casts (and raw pointer deref) instead of transmutes\n* *really* try to avoid `transmute` where possible\n* if you have a structure, try working on individual fields and unpack/repack the structure instead of transmuting it whole, e.g. `transmute::<RefCell<Box<T>>, RefCell<*mut T>>(x)` doesn't work, but `RefCell::new(Box::into_raw(x.into_inner()))` does (and `Box::into_raw` is just a `transmute`)"
  },
  {
    "hash": "6a0cfbcac294faab2b8bcd95a04cda042101a2d8",
    "author": "Manish Goregaokar",
    "date": 1460749603,
    "message": "Rollup merge of #32923 - jseyfried:fix_hygiene, r=nrc\n\nFix macro hygiene bug\n\nThis fixes #32922 (EDIT: and fixes #31856), macro hygiene bugs.\nIt is a [breaking-change]. For example, the following would break:\n```rust\nfn main() {\n    let x = true;\n    macro_rules! foo { () => {\n        let x = 0;\n        macro_rules! bar { () => {x} }\n        let _: bool = bar!();\n        //^ `bar!()` used to resolve the first `x` (a bool),\n        //| but will now resolve to the second x (an i32).\n    }}\n    foo! {};\n}\n```\n\nr? @nrc"
  },
  {
    "hash": "af7b00b68fc7960e98fb914be52d9a6a16fe2224",
    "author": "Manish Goregaokar",
    "date": 1459943131,
    "message": "Rollup merge of #32682 - petrochenkov:field3, r=Manishearth\n\n The AST part of https://github.com/rust-lang/rust/pull/31937\n\nUnlike HIR, AST still uses `Option` for field names because parser can't know field indexes reliably due to constructions like\n```\nstruct S(#[cfg(false)] u8, u8); // The index of the second field changes from 1 during parsing to 0 after expansion.\n```\nand I wouldn't like to put the burden of renaming fields on expansion passes and syntax extensions.\n\nplugin-[breaking-change] cc https://github.com/rust-lang/rust/issues/31645\nr? @Manishearth"
  },
  {
    "hash": "772c600d4d6f39daa6d07d1a60ee0df3d3426978",
    "author": "bors",
    "date": 1459907904,
    "message": "Auto merge of #32688 - jseyfried:ast_groundwork_for_1422, r=pnkfelix\n\n[breaking-batch] Add support for `pub(restricted)` syntax in the AST\n\nThis PR allows the AST to represent the `pub(restricted)` syntax from RFC 1422 (cc #32409).\n\nMore specifically, it makes `ast::Visibility` non-`Copy` and adds two new variants, `Visibility::Crate` for `pub(crate)` and `Visitibility::Restricted { path: P<Path>, id: NodeId }` for `pub(path)`.\n\nplugin-[breaking-change] cc #31645\nr? @pnkfelix"
  },
  {
    "hash": "a11129701c873d96fe0816e4c8b55510efebe96e",
    "author": "bors",
    "date": 1459223442,
    "message": "Auto merge of #32479 - eddyb:eof-not-even-twice, r=nikomatsakis\n\nPrevent bumping the parser past the EOF.\n\nMakes `Parser::bump` after EOF into an ICE, forcing callers to avoid repeated EOF bumps.\nThis ICE is intended to break infinite loops where EOF wasn't stopping the loop.\n\nFor example, the handling of EOF in `parse_trait_items`' recovery loop fixes #32446.\nBut even without this specific fix, the ICE is triggered, which helps diagnosis and UX.\n\nThis is a `[breaking-change]` for plugins authors who eagerly eat multiple EOFs.\nSee https://github.com/docopt/docopt.rs/pull/171 for such an example and the necessary fix."
  },
  {
    "hash": "128b2ad8298f33984c64b98cfb354bb932b740ef",
    "author": "Manish Goregaokar",
    "date": 1458963441,
    "message": "Rollup merge of #32199 - nikomatsakis:limiting-constants-in-patterns-2, r=pnkfelix\n\nRestrict constants in patterns\n\nThis implements [RFC 1445](https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md). The primary change is to limit the types of constants used in patterns to those that *derive* `Eq` (note that implementing `Eq` is not sufficient). This has two main effects:\n\n1. Floating point constants are linted, and will eventually be disallowed. This is because floating point constants do not implement `Eq` but only `PartialEq`. This check replaces the existing special case code that aimed to detect the use of `NaN`.\n2. Structs and enums must derive `Eq` to be usable within a match.\n\nThis is a [breaking-change]: if you encounter a problem, you are most likely using a constant in an expression where the type of the constant is some struct that does not currently implement\n`Eq`. Something like the following:\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nThe easiest and most future compatible fix is to annotate the type in question with `#[derive(Eq)]` (note that merely *implementing* `Eq` is not enough, it must be *derived*):\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nAnother good option is to rewrite the match arm to use an `if` condition (this is also particularly good for floating point types, which implement `PartialEq` but not `Eq`):\n\n```rust\nmatch foo {\n    c if c == SOME_CONST => ...\n}\n```\n\nFinally, a third alternative is to tag the type with `#[structural_match]`; but this is not recommended, as the attribute is never expected to be stabilized. Please see RFC #1445 for more details.\n\ncc https://github.com/rust-lang/rust/issues/31434\n\nr? @pnkfelix"
  },
  {
    "hash": "f69eb8efbe5dbc373426bf0ff021b49f37db41cb",
    "author": "Niko Matsakis",
    "date": 1458902742,
    "message": "issue a future-compat lint for constants of invalid type\n\nThis is a [breaking-change]: according to RFC #1445, constants used as\npatterns must be of a type that *derives* `Eq`. If you encounter a\nproblem, you are most likely using a constant in an expression where the\ntype of the constant is some struct that does not currently implement\n`Eq`. Something like the following:\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nThe easiest and most future compatible fix is to annotate the type in\nquestion with `#[derive(Eq)]` (note that merely *implementing* `Eq` is\nnot enough, it must be *derived*):\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nAnother good option is to rewrite the match arm to use an `if`\ncondition (this is also particularly good for floating point types,\nwhich implement `PartialEq` but not `Eq`):\n\n```rust\nmatch foo {\n    c if c == SOME_CONST => ...\n}\n```\n\nFinally, a third alternative is to tag the type with\n`#[structural_match]`; but this is not recommended, as the attribute is\nnever expected to be stabilized. Please see RFC #1445 for more details."
  },
  {
    "hash": "64a13a46601bb47a470264936b623b4adf706128",
    "author": "bors",
    "date": 1458907393,
    "message": "Auto merge of #31908 - jseyfried:disallow_shadowed_traits, r=nikomatsakis\n\nDisallow methods from traits that are not in scope\n\nThis PR only allows a trait method to be used if the trait is in scope (fixes #31379).\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmod foo {\n    pub trait T { fn f(&self) {} }\n    impl T for () {}\n}\n\nmod bar { pub use foo::T; }\n\nfn main() {\n    pub use bar::*;\n    struct T; // This shadows the trait `T`,\n    ().f() // making this an error.\n}\n```\nr? @nikomatsakis"
  },
  {
    "hash": "06074ac004701bff42c625247c4764b2ae6fca6c",
    "author": "bors",
    "date": 1457848514,
    "message": "Auto merge of #32141 - jseyfried:fix_resolution_in_lexical_scopes, r=nikomatsakis\n\nFix name resolution in lexical scopes\n\nCurrently, `resolve_item_in_lexical_scope` does not check the \"ribs\" (type parameters and local variables). This can allow items that should be shadowed by type parameters to be named.\n\nFor example,\n```rust\nstruct T { i: i32 }\nfn f<T>() {\n    let t = T { i: 0 }; // This use of `T` resolves to the struct, not the type parameter\n}\n\nmod Foo {\n    pub fn f() {}\n}\nfn g<Foo>() {\n    Foo::f(); // This use of `Foo` resolves to the module, not the type parameter\n}\n```\n\nThis PR changes `resolve_item_in_lexical_scope` so that it fails when the item is shadowed by a rib (fixes #32120).\nThis is a [breaking-change], but it looks unlikely to cause breakage in practice.\n\nr? @nikomatsakis"
  },
  {
    "hash": "5807fbbfde3ad04820f6fa0269711c81538057ec",
    "author": "bors",
    "date": 1457717207,
    "message": "Auto merge of #32134 - jseyfried:forbid_type_alias_as_module, r=nikomatsakis\n\nForbid glob-importing from a type alias\n\nThis PR forbids glob-importing from a type alias or trait (fixes #30560):\n```rust\ntype Alias = ();\nuse Alias::*; // This is currently allowed but shouldn't be\n```\n\nThis is a [breaking-change]. Since the disallowed glob imports don't actually import anything, any breakage can be fixed by removing the offending glob import.\n\nr? @alexcrichton"
  },
  {
    "hash": "bcda58f49133921abd091d7f800732fe2c4e5a98",
    "author": "bors",
    "date": 1457583380,
    "message": "Auto merge of #31710 - eddyb:reify, r=nikomatsakis\n\nDistinguish fn item types to allow reification from nothing to fn pointers.\n\nThe first commit is a rebase of #26284, except for files that have moved since.\n\nThis is a [breaking-change], due to:\n* each FFI function has a distinct type, like all other functions currently do\n* all generic parameters on functions are recorded in their item types, e.g.:\n`size_of::<u8>` & `size_of::<i8>`'s types differ despite their identical signature.\n* function items are zero-sized, which will stop transmutes from working on them\n\nThe first two cases are handled in most cases with the new coerce-unify logic,\nwhich will combine incompatible function item types into function pointers,\nat the outer-most level of if-else chains, match arms and array literals.\n\nThe last case is specially handled during type-checking such that transmutes\nfrom a function item type to a pointer or integer type will continue to work for\nanother release cycle, but are being linted against. To get rid of warnings and\nensure your code will continue to compile, cast to a pointer before transmuting."
  },
  {
    "hash": "3a872782d396e9ed3827a515a54d1f0a634c0b77",
    "author": "Jonas Schievink",
    "date": 1455625960,
    "message": "Move more uses of `panictry!` out of libsyntax\n\n[breaking-change] for syntax extensions"
  },
  {
    "hash": "c5d58de665819f7330b3d64bdd084d25a412830a",
    "author": "Alex Burka",
    "date": 1456556501,
    "message": "core: add inclusive ranges to core::ops\n\nSince it removes the old iter::{range_inclusive, RangeInclusive} which\nwere unstable and deprecated, this is a [breaking-change] on nightly."
  },
  {
    "hash": "5b5e52186917502258a9feadc8bf77a89183386b",
    "author": "bors",
    "date": 1457074511,
    "message": "Auto merge of #32006 - jseyfried:fix_expanded_mod_path, r=nikomatsakis\n\nThis PR changes the search paths for macro-expanded non-inline modules so that they match ordinary non-inline modules (fixes #31624). This is a [breaking-change].\n\nRight now, the search paths for a macro-expanded non-inline module are computed as if the module were declared in the top level of the file in which the macro was defined.\nFor example, consider `./foo/mod.rs`:\n```rust\nmod inconsequential { // moving the macro outside this module wouldn't change anything\n    macro_rules! mod_decl {\n        ($i:ident) => { mod $i; }\n    }\n}\n```\nand `./lib.rs`:\n```rust\nmod foo;\n\nmod bar {\n    mod_decl!(baz);\n    //^ Now, rustc expects `./foo/baz.rs` (or `./foo/baz/mod.rs`)\n    //| After this PR, rustc will expect `./bar/baz.rs` (or `./bar/baz/mod.rs`)\n}\n```\nr? @alexcrichton"
  },
  {
    "hash": "7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f",
    "author": "bors",
    "date": 1456971688,
    "message": "Auto merge of #31824 - jseyfried:privacy_in_resolve, r=nikomatsakis\n\nThis PR privacy checks paths as they are resolved instead of in `librustc_privacy` (fixes #12334 and fixes #31779). This removes the need for the `LastPrivate` system introduced in PR #9735, the limitations of which cause #31779.\n\nThis PR also reports privacy violations in paths to intra- and inter-crate items the same way -- it always reports the first inaccessible segment of the path.\n\nSince it fixes #31779, this is a [breaking-change]. For example, the following code would break:\n```rust\nmod foo {\n    pub use foo::bar::S;\n    mod bar { // `bar` should be private to `foo`\n        pub struct S;\n    }\n}\n\nimpl foo::S {\n    fn f() {}\n}\n\nfn main() {\n    foo::bar::S::f(); // This is now a privacy error\n}\n```\n\nr? @alexcrichton"
  },
  {
    "hash": "acea6fc1cb5edf5211ade6ad4a79b119879eab82",
    "author": "Manish Goregaokar",
    "date": 1456486422,
    "message": "Rollup merge of #31904 - bluss:writer-formatter-error, r=alexcrichton\n\nMake sure formatter errors are emitted by the default Write::write_fmt\n\nPreviously, if an error was returned from the formatter that did not\noriginate in an underlying writer error, Write::write_fmt would return\nsuccessfully even if the formatting did not complete (was interrupted by\nan `fmt::Error` return).\n\nNow we choose to emit an io::Error with kind Other for formatter errors.\n\nSince this may reveal error returns from `write!()` and similar that\npreviously passed silently, it's a kind of a [breaking-change].\n\nFixes #31879"
  },
  {
    "hash": "6cfafad3c56736a62e1043a8d01f7f2c74384008",
    "author": "Ulrik Sverdrup",
    "date": 1456451965,
    "message": "Make sure formatter errors are emitted by the default Write::write_fmt\n\nPreviously, if an error was returned from the formatter that did not\noriginate in an underlying writer error, Write::write_fmt would return\nsuccessfully even if the formatting did not complete (was interrupted by\nan `fmt::Error` return).\n\nNow we choose to emit an io::Error with kind Other for formatter errors.\n\nSince this may reveal error returns from `write!()` and similar that\npreviously passed silently, it's a kind of a [breaking-change]."
  },
  {
    "hash": "9c6a0088fbdae5a6554c39f8db9207c1b878eb05",
    "author": "bors",
    "date": 1456461508,
    "message": "Auto merge of #31857 - jseyfried:fix_scoping, r=nikomatsakis\n\nThis fixes a bug (#31845) introduced in #31105 in which lexical scopes contain items from all anonymous module ancestors, even if the path to the anonymous module includes a normal module:\n```rust\nfn f() {\n    fn g() {}\n    mod foo {\n        fn h() {\n           g(); // This erroneously resolves on nightly\n        }\n    }\n}\n```\n\nThis is a [breaking-change] on nightly but not on stable or beta.\nr? @nikomatsakis"
  },
  {
    "hash": "9658645407c784105bb361297d5316cadc9ff2bd",
    "author": "bors",
    "date": 1455651297,
    "message": "Auto merge of #31534 - jseyfried:restrict_noninline_mod, r=nikomatsakis\n\nThis PR disallows non-inline modules without path annotations that are either in a block or in an inline module whose containing file is not a directory owner (fixes #29765).\nThis is a [breaking-change].\nr? @nikomatsakis"
  },
  {
    "hash": "9d98390765bbe61ce2a39b40c99ae1a68bb6d1cc",
    "author": "bors",
    "date": 1455430690,
    "message": "Auto merge of #31581 - petrochenkov:patrefact, r=Manishearth\n\ncc https://github.com/rust-lang/rust/pull/31487#issuecomment-182945101\nplugin-[breaking-change]\n\nThe first commit renames `ast::Pat_` to `ast::PatKind` and uses its variants in enum qualified form. I've also taken the opportunity and renamed `PatKind::Region` into `PatKind::Ref`.\n\nThe second commit splits `PatKind::Enum` into `PatKind::TupleStruct` and `PatKind::UnitStruct`.\nSo, pattern kinds now correspond to their struct/variant kinds - `Struct`, `TupleStruct` and `UnitStruct`.\n@nikomatsakis @nrc @arielb1 Are you okay with this naming scheme?\nAn alternative possible naming scheme is `PatKind::StructVariant`, `PatKind::TupleVariant`, `PatKind::UnitVariant` (it's probably closer to the common use, but I like it less).\n\nI intend to apply these changes to HIR later, they should not necessarily go in the same nightly with https://github.com/rust-lang/rust/pull/31487\nr? @Manishearth"
  },
  {
    "hash": "c7640aa2aaad857bbc9f9a1002f8e1aaf520752e",
    "author": "bors",
    "date": 1455288980,
    "message": "Auto merge of #31583 - petrochenkov:indi_ast, r=Manishearth\n\ncc #31487\nplugin-[breaking-change]\n\nThe AST part of https://github.com/rust-lang/rust/pull/30087\n\nr? @Manishearth"
  },
  {
    "hash": "2b816b0d6a9bc8210ca314a020a247f8632b4f38",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::PathListItem_ variants"
  },
  {
    "hash": "8b3856b1bc1c23969e5d8983f25cf85698a5c2b1",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::StrStyle variants"
  },
  {
    "hash": "d844bfb1967b780ff6cc6e81644bf4b529dc0738",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Visibility variants"
  },
  {
    "hash": "dfe35da6b83f64bb7553b19649839512a3c301ce",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::TraitItemKind variants"
  },
  {
    "hash": "73fa9b2da2ee82c91a5c8d605b91f22f19e4d74b",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Mutablity variants"
  },
  {
    "hash": "14e09ad4686bb20a98acfd7d930386f6330d2b4d",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::MetaItem_"
  },
  {
    "hash": "e797e1961df00ec7725c47225dcf9b5a0e9fce64",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::MacStmtStyle"
  },
  {
    "hash": "798974cae58639c174010fd4a6411dcdc860e404",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::KleeneOp variants"
  },
  {
    "hash": "019614f03d106324ab50a37746b556c41e66c099",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Item_ variants"
  },
  {
    "hash": "0d6ddd190355650a6d851c3aae12cf79339665af",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::ForeignItem_ variants"
  },
  {
    "hash": "8290c950a8b4cdc70038736abcf29f41dede6e0c",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::Stmt_ variants"
  },
  {
    "hash": "498a2e416e693fa22042d3ae81c5c969fc87fe5c",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::IntLitType variants"
  },
  {
    "hash": "69072c4f5d18d7a1762fbfb007b0ba3d6b59ad33",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::Lit_ variants"
  },
  {
    "hash": "05d4cefd630cd9ae104555e69ceb3b1566298a6a",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::Ty_ variants"
  },
  {
    "hash": "ec61e632c0a00ccc2ca0494d5d3c8a0848c574f2",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] remove unused enum ast::PrimTy"
  },
  {
    "hash": "bfa66bb389ce1c7ce4aff09d1842b3428015bd4d",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] remove the sign from integer literals in the ast"
  },
  {
    "hash": "625e78b7001c6e20f29928a5da8c9d21e9aed6c5",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::{UintTy, IntTy} variants"
  },
  {
    "hash": "ccf48bcd4054ecb4e205a18b1ac582ef3ac3a905",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::FloatTy variants"
  },
  {
    "hash": "80bf9ae18a133571d694aa866b824dcaea875d32",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Expr_ variants"
  },
  {
    "hash": "1c4d43715843a5ff5af4657c798b5d5cc85ca523",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::ExplicitSelf_ variants"
  },
  {
    "hash": "79fa657abc6b8885ceb4023099b4e0026c5ef28f",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Decl_ variants"
  },
  {
    "hash": "8516ba367d1f51318ce373fe9b60650c82ded1e9",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::CaptureClause variants"
  },
  {
    "hash": "243a30c9319b56e1be2b9ff2f9ed9e0d7583e2d1",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob import/export syntax::abi enum variants"
  },
  {
    "hash": "47b0784ba8e62a2e1b877750baeae10d16555fff",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::BlockCheckMode variants"
  },
  {
    "hash": "3b57d40fe5a813ac957667ac04938753e3100f55",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob import ast::FunctionRetTy variants"
  },
  {
    "hash": "05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::BinOp_"
  },
  {
    "hash": "f875f4c4c24e8a14c04bbe4eedd230c4aa3c1431",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::UnOp variants"
  },
  {
    "hash": "1de70d33f7baf12978cfb3de861e61b2a5d6fca7",
    "author": "bors",
    "date": 1455164833,
    "message": "Auto merge of #31461 - jseyfried:remove_import_resolutions, r=nrc\n\nThis PR adds to `NameBinding` so it can more fully represent bindings from imports as well from items, refactors away `Target`, generalizes `ImportResolution` to a simpler type `NameResolution`, and uses a single `NameResolution`-valued map in place the existing maps `children` and `import_resolutions` (of `NameBinding`s and `ImportResolution`s, respectively), simplifying duplicate checking and name resolution.\n\nIt also unifies the `resolve_name_in_module` in `lib.rs` with its namesake in `resolve_imports.rs`, clarifying and improving the core logic (fixes #31403 and fixes #31404) while maintaining clear future-comparability with shadowable globs (i.e., never reporting that a resolution is a `Success` or is `Failing` unless this would also be knowable with shadowable globs).\n\nSince it fixes #31403, this is technically a [breaking-change], but it is exceedingly unlikely to cause breakage in practice. The following is an example of code that would break:\n```rust\nmod foo {\n    pub mod bar {} // This defines bar in the type namespace\n    pub use alpha::bar; // This defines bar in the value namespace\n\n    // This should define baz in both namespaces, but it only defines baz in the type namespace.\n    pub use self::bar as baz;\n    pub fn baz() {} // This should collide with baz, but now it does not.\n}\n\npub fn f() {}\nmod alpha {\n    pub use self::f as bar; // Changing this to `pub fn bar() {}` causes the collision right now.\n    pub use super::*;\n}\n```\n\nr? @nrc"
  },
  {
    "hash": "35635aebab321ff2a4708aeb172351356ad63cf7",
    "author": "bors",
    "date": 1454750644,
    "message": "Auto merge of #31333 - lambda:31273-abort-on-stack-overflow, r=brson\n\nAbort on stack overflow instead of re-raising SIGSEGV\n\nWe use guard pages that cause the process to abort to protect against\nundefined behavior in the event of stack overflow.  We have a handler\nthat catches segfaults, prints out an error message if the segfault was\ndue to a stack overflow, then unregisters itself and returns to allow\nthe signal to be re-raised and kill the process.\n\nThis caused some confusion, as it was unexpected that safe code would be\nable to cause a segfault, while it's easy to overflow the stack in safe\ncode.  To avoid this confusion, when we detect a segfault in the guard\npage, abort instead of the previous behavior of re-raising SIGSEGV.\n\nTo test this, we need to adapt the tests for segfault to actually check\nthe exit status.  Doing so revealed that the existing test for segfault\nbehavior was actually invalid; LLVM optimizes the explicit null pointer\nreference down to an illegal instruction, so the program aborts with\nSIGILL instead of SIGSEGV and the test didn't actually trigger the\nsignal handler at all.  Use a C helper function to get a null pointer\nthat LLVM can't optimize away, so we get our segfault instead.\n\nThis is a [breaking-change] if anyone is relying on the exact signal\nraised to kill a process on stack overflow.\n\nCloses #31273"
  },
  {
    "hash": "ee79bfa18affe95959a5f9a036c17bbd77979e21",
    "author": "Brian Campbell",
    "date": 1454722878,
    "message": "Abort on stack overflow instead of re-raising SIGSEGV\n\nWe use guard pages that cause the process to abort to protect against\nundefined behavior in the event of stack overflow.  We have a handler\nthat catches segfaults, prints out an error message if the segfault was\ndue to a stack overflow, then unregisters itself and returns to allow\nthe signal to be re-raised and kill the process.\n\nThis caused some confusion, as it was unexpected that safe code would be\nable to cause a segfault, while it's easy to overflow the stack in safe\ncode.  To avoid this confusion, when we detect a segfault in the guard\npage, abort instead of the previous behavior of re-raising the SIGSEGV.\n\nTo test this, we need to adapt the tests for segfault to actually check\nthe exit status.  Doing so revealed that the existing test for segfault\nbehavior was actually invalid; LLVM optimizes the explicit null pointer\nreference down to an illegal instruction, so the program aborts with\nSIGILL instead of SIGSEGV and the test didn't actually trigger the\nsignal handler at all.  Use a C helper function to get a null pointer\nthat LLVM can't optimize away, so we get our segfault instead.\n\nThis is a [breaking-change] if anyone is relying on the exact signal\nraised to kill a process on stack overflow.\n\nCloses #31273"
  },
  {
    "hash": "654f68dd50b72d1d812b0760f1b71d7c366f6f55",
    "author": "bors",
    "date": 1454302332,
    "message": "Auto merge of #30866 - jseyfried:fix_shadowed_use_visibility, r=nrc\n\nThis reverts PR #30324, fixing bug #30159 in which a public a glob import makes public any preceding imports that share a name with an item in the module being glob imported from.\n\nFor example,\n```rust\npub fn f() {}\npub mod foo {\n    fn f() {}\n}\n\nmod bar {\n    use f;\n    use f as g;\n    pub use foo::*; // This makes the first import public but does not affect the second import.\n}\n```\n\nThis is a [breaking-change]."
  },
  {
    "hash": "43c1a173a874f5513db58b2f5321489a00087484",
    "author": "bors",
    "date": 1453807458,
    "message": "Auto merge of #31105 - jseyfried:fix_lexical_scoping, r=nrc\n\nThis fixes #23880, a scoping bug in which items in a block are shadowed by local variables and type parameters that are in scope.\n\nAfter this PR, an item in a block will shadow any local variables or type parameters above the item in the scope hierarchy. Items in a block will continue to be shadowed by local variables in the same block (even if the item is defined after the local variable).\n\nThis is a [breaking-change]. For example, the following code breaks:\n```rust\nfn foo() {\n    let mut f = 1;\n    {\n        fn f() {}\n        f += 1; // This will resolve to the function instead of the local variable\n    }\n}"
  },
  {
    "hash": "faf0852fc1d01aef18fe8098a0f2f601dbfebd9b",
    "author": "Jeffrey Seyfried",
    "date": 1453781818,
    "message": "Resolve: fix #23880, a scoping bug\n\nThis fixes a bug in which items in a block are shadowed by local variables and type parameters that are in scope.\nIt is a [breaking-change]. For example, the following code breaks:\n\n```rust\nfn foo() {\n    let mut f = 1;\n    {\n        fn f() {}\n        f += 1; // This will now resolve to the function instead of the local variable\n    }\n}\n```\n\nAny breakage can be fixed by renaming the item that is no longer shadowed."
  },
  {
    "hash": "54475e950cf3db909c4dec4a30c72f7636ab4e07",
    "author": "bors",
    "date": 1453416097,
    "message": "Auto merge of #30882 - petrochenkov:varnamesp, r=nrc\n\nTuple and unit variants from other crates weren't put into type namespace.\nNow variant namespacing is aligned with struct namespacing and is not affected by the variant's crate of origin (struct -> type, tuple/unit -> type/value).\nAdditionally, struct variants from other crates are put into value namespace (struct variants from local crate were already in it). This is not a necessity, but a future proofing measure.\n\nThis fix can result in some new shadowing errors in cross-crate scenarios, crater reports [three regressions](https://github.com/rust-lang/rust/pull/30882#issuecomment-172369883).\n[breaking-change]"
  },
  {
    "hash": "06c66d6ca23c73c60aeb0ea2c12baaf0236afe40",
    "author": "Peter Atashian",
    "date": 1452965694,
    "message": "Change name when outputting staticlibs on Windows\nlibfoo.a -> foo.lib\nIn order to not cause conflicts, changes the DLL import library name\nfoo.lib -> foo.dll.lib\n\nFixes https://github.com/rust-lang/rust/issues/29508\n\nBecause this changes output filenames this is a [breaking-change]\n\nSigned-off-by: Peter Atashian <retep998@gmail.com>"
  },
  {
    "hash": "88463364bfb675fdecd2bf9b70c589cc5e7cb2fb",
    "author": "bors",
    "date": 1453013275,
    "message": "Auto merge of #30426 - gereeter:btree-rewrite, r=Gankro\n\nDespite being over 700 lines shorter, this implementation should use less memory than the previous one and is faster on at least insertions and iteration, the latter improving approximately 5x.\n\nTechnically a [breaking-change] due to removal of deprecated functions.\n\ncc @apasel422 @Gankro @goyox86\n\nFixes #27865.\n\n<!-- Reviewable:start -->\n[<img src=\"https://reviewable.io/review_button.png\" height=40 alt=\"Review on Reviewable\"/>](https://reviewable.io/reviews/rust-lang/rust/30426)\n<!-- Reviewable:end -->"
  },
  {
    "hash": "82f8e5ce84c83b02fbfa720c6841f12db1a55603",
    "author": "Nick Cameron",
    "date": 1452822565,
    "message": "Address reviewer comments\n\n[breaking-change]\n\n`OptLevel` variants are no longer `pub use`ed by rust::session::config. If you are using these variants, you must change your code to prefix the variant name with `OptLevel`."
  },
  {
    "hash": "b976d9e6660c16f4a1d5a28b11afa7ccb4f75da6",
    "author": "Nick Cameron",
    "date": 1452806652,
    "message": "Implement JSON error emission\n\n[breaking-change]\n\nsyntax::errors::Handler::new has been renamed to with_tty_emitter\n\nMany functions which used to take a syntax::errors::ColorConfig, now take a rustc::session::config::ErrorOutputType. If you previously used ColorConfig::Auto as a default, you should now use ErrorOutputType::default()."
  },
  {
    "hash": "8796e012cbfa0bf63522e409edc10cbac5afaacd",
    "author": "bors",
    "date": 1452672945,
    "message": "Auto merge of #29498 - wthrowe:replace-pattern, r=alexcrichton\n\nIt appears this was left out of RFC rust-lang/rfcs#528 because it might be useful to\nalso generalize the second argument in some way.  That doesn't seem to\nprevent generalizing the first argument now, however.\n\nThis is a [breaking-change] because it could cause type-inference to\nfail where it previously succeeded.\n\nAlso update docs for a few other methods that still referred to `&str` instead of patterns."
  },
  {
    "hash": "e7f3d6eddd28a917c9a0f7cd73a489048ca7f4cd",
    "author": "William Throwe",
    "date": 1449544113,
    "message": "Let str::replace take a pattern\n\nIt appears this was left out of RFC #528 because it might be useful to\nalso generalize the second argument in some way.  That doesn't seem to\nprevent generalizing the first argument now, however.\n\nThis is a [breaking-change] because it could cause type-inference to\nfail where it previously succeeded."
  },
  {
    "hash": "bac3eec67c367718c05585b72974c58a66f6abd0",
    "author": "Oliver Schneider",
    "date": 1452511906,
    "message": "[breaking-change] remove negate_unsigned feature gate"
  },
  {
    "hash": "69e1f57dfbd32a1a342d696a3e79624da97ebe1b",
    "author": "bors",
    "date": 1452494458,
    "message": "Auto merge of #30295 - jseyfried:fix_extern_crate_duplicate, r=nrc\n\nFix a bug allowing an item and an external crate to collide so long as the external crate is declared after the item. For example,\n```rust\nmod core { pub fn f() {} } // This would be an error if it followed the `extern crate`\nextern crate core; // This declaration is shadowed by the preceding module\n\nfn main() { core::f(); }\n```\nThis is a [breaking-change], but it looks unlikely to cause breakage in practice, and any breakage can be fixed by removing colliding `extern crate` declarations, which are shadowed and hence unused."
  },
  {
    "hash": "91b27ec9beb8455426da3efd26dfc9155058f5bd",
    "author": "bors",
    "date": 1452148376,
    "message": "Auto merge of #30724 - nikomatsakis:feature-gate-defaulted-type-parameters, r=pnkfelix\n\nIt was recently realized that we accept defaulted type parameters everywhere, without feature gate, even though the only place that we really *intended* to accept them were on types. This PR adds a lint warning unless the \"type-parameter-defaults\" feature is enabled. This should eventually become a hard error.\n\nThis is a [breaking-change] in that new feature gates are required (or simply removing the defaults, which is probably a better choice as they have little effect at this time). Results of a [crater run][crater] suggest that approximately 5-15 crates are affected. I didn't do the measurement quite right so that run cannot distinguish \"true\" regressions from \"non-root\" regressions, but even the upper bound of 15 affected crates seems relatively minimal.\n\n[crater]: https://gist.github.com/nikomatsakis/760c6a67698bd24253bf\n\ncc @rust-lang/lang\nr? @pnkfelix"
  },
  {
    "hash": "5daa75373d870f255923aed37d99db73a661bd51",
    "author": "bors",
    "date": 1452112255,
    "message": "Auto merge of #30654 - nrc:panictry, r=brson\n\nThe motivation (other than removing boilerplate) is that this is a baby step towards a parser with error recovery.\n\n[breaking-change] if you use any of the changed functions, you'll need to remove a try! or panictry!"
  },
  {
    "hash": "9023c659af8a43dd5e284d7b311e5f19721c9bd8",
    "author": "Nick Cameron",
    "date": 1451525342,
    "message": "Cut out a bunch of Result and panictry! boilerplate from libsyntax.\n\n[breaking-change] if you use any of the changed functions, you'll need to remove a try! or panictry!"
  },
  {
    "hash": "e8c337b5ca883285e6215f1f669d5556842d1520",
    "author": "bors",
    "date": 1452105477,
    "message": "Auto merge of #30532 - nikomatsakis:cross-item-dependencies, r=mw\n\nThis is roughly the same as my previous PR that created a dependency graph, but that:\n\n1. The dependency graph is only optionally constructed, though this doesn't seem to make much of a difference in terms of overhead (see measurements below).\n2. The dependency graph is simpler (I combined a lot of nodes).\n3. The dependency graph debugging facilities are much better: you can now use `RUST_DEP_GRAPH_FILTER` to filter the dep graph to just the nodes you are interested in, which is super help.\n4. The tests are somewhat more elaborate, including a few known bugs I need to fix in a second pass.\n\nThis is potentially a `[breaking-change]` for plugin authors. If you are poking about in tcx state or something like that, you probably want to add `let _ignore = tcx.dep_graph.in_ignore();`, which will cause your reads/writes to be ignored and not affect the dep-graph.\n\nAfter this, or perhaps as an add-on to this PR in some cases, what I would like to do is the following:\n\n- [x] Write-up a little guide to how to use this system, the debugging options available, and what the possible failure modes are.\n- [ ] Introduce read-only and perhaps the `Meta` node\n- [x] Replace \"memoization tasks\" with node from the map itself\n- [ ] Fix the shortcomings, obviously! Notably, the HIR map needs to register reads, and there is some state that is not yet tracked. (Maybe as a separate PR.)\n- [x] Refactor the dep-graph code so that the actual maintenance of the dep-graph occurs in a parallel thread, and the main thread simply throws things into a shared channel (probably a fixed-size channel). There is no reason for dep-graph construction to be on the main thread. (Maybe as a separate PR.)\n\nRegarding performance: adding this tracking does add some overhead, approximately 2% in my measurements (I was comparing the build times for rustdoc). Interestingly, enabling or disabling tracking doesn't seem to do very much. I want to poke at this some more and gather a bit more data -- in some tests I've seen that 2% go away, but on others it comes back. It's not entirely clear to me if that 2% is truly due to constructing the dep-graph at all.\n\nThe next big step after this is write some code to dump the dep-graph to disk and reload it.\n\nr? @michaelwoerister"
  },
  {
    "hash": "21b025f55fa7f68982f9faf58522da11b3d91815",
    "author": "bors",
    "date": 1452092417,
    "message": "Auto merge of #30733 - ubsan:wrapping_op_assign, r=eddyb\n\nFix a breaking change in #30523\n\nWhile this does fix a breaking change, it is also, technically, a\n[breaking-change] to go back to our original way"
  },
  {
    "hash": "14e1e2aee812978c81d4edf23359e7dca444d678",
    "author": "Nicholas Mazzuca",
    "date": 1452060963,
    "message": "Fix a breaking change in #30523\n\nWhile this does fix a breaking change, it is also, technically, a\n[breaking-change] to go back to our original way"
  },
  {
    "hash": "d5e229057c93222afd4943a49d382c4c5d6e8c26",
    "author": "bors",
    "date": 1451951866,
    "message": "Auto merge of #30681 - Toby-S:master, r=bluss\n\nMake `\".\".parse::<f32>()` and `\".\".parse::<f64>()` return Err\n\nThis fixes #30344.\n\nThis is a [breaking-change], which the libs team have classified as a\nbug fix."
  },
  {
    "hash": "33f3c52d32e6f91494bc305fd25f9d5ae5a11702",
    "author": "Toby Scrace",
    "date": 1451931813,
    "message": "Make float parsing \".\" return Err\n\nThis makes both of the following return Err:\n\n    \".\".parse::<f32>()\n    \".\".parse::<f64>()\n\nThis is a [breaking-change], which the libs team have classified as a\nbug fix."
  },
  {
    "hash": "5e8cb3819bf62527947634ad4d5e44b4b69daecd",
    "author": "bors",
    "date": 1451932641,
    "message": "Auto merge of #30523 - ubsan:wrapping_op_assign, r=eddyb\n\nAdd OpAssign to Wrapping<T>, plus fix some problems in core::num::wrapping\n\nincluding, but not limited to:\n\n* Testing Wrapping<T>\n* Pull out a lot of broken code that doesn't need to be there with the new stage0 compiler\n* Adding Rem and RemAssign to Wrapping<T>\n* Removed 3 (assumed accidental) re-exports, which is a minor [breaking-change].\n* Change shl and shr to take all integer types, instead of a usize; this is a more major [breaking-change], because of values that were inferred before, but brings us in line with the integer shifts.\n\nFixes #30524 and #30523"
  },
  {
    "hash": "ef91cdb140d7dffa4b04f42ab0bc02dc257940e3",
    "author": "bors",
    "date": 1450464892,
    "message": "Auto merge of #29973 - petrochenkov:privinpub, r=nikomatsakis\n\nSome notes:\nThis patch enforces the rules from [RFC 136](https://github.com/rust-lang/rfcs/blob/master/text/0136-no-privates-in-public.md) and makes \"private in public\" a module-level concept and not crate-level. Only `pub` annotations are used by the new algorithm, crate-level exported node set produced by `EmbargoVisitor` is not used. The error messages are tweaked accordingly and don't use the word \"exported\" to avoid confusing people (https://github.com/rust-lang/rust/issues/29668).\n\nThe old algorithm tried to be extra smart with impls, but it mostly led to unpredictable behavior and bugs like https://github.com/rust-lang/rust/issues/28325.\nThe new algorithm tries to be as simple as possible - an impl is considered public iff its type is public and its trait is public (if presents).\nA type or trait is considered public if all its components are public, [complications](https://internals.rust-lang.org/t/limits-of-type-inference-smartness/2919) with private types leaking to other crates/modules through trait impls and type inference are deliberately ignored so far.\n\nThe new algorithm is not recursive and uses the nice new facility `Crate::visit_all_items`!\n\nObsolete pre-1.0 feature `visible_private_types` is removed.\n\nThis is a [breaking-change].\nThe two main vectors of breakage are type aliases (https://github.com/rust-lang/rust/issues/28450) and impls (https://github.com/rust-lang/rust/issues/28325).\nI need some statistics from a crater run (cc @alexcrichton) to decide on the breakage mitigation strategy.\nUPDATE: All the new errors are reported as warnings controlled by a lint `private_in_public` and lint group `future_incompatible`, but the intent is to make them hard errors eventually.\n\nCloses https://github.com/rust-lang/rust/issues/28325\nCloses https://github.com/rust-lang/rust/issues/28450\nCloses https://github.com/rust-lang/rust/issues/29524\nCloses https://github.com/rust-lang/rust/issues/29627\nCloses https://github.com/rust-lang/rust/issues/29668\nCloses https://github.com/rust-lang/rust/issues/30055\n\nr? @nikomatsakis"
  },
  {
    "hash": "ce7bc51933e2facb4eca029ac17b398f372f5b41",
    "author": "bors",
    "date": 1450260576,
    "message": "Auto merge of #30300 - sanxiyn:syntax-ext, r=nikomatsakis\n\nThis reduces iteration time (`make rustc-stage1`) for moved syntax extensions from 11 minutes to 3 minutes on my machine.\n\nBecause of the signature change, this is a [breaking-change] for people directly calling `expand_crate`. I think it is rare: from GitHub search, only case I found is [glassful](https://github.com/kmcallister/glassful)."
  },
  {
    "hash": "ec8ea22c7f59fd898670060bceb6810cef68ca0a",
    "author": "faineance",
    "date": 1450127701,
    "message": "[breaking-change] move ast_util functions to methods"
  },
  {
    "hash": "672a3d93e34ad52529f3bdedfd26d52d67824ccd",
    "author": "bors",
    "date": 1449808073,
    "message": "Auto merge of #30294 - jseyfried:fix_shadowed_use_visibility, r=nrc\n\nThis fixes a bug in which the visibility of a use declaration defining a name in one namespace (e.g. the value namespace) is overridden by a later use declaration defining the same name in the other namespace (e.g. the type namespace). For example,\n```rust\nfn f() {}\npub mod bar {}\n\nmod foo {\n    use f; // This import should not be visible outside `foo`,\n    pub use bar as f; // but it visible outside of `foo` because of this import.\n}\n\nfn main() { foo::f(); }\n```\nAs the example demonstrates, this is a [breaking-change], but it looks unlikely to cause breakage in practice, and any breakage can be fixed by correcting visibility modifiers."
  },
  {
    "hash": "e819d8aa3cd2319fa57e7336e167069ef7002d6a",
    "author": "bors",
    "date": 1449454573,
    "message": "Auto merge of #30247 - bluss:revert-array-clone, r=alexcrichton\n\nRevert \"PR #30130 Implement `Clone` for more arrays\"\n\nThis reverts commit e22a64e8d8d4da46c74f878ce1c23ad1c88982e8.\n\nThis caused a regression such that types like `[[u8; 256]; 4]`\nno longer implemented Clone. This previously worked due to Clone\nfor `[T; N]` (N in 0 to 32) being implemented for T: Copy.\n\nDue to fixed size arrays not implementing Clone for sizes above 32,\nthe new implementation requiring T: Clone would not allow\n`[[u8; 256]; 4]` to be Clone.\n\nFixes #30244\n\nDue to changing back, this is technically a [breaking-change],\nalbeit for a behavior that existed for a very short time."
  }
]
