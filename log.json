[
  {
    "hash": "2b816b0d6a9bc8210ca314a020a247f8632b4f38",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::PathListItem_ variants"
  },
  {
    "hash": "8b3856b1bc1c23969e5d8983f25cf85698a5c2b1",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::StrStyle variants"
  },
  {
    "hash": "d844bfb1967b780ff6cc6e81644bf4b529dc0738",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Visibility variants"
  },
  {
    "hash": "dfe35da6b83f64bb7553b19649839512a3c301ce",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::TraitItemKind variants"
  },
  {
    "hash": "73fa9b2da2ee82c91a5c8d605b91f22f19e4d74b",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Mutablity variants"
  },
  {
    "hash": "14e09ad4686bb20a98acfd7d930386f6330d2b4d",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::MetaItem_"
  },
  {
    "hash": "e797e1961df00ec7725c47225dcf9b5a0e9fce64",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::MacStmtStyle"
  },
  {
    "hash": "798974cae58639c174010fd4a6411dcdc860e404",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::KleeneOp variants"
  },
  {
    "hash": "019614f03d106324ab50a37746b556c41e66c099",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Item_ variants"
  },
  {
    "hash": "0d6ddd190355650a6d851c3aae12cf79339665af",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::ForeignItem_ variants"
  },
  {
    "hash": "8290c950a8b4cdc70038736abcf29f41dede6e0c",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::Stmt_ variants"
  },
  {
    "hash": "498a2e416e693fa22042d3ae81c5c969fc87fe5c",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::IntLitType variants"
  },
  {
    "hash": "69072c4f5d18d7a1762fbfb007b0ba3d6b59ad33",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::Lit_ variants"
  },
  {
    "hash": "05d4cefd630cd9ae104555e69ceb3b1566298a6a",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't pub export ast::Ty_ variants"
  },
  {
    "hash": "ec61e632c0a00ccc2ca0494d5d3c8a0848c574f2",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] remove unused enum ast::PrimTy"
  },
  {
    "hash": "bfa66bb389ce1c7ce4aff09d1842b3428015bd4d",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] remove the sign from integer literals in the ast"
  },
  {
    "hash": "625e78b7001c6e20f29928a5da8c9d21e9aed6c5",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::{UintTy, IntTy} variants"
  },
  {
    "hash": "ccf48bcd4054ecb4e205a18b1ac582ef3ac3a905",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::FloatTy variants"
  },
  {
    "hash": "80bf9ae18a133571d694aa866b824dcaea875d32",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Expr_ variants"
  },
  {
    "hash": "1c4d43715843a5ff5af4657c798b5d5cc85ca523",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::ExplicitSelf_ variants"
  },
  {
    "hash": "79fa657abc6b8885ceb4023099b4e0026c5ef28f",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Decl_ variants"
  },
  {
    "hash": "8516ba367d1f51318ce373fe9b60650c82ded1e9",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::CaptureClause variants"
  },
  {
    "hash": "243a30c9319b56e1be2b9ff2f9ed9e0d7583e2d1",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob import/export syntax::abi enum variants"
  },
  {
    "hash": "47b0784ba8e62a2e1b877750baeae10d16555fff",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::BlockCheckMode variants"
  },
  {
    "hash": "3b57d40fe5a813ac957667ac04938753e3100f55",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob import ast::FunctionRetTy variants"
  },
  {
    "hash": "05e25de4f0add7ae3cd0e8f66cd4558c5bfa42aa",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::BinOp_"
  },
  {
    "hash": "f875f4c4c24e8a14c04bbe4eedd230c4aa3c1431",
    "author": "Oliver Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::UnOp variants"
  },
  {
    "hash": "1de70d33f7baf12978cfb3de861e61b2a5d6fca7",
    "author": "bors",
    "date": 1455164833,
    "message": "Auto merge of #31461 - jseyfried:remove_import_resolutions, r=nrc\n\nThis PR adds to `NameBinding` so it can more fully represent bindings from imports as well from items, refactors away `Target`, generalizes `ImportResolution` to a simpler type `NameResolution`, and uses a single `NameResolution`-valued map in place the existing maps `children` and `import_resolutions` (of `NameBinding`s and `ImportResolution`s, respectively), simplifying duplicate checking and name resolution.\n\nIt also unifies the `resolve_name_in_module` in `lib.rs` with its namesake in `resolve_imports.rs`, clarifying and improving the core logic (fixes #31403 and fixes #31404) while maintaining clear future-comparability with shadowable globs (i.e., never reporting that a resolution is a `Success` or is `Failing` unless this would also be knowable with shadowable globs).\n\nSince it fixes #31403, this is technically a [breaking-change], but it is exceedingly unlikely to cause breakage in practice. The following is an example of code that would break:\n```rust\nmod foo {\n    pub mod bar {} // This defines bar in the type namespace\n    pub use alpha::bar; // This defines bar in the value namespace\n\n    // This should define baz in both namespaces, but it only defines baz in the type namespace.\n    pub use self::bar as baz;\n    pub fn baz() {} // This should collide with baz, but now it does not.\n}\n\npub fn f() {}\nmod alpha {\n    pub use self::f as bar; // Changing this to `pub fn bar() {}` causes the collision right now.\n    pub use super::*;\n}\n```\n\nr? @nrc"
  },
  {
    "hash": "35635aebab321ff2a4708aeb172351356ad63cf7",
    "author": "bors",
    "date": 1454750644,
    "message": "Auto merge of #31333 - lambda:31273-abort-on-stack-overflow, r=brson\n\nAbort on stack overflow instead of re-raising SIGSEGV\n\nWe use guard pages that cause the process to abort to protect against\nundefined behavior in the event of stack overflow.  We have a handler\nthat catches segfaults, prints out an error message if the segfault was\ndue to a stack overflow, then unregisters itself and returns to allow\nthe signal to be re-raised and kill the process.\n\nThis caused some confusion, as it was unexpected that safe code would be\nable to cause a segfault, while it's easy to overflow the stack in safe\ncode.  To avoid this confusion, when we detect a segfault in the guard\npage, abort instead of the previous behavior of re-raising SIGSEGV.\n\nTo test this, we need to adapt the tests for segfault to actually check\nthe exit status.  Doing so revealed that the existing test for segfault\nbehavior was actually invalid; LLVM optimizes the explicit null pointer\nreference down to an illegal instruction, so the program aborts with\nSIGILL instead of SIGSEGV and the test didn't actually trigger the\nsignal handler at all.  Use a C helper function to get a null pointer\nthat LLVM can't optimize away, so we get our segfault instead.\n\nThis is a [breaking-change] if anyone is relying on the exact signal\nraised to kill a process on stack overflow.\n\nCloses #31273"
  },
  {
    "hash": "ee79bfa18affe95959a5f9a036c17bbd77979e21",
    "author": "Brian Campbell",
    "date": 1454722878,
    "message": "Abort on stack overflow instead of re-raising SIGSEGV\n\nWe use guard pages that cause the process to abort to protect against\nundefined behavior in the event of stack overflow.  We have a handler\nthat catches segfaults, prints out an error message if the segfault was\ndue to a stack overflow, then unregisters itself and returns to allow\nthe signal to be re-raised and kill the process.\n\nThis caused some confusion, as it was unexpected that safe code would be\nable to cause a segfault, while it's easy to overflow the stack in safe\ncode.  To avoid this confusion, when we detect a segfault in the guard\npage, abort instead of the previous behavior of re-raising the SIGSEGV.\n\nTo test this, we need to adapt the tests for segfault to actually check\nthe exit status.  Doing so revealed that the existing test for segfault\nbehavior was actually invalid; LLVM optimizes the explicit null pointer\nreference down to an illegal instruction, so the program aborts with\nSIGILL instead of SIGSEGV and the test didn't actually trigger the\nsignal handler at all.  Use a C helper function to get a null pointer\nthat LLVM can't optimize away, so we get our segfault instead.\n\nThis is a [breaking-change] if anyone is relying on the exact signal\nraised to kill a process on stack overflow.\n\nCloses #31273"
  },
  {
    "hash": "654f68dd50b72d1d812b0760f1b71d7c366f6f55",
    "author": "bors",
    "date": 1454302332,
    "message": "Auto merge of #30866 - jseyfried:fix_shadowed_use_visibility, r=nrc\n\nThis reverts PR #30324, fixing bug #30159 in which a public a glob import makes public any preceding imports that share a name with an item in the module being glob imported from.\n\nFor example,\n```rust\npub fn f() {}\npub mod foo {\n    fn f() {}\n}\n\nmod bar {\n    use f;\n    use f as g;\n    pub use foo::*; // This makes the first import public but does not affect the second import.\n}\n```\n\nThis is a [breaking-change]."
  },
  {
    "hash": "43c1a173a874f5513db58b2f5321489a00087484",
    "author": "bors",
    "date": 1453807458,
    "message": "Auto merge of #31105 - jseyfried:fix_lexical_scoping, r=nrc\n\nThis fixes #23880, a scoping bug in which items in a block are shadowed by local variables and type parameters that are in scope.\n\nAfter this PR, an item in a block will shadow any local variables or type parameters above the item in the scope hierarchy. Items in a block will continue to be shadowed by local variables in the same block (even if the item is defined after the local variable).\n\nThis is a [breaking-change]. For example, the following code breaks:\n```rust\nfn foo() {\n    let mut f = 1;\n    {\n        fn f() {}\n        f += 1; // This will resolve to the function instead of the local variable\n    }\n}"
  },
  {
    "hash": "faf0852fc1d01aef18fe8098a0f2f601dbfebd9b",
    "author": "Jeffrey Seyfried",
    "date": 1453781818,
    "message": "Resolve: fix #23880, a scoping bug\n\nThis fixes a bug in which items in a block are shadowed by local variables and type parameters that are in scope.\nIt is a [breaking-change]. For example, the following code breaks:\n\n```rust\nfn foo() {\n    let mut f = 1;\n    {\n        fn f() {}\n        f += 1; // This will now resolve to the function instead of the local variable\n    }\n}\n```\n\nAny breakage can be fixed by renaming the item that is no longer shadowed."
  },
  {
    "hash": "54475e950cf3db909c4dec4a30c72f7636ab4e07",
    "author": "bors",
    "date": 1453416097,
    "message": "Auto merge of #30882 - petrochenkov:varnamesp, r=nrc\n\nTuple and unit variants from other crates weren't put into type namespace.\nNow variant namespacing is aligned with struct namespacing and is not affected by the variant's crate of origin (struct -> type, tuple/unit -> type/value).\nAdditionally, struct variants from other crates are put into value namespace (struct variants from local crate were already in it). This is not a necessity, but a future proofing measure.\n\nThis fix can result in some new shadowing errors in cross-crate scenarios, crater reports [three regressions](https://github.com/rust-lang/rust/pull/30882#issuecomment-172369883).\n[breaking-change]"
  },
  {
    "hash": "06c66d6ca23c73c60aeb0ea2c12baaf0236afe40",
    "author": "Peter Atashian",
    "date": 1452965694,
    "message": "Change name when outputting staticlibs on Windows\nlibfoo.a -> foo.lib\nIn order to not cause conflicts, changes the DLL import library name\nfoo.lib -> foo.dll.lib\n\nFixes https://github.com/rust-lang/rust/issues/29508\n\nBecause this changes output filenames this is a [breaking-change]\n\nSigned-off-by: Peter Atashian <retep998@gmail.com>"
  },
  {
    "hash": "88463364bfb675fdecd2bf9b70c589cc5e7cb2fb",
    "author": "bors",
    "date": 1453013275,
    "message": "Auto merge of #30426 - gereeter:btree-rewrite, r=Gankro\n\nDespite being over 700 lines shorter, this implementation should use less memory than the previous one and is faster on at least insertions and iteration, the latter improving approximately 5x.\n\nTechnically a [breaking-change] due to removal of deprecated functions.\n\ncc @apasel422 @Gankro @goyox86\n\nFixes #27865.\n\n<!-- Reviewable:start -->\n[<img src=\"https://reviewable.io/review_button.png\" height=40 alt=\"Review on Reviewable\"/>](https://reviewable.io/reviews/rust-lang/rust/30426)\n<!-- Reviewable:end -->"
  },
  {
    "hash": "82f8e5ce84c83b02fbfa720c6841f12db1a55603",
    "author": "Nick Cameron",
    "date": 1452822565,
    "message": "Address reviewer comments\n\n[breaking-change]\n\n`OptLevel` variants are no longer `pub use`ed by rust::session::config. If you are using these variants, you must change your code to prefix the variant name with `OptLevel`."
  },
  {
    "hash": "b976d9e6660c16f4a1d5a28b11afa7ccb4f75da6",
    "author": "Nick Cameron",
    "date": 1452806652,
    "message": "Implement JSON error emission\n\n[breaking-change]\n\nsyntax::errors::Handler::new has been renamed to with_tty_emitter\n\nMany functions which used to take a syntax::errors::ColorConfig, now take a rustc::session::config::ErrorOutputType. If you previously used ColorConfig::Auto as a default, you should now use ErrorOutputType::default()."
  },
  {
    "hash": "8796e012cbfa0bf63522e409edc10cbac5afaacd",
    "author": "bors",
    "date": 1452672945,
    "message": "Auto merge of #29498 - wthrowe:replace-pattern, r=alexcrichton\n\nIt appears this was left out of RFC rust-lang/rfcs#528 because it might be useful to\nalso generalize the second argument in some way.  That doesn't seem to\nprevent generalizing the first argument now, however.\n\nThis is a [breaking-change] because it could cause type-inference to\nfail where it previously succeeded.\n\nAlso update docs for a few other methods that still referred to `&str` instead of patterns."
  },
  {
    "hash": "e7f3d6eddd28a917c9a0f7cd73a489048ca7f4cd",
    "author": "William Throwe",
    "date": 1449544113,
    "message": "Let str::replace take a pattern\n\nIt appears this was left out of RFC #528 because it might be useful to\nalso generalize the second argument in some way.  That doesn't seem to\nprevent generalizing the first argument now, however.\n\nThis is a [breaking-change] because it could cause type-inference to\nfail where it previously succeeded."
  },
  {
    "hash": "bac3eec67c367718c05585b72974c58a66f6abd0",
    "author": "Oliver Schneider",
    "date": 1452511906,
    "message": "[breaking-change] remove negate_unsigned feature gate"
  },
  {
    "hash": "69e1f57dfbd32a1a342d696a3e79624da97ebe1b",
    "author": "bors",
    "date": 1452494458,
    "message": "Auto merge of #30295 - jseyfried:fix_extern_crate_duplicate, r=nrc\n\nFix a bug allowing an item and an external crate to collide so long as the external crate is declared after the item. For example,\n```rust\nmod core { pub fn f() {} } // This would be an error if it followed the `extern crate`\nextern crate core; // This declaration is shadowed by the preceding module\n\nfn main() { core::f(); }\n```\nThis is a [breaking-change], but it looks unlikely to cause breakage in practice, and any breakage can be fixed by removing colliding `extern crate` declarations, which are shadowed and hence unused."
  },
  {
    "hash": "91b27ec9beb8455426da3efd26dfc9155058f5bd",
    "author": "bors",
    "date": 1452148376,
    "message": "Auto merge of #30724 - nikomatsakis:feature-gate-defaulted-type-parameters, r=pnkfelix\n\nIt was recently realized that we accept defaulted type parameters everywhere, without feature gate, even though the only place that we really *intended* to accept them were on types. This PR adds a lint warning unless the \"type-parameter-defaults\" feature is enabled. This should eventually become a hard error.\n\nThis is a [breaking-change] in that new feature gates are required (or simply removing the defaults, which is probably a better choice as they have little effect at this time). Results of a [crater run][crater] suggest that approximately 5-15 crates are affected. I didn't do the measurement quite right so that run cannot distinguish \"true\" regressions from \"non-root\" regressions, but even the upper bound of 15 affected crates seems relatively minimal.\n\n[crater]: https://gist.github.com/nikomatsakis/760c6a67698bd24253bf\n\ncc @rust-lang/lang\nr? @pnkfelix"
  },
  {
    "hash": "5daa75373d870f255923aed37d99db73a661bd51",
    "author": "bors",
    "date": 1452112255,
    "message": "Auto merge of #30654 - nrc:panictry, r=brson\n\nThe motivation (other than removing boilerplate) is that this is a baby step towards a parser with error recovery.\n\n[breaking-change] if you use any of the changed functions, you'll need to remove a try! or panictry!"
  },
  {
    "hash": "9023c659af8a43dd5e284d7b311e5f19721c9bd8",
    "author": "Nick Cameron",
    "date": 1451525342,
    "message": "Cut out a bunch of Result and panictry! boilerplate from libsyntax.\n\n[breaking-change] if you use any of the changed functions, you'll need to remove a try! or panictry!"
  },
  {
    "hash": "e8c337b5ca883285e6215f1f669d5556842d1520",
    "author": "bors",
    "date": 1452105477,
    "message": "Auto merge of #30532 - nikomatsakis:cross-item-dependencies, r=mw\n\nThis is roughly the same as my previous PR that created a dependency graph, but that:\n\n1. The dependency graph is only optionally constructed, though this doesn't seem to make much of a difference in terms of overhead (see measurements below).\n2. The dependency graph is simpler (I combined a lot of nodes).\n3. The dependency graph debugging facilities are much better: you can now use `RUST_DEP_GRAPH_FILTER` to filter the dep graph to just the nodes you are interested in, which is super help.\n4. The tests are somewhat more elaborate, including a few known bugs I need to fix in a second pass.\n\nThis is potentially a `[breaking-change]` for plugin authors. If you are poking about in tcx state or something like that, you probably want to add `let _ignore = tcx.dep_graph.in_ignore();`, which will cause your reads/writes to be ignored and not affect the dep-graph.\n\nAfter this, or perhaps as an add-on to this PR in some cases, what I would like to do is the following:\n\n- [x] Write-up a little guide to how to use this system, the debugging options available, and what the possible failure modes are.\n- [ ] Introduce read-only and perhaps the `Meta` node\n- [x] Replace \"memoization tasks\" with node from the map itself\n- [ ] Fix the shortcomings, obviously! Notably, the HIR map needs to register reads, and there is some state that is not yet tracked. (Maybe as a separate PR.)\n- [x] Refactor the dep-graph code so that the actual maintenance of the dep-graph occurs in a parallel thread, and the main thread simply throws things into a shared channel (probably a fixed-size channel). There is no reason for dep-graph construction to be on the main thread. (Maybe as a separate PR.)\n\nRegarding performance: adding this tracking does add some overhead, approximately 2% in my measurements (I was comparing the build times for rustdoc). Interestingly, enabling or disabling tracking doesn't seem to do very much. I want to poke at this some more and gather a bit more data -- in some tests I've seen that 2% go away, but on others it comes back. It's not entirely clear to me if that 2% is truly due to constructing the dep-graph at all.\n\nThe next big step after this is write some code to dump the dep-graph to disk and reload it.\n\nr? @michaelwoerister"
  },
  {
    "hash": "21b025f55fa7f68982f9faf58522da11b3d91815",
    "author": "bors",
    "date": 1452092417,
    "message": "Auto merge of #30733 - ubsan:wrapping_op_assign, r=eddyb\n\nFix a breaking change in #30523\n\nWhile this does fix a breaking change, it is also, technically, a\n[breaking-change] to go back to our original way"
  },
  {
    "hash": "14e1e2aee812978c81d4edf23359e7dca444d678",
    "author": "Nicholas Mazzuca",
    "date": 1452060963,
    "message": "Fix a breaking change in #30523\n\nWhile this does fix a breaking change, it is also, technically, a\n[breaking-change] to go back to our original way"
  },
  {
    "hash": "d5e229057c93222afd4943a49d382c4c5d6e8c26",
    "author": "bors",
    "date": 1451951866,
    "message": "Auto merge of #30681 - Toby-S:master, r=bluss\n\nMake `\".\".parse::<f32>()` and `\".\".parse::<f64>()` return Err\n\nThis fixes #30344.\n\nThis is a [breaking-change], which the libs team have classified as a\nbug fix."
  },
  {
    "hash": "33f3c52d32e6f91494bc305fd25f9d5ae5a11702",
    "author": "Toby Scrace",
    "date": 1451931813,
    "message": "Make float parsing \".\" return Err\n\nThis makes both of the following return Err:\n\n    \".\".parse::<f32>()\n    \".\".parse::<f64>()\n\nThis is a [breaking-change], which the libs team have classified as a\nbug fix."
  },
  {
    "hash": "5e8cb3819bf62527947634ad4d5e44b4b69daecd",
    "author": "bors",
    "date": 1451932641,
    "message": "Auto merge of #30523 - ubsan:wrapping_op_assign, r=eddyb\n\nAdd OpAssign to Wrapping<T>, plus fix some problems in core::num::wrapping\n\nincluding, but not limited to:\n\n* Testing Wrapping<T>\n* Pull out a lot of broken code that doesn't need to be there with the new stage0 compiler\n* Adding Rem and RemAssign to Wrapping<T>\n* Removed 3 (assumed accidental) re-exports, which is a minor [breaking-change].\n* Change shl and shr to take all integer types, instead of a usize; this is a more major [breaking-change], because of values that were inferred before, but brings us in line with the integer shifts.\n\nFixes #30524 and #30523"
  },
  {
    "hash": "ef91cdb140d7dffa4b04f42ab0bc02dc257940e3",
    "author": "bors",
    "date": 1450464892,
    "message": "Auto merge of #29973 - petrochenkov:privinpub, r=nikomatsakis\n\nSome notes:\nThis patch enforces the rules from [RFC 136](https://github.com/rust-lang/rfcs/blob/master/text/0136-no-privates-in-public.md) and makes \"private in public\" a module-level concept and not crate-level. Only `pub` annotations are used by the new algorithm, crate-level exported node set produced by `EmbargoVisitor` is not used. The error messages are tweaked accordingly and don't use the word \"exported\" to avoid confusing people (https://github.com/rust-lang/rust/issues/29668).\n\nThe old algorithm tried to be extra smart with impls, but it mostly led to unpredictable behavior and bugs like https://github.com/rust-lang/rust/issues/28325.\nThe new algorithm tries to be as simple as possible - an impl is considered public iff its type is public and its trait is public (if presents).\nA type or trait is considered public if all its components are public, [complications](https://internals.rust-lang.org/t/limits-of-type-inference-smartness/2919) with private types leaking to other crates/modules through trait impls and type inference are deliberately ignored so far.\n\nThe new algorithm is not recursive and uses the nice new facility `Crate::visit_all_items`!\n\nObsolete pre-1.0 feature `visible_private_types` is removed.\n\nThis is a [breaking-change].\nThe two main vectors of breakage are type aliases (https://github.com/rust-lang/rust/issues/28450) and impls (https://github.com/rust-lang/rust/issues/28325).\nI need some statistics from a crater run (cc @alexcrichton) to decide on the breakage mitigation strategy.\nUPDATE: All the new errors are reported as warnings controlled by a lint `private_in_public` and lint group `future_incompatible`, but the intent is to make them hard errors eventually.\n\nCloses https://github.com/rust-lang/rust/issues/28325\nCloses https://github.com/rust-lang/rust/issues/28450\nCloses https://github.com/rust-lang/rust/issues/29524\nCloses https://github.com/rust-lang/rust/issues/29627\nCloses https://github.com/rust-lang/rust/issues/29668\nCloses https://github.com/rust-lang/rust/issues/30055\n\nr? @nikomatsakis"
  },
  {
    "hash": "ce7bc51933e2facb4eca029ac17b398f372f5b41",
    "author": "bors",
    "date": 1450260576,
    "message": "Auto merge of #30300 - sanxiyn:syntax-ext, r=nikomatsakis\n\nThis reduces iteration time (`make rustc-stage1`) for moved syntax extensions from 11 minutes to 3 minutes on my machine.\n\nBecause of the signature change, this is a [breaking-change] for people directly calling `expand_crate`. I think it is rare: from GitHub search, only case I found is [glassful](https://github.com/kmcallister/glassful)."
  },
  {
    "hash": "ec8ea22c7f59fd898670060bceb6810cef68ca0a",
    "author": "faineance",
    "date": 1450127701,
    "message": "[breaking-change] move ast_util functions to methods"
  },
  {
    "hash": "672a3d93e34ad52529f3bdedfd26d52d67824ccd",
    "author": "bors",
    "date": 1449808073,
    "message": "Auto merge of #30294 - jseyfried:fix_shadowed_use_visibility, r=nrc\n\nThis fixes a bug in which the visibility of a use declaration defining a name in one namespace (e.g. the value namespace) is overridden by a later use declaration defining the same name in the other namespace (e.g. the type namespace). For example,\n```rust\nfn f() {}\npub mod bar {}\n\nmod foo {\n    use f; // This import should not be visible outside `foo`,\n    pub use bar as f; // but it visible outside of `foo` because of this import.\n}\n\nfn main() { foo::f(); }\n```\nAs the example demonstrates, this is a [breaking-change], but it looks unlikely to cause breakage in practice, and any breakage can be fixed by correcting visibility modifiers."
  },
  {
    "hash": "e819d8aa3cd2319fa57e7336e167069ef7002d6a",
    "author": "bors",
    "date": 1449454573,
    "message": "Auto merge of #30247 - bluss:revert-array-clone, r=alexcrichton\n\nRevert \"PR #30130 Implement `Clone` for more arrays\"\n\nThis reverts commit e22a64e8d8d4da46c74f878ce1c23ad1c88982e8.\n\nThis caused a regression such that types like `[[u8; 256]; 4]`\nno longer implemented Clone. This previously worked due to Clone\nfor `[T; N]` (N in 0 to 32) being implemented for T: Copy.\n\nDue to fixed size arrays not implementing Clone for sizes above 32,\nthe new implementation requiring T: Clone would not allow\n`[[u8; 256]; 4]` to be Clone.\n\nFixes #30244\n\nDue to changing back, this is technically a [breaking-change],\nalbeit for a behavior that existed for a very short time."
  },
  {
    "hash": "e22a64e8d8d4da46c74f878ce1c23ad1c88982e8",
    "author": "bors",
    "date": 1449269522,
    "message": "Auto merge of #30130 - tbu-:pr_array_clone, r=alexcrichton\n\n[breaking-change]"
  },
  {
    "hash": "e9ac44026d2d4ac11728263726505ea4cea3c1ff",
    "author": "bors",
    "date": 1448671534,
    "message": "Auto merge of #29383 - petrochenkov:empstr, r=pnkfelix\n\nFixes https://github.com/rust-lang/rust/issues/28692\nFixes https://github.com/rust-lang/rust/issues/28992\nFixes some other similar issues (see the tests)\n\n[breaking-change], needs crater run (cc @brson or @alexcrichton )\n\nThe pattern with parens `UnitVariant(..)` for unit variants seems to be popular in rustc (see the second commit), but mostly used by one person (@nikomatsakis), according to git blame. If it causes breakage on crates.io I'll add an exceptional case for it."
  },
  {
    "hash": "6ef02eff89e3d2a29eab3346bff393821df6e033",
    "author": "bors",
    "date": 1448562058,
    "message": "Auto merge of #30043 - arielb1:split-metadata, r=nikomatsakis\n\nThis improves bootstrap times because of better parallelism - though I need to measure how much - and allows metadata to be modified without triggering a full recompile. This also ensures that metadata handling and the rest of rustc remain decoupled, which is a first step for switching to a new metadata format.\n\nThis is a [breaking-change] to all plugin authors because of the following renames:\n * `rustc::plugin` is now `rustc_plugin`\n * `rustc::metadata` is now `rustc_metadata`\n * Most data types from `rustc::metadata`, along with `LOCAL_CRATE`, are now in `rustc::middle::cstore`.\n * The CStore methods were split between the `rustc::middle::CrateStore` trait (and trait object) and the `rustc_metadata::cstore::CStore`, with an `Rc<CrateStore>` stored in the `Session`. The inner `CStore` can be accessed via the inner `Any` bound, but this is deprecated.\n\nr? @nikomatsakis"
  },
  {
    "hash": "1430a3500076ad504a0b30be77fd2ad4468ea769",
    "author": "Ariel Ben-Yehuda",
    "date": 1448554959,
    "message": "move librustc/plugin to librustc_plugin\n\nthis is a [breaking-change] to all plugin authors - sorry"
  },
  {
    "hash": "3c0d55cc76c524c12160bfb45663d9aca73e6556",
    "author": "Ariel Ben-Yehuda",
    "date": 1447959239,
    "message": "constrained_type_params: make projections depend on their trait-ref\n\nAs this is a soundness fix, it is a [breaking-change].\n\nFixes #29861."
  },
  {
    "hash": "767ee79c4c38e7909c7fefef1b33be4612112336",
    "author": "Niko Matsakis",
    "date": 1447892538,
    "message": "Refactor the HIR so that items are stored in a map in the `Crate`,\nrather being stored inline. Refactor (and rename) the visitor so that\n(by default) it only visits the interior content of an item not nested\nitems.\n\nThis is a [breaking-change] for anyone who uses the HIR visitor. Besides\nchanging `visit::` to `intravisit::`, you need to refactor your visitor\nin one of two ways, depending on what it requires:\n\n1. If you just want to visit all items (most common), you should call\n   `krate.visit_all_items(&mut visitor)`.\n\n2. If you need to visit nested items in the middle of the parent items,\n   you should override `visit_nested_item` with something like:\n   `self.visit_item(self.tcx.map.expect_item(item.id))`, presuming you\n   have access to a tcx (or at least a HIR map)."
  },
  {
    "hash": "ad3bd1b46d52ccb339a09558064b9bf687c47a75",
    "author": "bors",
    "date": 1447201508,
    "message": "Auto merge of #29726 - petrochenkov:privsan, r=alexcrichton\n\n- Check privacy sanity in all blocks, not only function bodies\n- Check all fields, not only named\n- Check all impl items, not only methods\n- Check default impls\n- Move the sanity check in the beginning of privacy checking, so others could rely on it\n\nTechnically it's a [breaking-change], but I expect no breakage because, well, it's *sane* privacy visitor, if code is broken it must be insane by definition!"
  },
  {
    "hash": "749625ad6d15d0254b90e3d16f79d1cb1e260969",
    "author": "bors",
    "date": 1446513790,
    "message": "Auto merge of #29500 - vadimcn:rustlib, r=alexcrichton\n\nAccording to a recent [discussion on IRC](https://botbot.me/mozilla/rust-tools/2015-10-27/?msg=52887517&page=2), there's no good reason for Windows builds to store target libraries under `bin`, when on every other platform they are under `lib`.\r\n\r\nThis might be a [breaking-change] for some users.  I am pretty sure VisualRust has that path hard-coded somewhere.\r\n\r\nr? @brson"
  },
  {
    "hash": "6d43fef3aaf64b2e7df14ca676a3a39b723ed7f3",
    "author": "bors",
    "date": 1446385009,
    "message": "Auto merge of #29486 - petrochenkov:multiwild, r=Manishearth\n\nMotivation:\r\n- It is not actually a pattern\r\n- It is not actually needed, except for...\r\n\r\nDrawback:\r\n- Slice patterns like `[a, _.., b]` are pretty-printed as `[a, .., b]`. Great loss :(\r\n\r\nplugin-[breaking-change], as always"
  },
  {
    "hash": "c44316d4a1ad0fe01ae366e163993aa3980c755f",
    "author": "bors",
    "date": 1445848079,
    "message": "Auto merge of #29303 - petrochenkov:unistrimp, r=eddyb\n\nAnd use `VariantData` instead of `P<VariantData>` in `Item_` and `Variant_`\r\n\r\nImprovements suggested by @eddyb in https://github.com/rust-lang/rust/pull/28816#discussion_r42483587 and https://github.com/rust-lang/rust/pull/28816#discussion_r42483648\r\n\r\nplugin-[breaking-change]\r\n\r\nr? @eddyb"
  },
  {
    "hash": "04e497c0056aed899cd6edbc98e7a68a9b391c5c",
    "author": "bors",
    "date": 1445689272,
    "message": "Auto merge of #29259 - arielb1:supertrait-self-2, r=eddyb\n\nâ€¦being it\r\n\r\nThis is a [breaking-change]:lang, but the broken code does not make\r\nmuch sense.\r\n\r\nFixes #26056\r\n\r\nr? @eddyb"
  },
  {
    "hash": "5d6d26c241b785daef873a0c6b9a0553c3a9451d",
    "author": "Ariel Ben-Yehuda",
    "date": 1445635349,
    "message": "object_safety: check whether a supertrait contains Self even without being it\n\nThis is a [breaking-change]:lang, but the broken code does not make\nmuch sense.\n\nFixes #26056"
  },
  {
    "hash": "97ba52ec379e17cc0984224b756282b68bc3a53b",
    "author": "bors",
    "date": 1445367747,
    "message": "Auto merge of #29148 - petrochenkov:noshow, r=alexcrichton\n\nCloses https://github.com/rust-lang/rust/issues/29145\r\n\r\n[breaking-change], needs a crater run."
  },
  {
    "hash": "d6bd8d8491e89277edbfc9a4e0f8953847abbdd6",
    "author": "Andrew Paseltiner",
    "date": 1445034931,
    "message": "Add `Shared` pointer and have `{Arc, Rc}` use it\n\nThis change has two consequences:\n\n1. It makes `Arc<T>` and `Rc<T>` covariant in `T`.\n\n2. It causes the compiler to reject code that was unsound with respect\nto dropck. See compile-fail/issue-29106.rs for an example of code that\nno longer compiles. Because of this, this is a [breaking-change].\n\nFixes #29037.\nFixes #29106."
  },
  {
    "hash": "130851e03046db41d555a401a08c87f187fd911a",
    "author": "bors",
    "date": 1443910057,
    "message": "Auto merge of #28669 - arielb1:well-formed-methods, r=nikomatsakis\n\nBy RFC1214:\r\n>    Before calling a fn, we check that its argument and return types are WF.\r\n    \r\nThe previous code only checked the trait-ref, which was not enough\r\nin several cases.\r\n    \r\nAs this is a soundness fix, it is a [breaking-change]. Some new annotations are needed, which I think are because of #18653 and the imperfection of `projection_must_outlive` (that can probably be worked around by moving the wf obligation later).\r\n    \r\nFixes #28609\r\n\r\nr? @nikomatsakis"
  },
  {
    "hash": "603a75c8eaa8ee168e4333e4fba5eb782ed7192b",
    "author": "Ariel Ben-Yehuda",
    "date": 1443818410,
    "message": "ensure that the types of methods are well-formed\n\nBy RFC1214:\nBefore calling a fn, we check that its argument and return types are WF. This check takes place after all higher-ranked lifetimes have been instantiated. Checking the argument types ensures that the implied bounds due to argument types are correct. Checking the return type ensures that the resulting type of the call is WF.\n\nThe previous code only checked the trait-ref, which was not enough\nin several cases.\n\nAs this is a soundness fix, it is a [breaking-change].\n\nFixes #28609"
  },
  {
    "hash": "ef07d7dd40e33d7af95c7b00717503730ce69c11",
    "author": "bors",
    "date": 1443813399,
    "message": "Auto merge of #28650 - sanxiyn:attr-usage, r=nrc\n\nThis is technically a [breaking-change].\r\n\r\nFix #2809.\r\nFix #22746."
  },
  {
    "hash": "e82faeb65594302897223b2ca4ee6927fb54625f",
    "author": "bors",
    "date": 1443716788,
    "message": "Auto merge of #28742 - nikomatsakis:def-id-encapsulate, r=eddyb\n\nAs described in https://github.com/rust-lang/rfcs/pull/1298, the idea here is to make DefIds independent of changes to the content of other items. They are also *mostly* independent from ordering, so e.g. reordering two functions will change the defids, but it will not change the paths that they expand into (but this is not the case for some things, such as impls).\r\n\r\nThis is a major refactoring, so I did it in slices. The final commit is in some sense The Big One where most of the work is done. The earlier commits just pave the way by gradually refactoring accesses to the `node` field.\r\n\r\nThis is a [breaking-change] for plugin authors. The things you need to do to migrate your code are as follows:\r\n\r\n1. For local def-ids, rather than do `def_id.node`, call `tcx.map.as_local_node_id(def_id)`.\r\n2. To construct a local def-id, call `tcx.map.local_def_id(node_id)`.\r\n3. Note that you cannot make def-ids for any node, but only for \"definitions\" -- which include all items, as well as a number of other things, but not e.g. arbitrary expressions.\r\n4. You can get the path to a def-id by calling `tcx.def_path(def_id)`.\r\n\r\nOne thing that is NOT part of this PR, but which I plan do in a follow-up, is converting uses of the existing `with_path` API to use `def_path`, which is basically the same.\r\n\r\nr? @eddyb (or @nrc)"
  },
  {
    "hash": "587be42d0bd318d6c2f41fe4716e040366dc8951",
    "author": "bors",
    "date": 1443673744,
    "message": "Auto merge of #28605 - alexcrichton:link-native-first, r=brson\n\nThis commit swaps the order of linking local native libraries and upstream\r\nnative libraries on the linker command line. Detail of bugs this can cause can\r\nbe found in #28595, and this change also invalidates the test case that was\r\nadded for #12446 which is now considered a bug because the downstream dependency\r\nwould need to declare that it depends on the native library somehow.\r\n\r\nCloses #28595\r\n[breaking-change]"
  },
  {
    "hash": "5ca60d94316bd56f412ef4c13292237e206babf1",
    "author": "bors",
    "date": 1443127376,
    "message": "Auto merge of #28608 - eddyb:no-place-for-an-old-box, r=pnkfelix\n\nWhile this is technically a [breaking-change], there is no excuse for touching `HEAP`.\r\nr? @pnkfelix"
  },
  {
    "hash": "6a2187414a8c25f485dc788088b4466f595a7dd9",
    "author": "bors",
    "date": 1443120900,
    "message": "Auto merge of #28538 - alevy:make_fixedsizearray_unsafe, r=alexcrichton\n\n[breaking-change]\r\n\r\n`FixedSizeArray` is meant to be implemented for arrays of fixed size only, but can be implemented for anything at the moment. Marking the trait unsafe would make it more reasonable to write unsafe code which operates on fixed size arrays of any size.\r\n\r\nFor example, using `uninitialized` to create a fixed size array and immediately filling it with a fixed value is externally safe:\r\n\r\n```\r\npub fn init_with_nones<T, A: FixedSizeArray<Option<T>>>() -> A {\r\n    let mut res = unsafe { mem::uninitialized() };\r\n    for elm in res.as_mut_slice().iter_mut() {\r\n        *elm = None;\r\n    }\r\n    res\r\n}\r\n```\r\n\r\nBut the same code is not safe if `FixedSizeArray` is implemented for other types:\r\n\r\n```\r\nstruct Foo { foo: usize }\r\nimpl FixedSizeArray<Option<usize>> for Foo {\r\n    fn as_slice(&self) -> &[usize] { &[] }\r\n    fn as_mut_slice(&self) -> &mut [usize] { &mut [] }\r\n}\r\n```\r\n\r\nnow `init_with_nones() : Foo` returns a `Foo` with an undefined value for the field `foo`."
  },
  {
    "hash": "920f32becd5d54864a966900963a376d74d09922",
    "author": "Sebastian Wicki",
    "date": 1442874820,
    "message": "Add `no_default_libraries` target linker option\n\nIf set to false, `-nodefaultlibs` is not passed to the linker. This\nwas the default behavior on Windows, but it should be configurable\nper target.\n\nThis is a [breaking-change] for target specifications that have\nthe `is_like_windows` option set to true. Such targets need to\nset `no_default_libraries` to false in order to restore the old\nbehavior."
  },
  {
    "hash": "a642d853aa29f8ec8486e736be551cf77f34e219",
    "author": "Nick Cameron",
    "date": 1442449006,
    "message": "Change to a multi-trait approach\n\n[breaking-change] for lint authors\n\nYou must now implement LateLintPass or EarlyLintPass as well as LintPass and use either register_late_lint_pass or register_early_lint_pass, rather than register_lint_pass."
  },
  {
    "hash": "76856e19ff3c7c699931d0acee8e61bc0dfec512",
    "author": "Nick Cameron",
    "date": 1442449006,
    "message": "Add an early lint pass for lints that operate on the AST\n\nThere is a minor [breaking-change] for lint authors - some functions which were previously defined on `lint::Context` have moved to a trait - `LintContext`, you may need to import that trait to avoid name resolution errors."
  },
  {
    "hash": "fc4d566b432d48933e27dd65a973c936b564d6e9",
    "author": "bors",
    "date": 1442363724,
    "message": "Auto merge of #28399 - nrc:attrs, r=nikomatsakis\n\nThis could be a [breaking-change] if your lint or syntax extension (is that even possible?) uses HIR attributes or literals."
  },
  {
    "hash": "e9f1b063295c48c97e239ce479b08f192a3eece4",
    "author": "Nick Cameron",
    "date": 1442357826,
    "message": "Use ast attributes every where (remove HIR attributes).\n\nThis could be a [breaking-change] if your lint or syntax extension (is that even possible?) uses HIR attributes or literals."
  },
  {
    "hash": "4d6dc7f9ba9fe61e38d737b29bfe490e835f6921",
    "author": "bors",
    "date": 1442213478,
    "message": "Auto merge of #28396 - arielb1:misplaced-binding, r=eddyb\n\nTechnically a [breaking-change], but the broken code is useless,\r\nlike `i32<Param=()>`.\r\n\r\nFixes #24682\r\n\r\nr? @eddyb"
  },
  {
    "hash": "5d4455510afe3b7f74e04d3125ef8536a63d9e60",
    "author": "Ariel Ben-Yehuda",
    "date": 1442177261,
    "message": "ensure projections are prohibited when type parameters are\n\nTechnically a [breaking-change], but the broken code is useless,\nlike `i32<Param=()>`.\n\nFixes #24682"
  },
  {
    "hash": "ae75ef9e62b7df8c46865cfb907c56cab1f29f81",
    "author": "bors",
    "date": 1441098772,
    "message": "Auto merge of #28137 - nrc:remove-non-multi, r=huonw\n\nThis is a [breaking-change] for syntax extension authors. The fix is to use MultiModifier or MultiDecorator, which have the same functionality but are more flexible. Users of syntax extensions are unaffected."
  },
  {
    "hash": "20e1ea2dd84d5b29414059a4e07ce7327d1bef19",
    "author": "Nick Cameron",
    "date": 1441070163,
    "message": "Remove the Modifier and Decorator kinds of syntax extensions.\n\nThis is a [breaking-change] for syntax extension authors. The fix is to use MultiModifier or MultiDecorator, which have the same functionality but are more flexible. Users of syntax extensions are unaffected."
  },
  {
    "hash": "1f81ef4d0f2547cacc316b01ad03603ad772e38e",
    "author": "Tobias Bucher",
    "date": 1440923045,
    "message": "Atomically set CLOEXEC on duplicated sockets\n\nFor Bitrig, NetBSD and OpenBSD the constant was incorrectly in posix01, when\nit's actually posix08, so we move it. This is a [breaking-change], but we\nalready had one in #27930.\n\nFix NetBSD's F_DUPFD_CLOEXEC constant.\n\nFor a similar feature detection, see this musl thread:\nhttp://comments.gmane.org/gmane.linux.lib.musl.general/2963\n\nThis assumes that an int literal has type `c_int` for varidic functions."
  },
  {
    "hash": "db67cbe43dfce043c664c53d709b91252d5afc9e",
    "author": "bors",
    "date": 1440410628,
    "message": "Auto merge of #27856 - nikomatsakis:move-def-id-to-rustc, r=eddyb\n\nIt doesn't really make sense for DefId to be in libsyntax -- it is concerned with a single crate only. It is the compiler that understands the idea of many crates. (At some point, there might be a useful intermediate point here.) This is a refactoring in support of incr. compilation, which will be adjusting the notion of a DefId to make it more durable across compilations.\r\n\r\nThis will probably be a [breaking-change] for every plugin ever. You need to adjust things as follows:\r\n\r\n    use rustc::middle::def_id::{DefId, LOCAL_CRATE}; // two most common definitions\r\n    ast_util::is_local(def_id) => def_id.is_local()\r\n    ast_util::local_def(node_id) => DefId::local(node_id)"
  },
  {
    "hash": "983d2b3d1a97846c90ea8f689774be8353b340be",
    "author": "bors",
    "date": 1440225053,
    "message": "Auto merge of #27826 - sfackler:wait-timeout-enum, r=alexcrichton\n\nReturning a primitive bool results in a somewhat confusing API - does\r\n`true` indicate success - i.e. no timeout, or that a timeout has\r\noccurred? An explicitly named enum makes it clearer.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton"
  },
  {
    "hash": "42a386fcf89a40e6c3a8806ccf381514c2a77c10",
    "author": "Steven Fackler",
    "date": 1440028815,
    "message": "Make Condvar::wait_timeout return an enum instead of a bool\n\nReturning a primitive bool results in a somewhat confusing API - does\n`true` indicate success - i.e. no timeout, or that a timeout has\noccurred? An explicitly named enum makes it clearer.\n\n[breaking-change]"
  },
  {
    "hash": "c66554cab3518a9f5c36eafd622ca4c8a3fda631",
    "author": "Huon Wilson",
    "date": 1439847697,
    "message": "switch core::simd to repr(simd) and deprecate it.\n\nThis functionality will be available out of tree in the `simd` crate on\ncrates.io.\n\n[breaking-change]"
  },
  {
    "hash": "bb954cfa75ec63b2cf28229ecc4aee7024381d0b",
    "author": "bors",
    "date": 1439472578,
    "message": "Auto merge of #27307 - rkruppe:dec2flt, r=pnkfelix\n\nCompletely rewrite the conversion of decimal strings to `f64` and `f32`. The code is intended to be absolutely positively completely 100% accurate (when it doesn't give up). To the best of my knowledge, it achieves that goal. Any input that is not rejected is converted to the floating point number that is closest to the true value of the input. This includes overflow, subnormal numbers, and underflow to zero. In other words, the rounding error is less than or equal to 0.5 units in the last place. Half-way cases (exactly 0.5 ULP error) are handled with half-to-even rounding, also known as banker's rounding.\r\n\r\nThis code implements the algorithms from the paper [How to Read Floating Point Numbers Accurately][paper] by William D. Clinger, with extensions to handle underflow, overflow and subnormals, as well as some algorithmic optimizations.\r\n\r\n# Correctness\r\n\r\nWith such a large amount of tricky code, many bugs are to be expected. Indeed tracking down the obscure causes of various rounding errors accounts for the bulk of the development time. Extensive tests (taking in the order of hours to run through to completion) are included in `src/etc/test-float-parse`: Though exhaustively testing all possible inputs is impossible, I've had good success with generating millions of instances from various \"classes\" of inputs. These tests take far too long to be run by @bors so contributors who touch this code need the discipline to run them. There are `#[test]`s, but they don't even cover every stupid mistake I made in course of writing this.\r\n\r\nAnother aspect is *integer* overflow. Extreme (or malicious) inputs could cause overflow both in the machine-sized integers used for bookkeeping throughout the algorithms (e.g., the decimal exponent) as well as the arbitrary-precision arithmetic. There is input validation to reject all such cases I know of, and I am quite sure nobody will *accidentally* cause this code to go out of range. Still, no guarantees.\r\n\r\n# Limitations\r\n\r\nNoticed the weasel words \"(when it doesn't give up)\" at the beginning? Some otherwise well-formed decimal strings are rejected because spelling out the value of the input requires too many digits, i.e., `digits * 10^abs(exp)` can't be stored in a bignum. This only applies if the value is not \"obviously\" zero or infinite, i.e., if you take a near-infinity or near-zero value and add many pointless fractional digits. At least with the algorithm used here, computing the precise value would require computing the full value as a fraction, which would overflow. The precise limit is `number_of_digits + abs(exp) > 375` but could be raised almost arbitrarily. In the future, another algorithm might lift this restriction entirely.\r\n\r\nThis should not be an issue for any realistic inputs. Still, the code does reject inputs that would result in a finite float when evaluated with unlimited precision. Some of these inputs are even regressions that the old code (mostly) handled, such as `0.333...333` with 400+ `3`s. Thus this might qualify as [breaking-change].\r\n\r\n# Performance\r\n\r\nBenchmarks results are... tolerable. Short numbers that hit the fast paths (`f64` multiplication or shortcuts to zero/inf) have performance in the same order of magnitude as the old code tens of nanoseconds. Numbers that are delegated to Algorithm Bellerophon (using floats with 64 bit significand, implemented in software) are slower, but not drastically so (couple hundred nanoseconds).\r\n\r\nNumbers that need the AlgorithmM fallback (for `f64`, roughly everything below 1e-305 and above 1e305) take far, far longer, hundreds of microseconds. Note that my implementation is not quite as naive as the expository version in the paper (it needs one to four division instead of ~1000), but division is fundamentally pretty expensive and my implementation of it is extremely simple and slow.\r\n\r\nAll benchmarks run on a mediocre laptop with a i5-4200U CPU under light load.\r\n\r\n# Binary size\r\n\r\nUnfortunately the implementation needs to duplicate almost all code: Once for `f32` and once for `f64`. Before you ask, no, this cannot be avoided, at least not completely (but see the Future Work section). There's also a precomputed table of powers of ten, weighing in at about six kilobytes.\r\n\r\nRunning a stage1 `rustc` over a stand-alone program that simply parses pi to `f32` and `f64` and outputs both results reveals that the overhead vs. the old parsing code is about 44 KiB normally and about 28 KiB with LTO. It's presumably half of that + 3 KiB when only one of the two code paths is exercised.\r\n\r\n| rustc options                 | old       | new       | delta         |\r\n|---------------------------    |---------  |---------  |-----------    |\r\n| [nothing]                     | 2588375   | 2633828   | 44.39 KiB     |\r\n| -O                            | 2585211   | 2630688   | 44.41 KiB     |\r\n| -O -C lto                     | 1026353   | 1054981   | 27.96 KiB     |\r\n| -O -C lto -C link-args=-s     | 414208    | 442368    | 27.5 KiB      |\r\n\r\n# Future Work\r\n\r\n## Directory layout\r\n\r\nThe `dec2flt` code uses some types embedded deeply in the `flt2dec` module hierarchy, even though nothing about them it formatting-specific. They should be moved to a more conversion-direction-agnostic location at some point.\r\n\r\n## Performance\r\n\r\nIt could be much better, especially for large inputs. Some low-hanging fruit has been picked but much more work could be done. Some specific ideas are jotted down in `FIXME`s all over the code.\r\n\r\n## Binary size\r\n\r\nOne could try to compress the table further, though I am skeptical. Another avenue would be reducing the code duplication from basically everything being generic over `T: RawFloat`. Perhaps one can reduce the magnitude of the duplication by pushing the parts that don't need to know the target type into separate functions, but this is finicky and probably makes some code read less naturally.\r\n\r\n## Other bases\r\n\r\nThis PR leaves `f{32,64}::from_str_radix` alone. It only replaces `FromStr` (and thus `.parse()`). I am convinced that `from_str_radix` should not exist, and have proposed its [deprecation and speedy removal][deprecate-radix]. Whatever the outcome of that discussion, it is independent from, and out of scope for, this PR.\r\n\r\nFixes #24557\r\nFixes #14353\r\n\r\nr? @pnkfelix\r\n\r\ncc @lifthrasiir @huonw \r\n\r\n[paper]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152\r\n[deprecate-radix]: https://internals.rust-lang.org/t/deprecate-f-32-64-from-str-radix/2405"
  },
  {
    "hash": "ba792a4baa856d83c3001afa181db91c5b4c9732",
    "author": "Robin Kruppe",
    "date": 1439046931,
    "message": "Accurate decimal-to-float parsing routines.\n\nThis commit primarily adds implementations of the algorithms from William\nClinger's paper \"How to Read Floating Point Numbers Accurately\". It also\nincludes a lot of infrastructure necessary for those algorithms, and some\nunit tests.\n\nSince these algorithms reject a few (extreme) inputs that were previously\naccepted, this could be seen as a [breaking-change]"
  },
  {
    "hash": "50141d7e1e5b1b539d45240dff709fa68e7472c2",
    "author": "bors",
    "date": 1439264836,
    "message": "Auto merge of #26818 - sfackler:duration-stabilization, r=aturon\n\nThis commit stabilizes the `std::time` module and the `Duration` type.\r\n`Duration::span` remains unstable, and the `Display` implementation for\r\n`Duration` has been removed as it is still being reworked and all trait\r\nimplementations for stable types are de facto stable.\r\n\r\nThis is a [breaking-change] to those using `Duration`'s `Display`\r\nimplementation.\r\n\r\nI'm opening this PR as a platform for discussion - there may be some method renaming to do as part of the stabilization process."
  },
  {
    "hash": "999bdeca88a06938ac1e1c608091d3afe4d7e173",
    "author": "Steven Fackler",
    "date": 1439251458,
    "message": "Stabilize the Duration API\n\nThis commit stabilizes the `std::time` module and the `Duration` type.\n`Duration::span` remains unstable, and the `Display` implementation for\n`Duration` has been removed as it is still being reworked and all trait\nimplementations for stable types are de facto stable.\n\nThis is a [breaking-change] to those using `Duration`'s `Display`\nimplementation."
  },
  {
    "hash": "87055a68c3194db212456f99ece080728a5fc2f8",
    "author": "bors",
    "date": 1438251923,
    "message": "Auto merge of #27371 - Gankro:str-clone, r=alexcrichton\n\nThis is a minor [breaking-change], as it changes what\r\n`boxed_str.to_owned()` does (previously it would deref to `&str` and\r\ncall `to_owned` on that to get a `String`). However `Box<str>` is such an\r\nexceptionally rare type that this is not expected to be a serious\r\nconcern. Also a `Box<str>` can be freely converted to a `String` to\r\nobtain the previous result anyway."
  },
  {
    "hash": "3e954a8cb2fd094d79713059d83d37b2daa7b396",
    "author": "Alexis Beingessner",
    "date": 1438220581,
    "message": "implement Clone for Box<str>, closes #27323\n\nThis is a minor [breaking-change], as it changes what\n`boxed_str.to_owned()` does (previously it would deref to `&str` and\ncall `to_owned` on that to get a `String`). However `Box<str>` is such an\nexceptionally rare type that this is not expected to be a serious\nconcern. Also a `Box<str>` can be freely converted to a `String` to\nobtain the previous behaviour anyway."
  },
  {
    "hash": "757b0c176fa185fda59283efaf0d8079b702ca69",
    "author": "Ariel Ben-Yehuda",
    "date": 1438102268,
    "message": "prohibit the lhs of an @-pattern being a constant\n\nas this breaks code that worked under some conditions, this is a\n[breaking-change]\n\nFixes #27033\nFixes #27077"
  },
  {
    "hash": "d576ef3d7be3efe28f902bbb3b2197f4553db412",
    "author": "bors",
    "date": 1438152475,
    "message": "Auto merge of #27261 - arielb1:drop-sanity-check, r=pnkfelix\n\nThis fixes multiple bugs, and as several of these are soundness issue, is a [breaking-change].\r\n\r\nr? @pnkfelix"
  },
  {
    "hash": "bfbc7bc45d66ba7be8ab2ba60316cb1e303f4544",
    "author": "Ariel Ben-Yehuda",
    "date": 1437770777,
    "message": "handle all type variants correctly in dropck\n\nThis fixes a few soundness bugs in dropck, so to anyone who relied on them,\nthis is a\n[breaking-change]\n\nFixes #24086.\nFixes #25389.\nFixes #25598.\nFixes #25750.\nFixes #26641.\nFixes #26657.\nFixes #27240.\nFixes #27241."
  }
]
