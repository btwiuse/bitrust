[
  {
    "hash": "dee8a71cd5221536c319ca8c14108e93521092f5",
    "author": "Ariel Ben-Yehuda",
    "date": 1511705563,
    "message": "fix #[derive] implementation for repr(packed) structs\n\nFix the derive implementation for repr(packed) structs to move the\nfields out instead of calling functions on references to each subfield.\n\nThat's it, `#[derive(PartialEq)]` on a packed struct now does:\n```Rust\nfn eq(&self, other: &Self) {\n    let field_0 = self.0;\n    let other_field_0 = other.0;\n    &field_0 == &other_field_0\n}\n```\n\nInstead of\n```Rust\nfn eq(&self, other: &Self) {\n    let ref field_0 = self.0;\n    let ref other_field_0 = other.0;\n    &*field_0 == &*other_field_0\n}\n```\n\nTaking (unaligned) references to each subfield is undefined, unsound and\nis an error with MIR effectck, so it had to be prevented. This causes\na borrowck error when a `repr(packed)` struct has a non-Copy field (and\ntherefore is a [breaking-change]), but I don't see a sound way to avoid\nthat error."
  },
  {
    "hash": "7ebd81377db0e24f57be9c4f7aa84d2556931f1a",
    "author": "Guillaume Gomez",
    "date": 1502614989,
    "message": "Rollup merge of #43782 - nrc:include, r=GuillaumeGomez\n\nFix include! in doc tests\n\nBy making the path relative to the current file.\n\nFixes #43153\n\n[breaking-change] - if you use `include!` inside a doc test, you'll need to change the path to be relative to the current file rather than relative to the working directory."
  },
  {
    "hash": "83c659ef655b1f740777f83eb415fd7ebe5a3fe5",
    "author": "bors",
    "date": 1500373213,
    "message": "Auto merge of #42492 - petrochenkov:methlife, r=nikomatsakis\n\nSupport generic lifetime arguments in method calls\n\nFixes https://github.com/rust-lang/rust/issues/42403\nFixes https://github.com/rust-lang/rust/issues/42115\nLifetimes in a method call `x.f::<'a, 'b, T, U>()` are treated exactly like lifetimes in the equivalent UFCS call `X::f::<'a, 'b, T, U>`.\nIn addition, if the method has late bound lifetime parameters (explicit or implicit), then explicitly specifying lifetime arguments is not permitted (guarded by a compatibility lint).\n[breaking-change] because previously lifetimes in method calls were accepted unconditionally.\n\nr? @eddyb"
  },
  {
    "hash": "b80b659d674fa19b2b48142e4f7974544bc8d5f6",
    "author": "bors",
    "date": 1499391133,
    "message": "Auto merge of #42125 - petrochenkov:privty, r=nikomatsakis\n\nCheck types for privacy\n\nThis PR implements late post factum checking of type privacy, as opposed to early preventive \"private-in-public\" checking.\nThis will allow to turn private-in-public checks into a lint and make them more heuristic-based, and more aligned with what people may expect (e.g. reachability-based behavior).\n\nTypes are privacy-checked if they are written explicitly, and also if they are inferred as expression or pattern types.\nThis PR checks \"semantic\" types and does it unhygienically, this significantly restricts what macros 2.0 (as implemented in https://github.com/rust-lang/rust/pull/40847) can do (sorry @jseyfried) - they still can use private *names*, but can't use private *types*.\nThis is the most conservative solution, but hopefully it's temporary and can be relaxed in the future, probably using macro contexts of expression/pattern spans.\n\nTraits are also checked in preparation for [trait aliases](https://github.com/rust-lang/rust/issues/41517), which will be able to leak private traits, and macros 2.0 which will be able to leak pretty much anything.\n\nThis is a [breaking-change], but the code that is not contrived and can be broken by this patch should be guarded by `private_in_public` lint. [Previous crater run](https://github.com/rust-lang/rust/issues/34537#issuecomment-262865768) discovered a few abandoned crates that weren't updated since `private_in_public` has been introduced in 2015.\n\ncc https://github.com/rust-lang/rust/issues/34537 https://internals.rust-lang.org/t/lang-team-minutes-private-in-public-rules/4504\nFixes https://github.com/rust-lang/rust/issues/30476\nFixes https://github.com/rust-lang/rust/issues/33479\n\ncc @nikomatsakis\nr? @eddyb"
  },
  {
    "hash": "2a992167c51d30a2b21da7a20d8c3077a2ec0093",
    "author": "bors",
    "date": 1499001743,
    "message": "Auto merge of #43015 - arielb1:every-error-counts, r=eddyb\n\nreport the total number of errors on compilation failure\n\nPrior to this PR, when we aborted because a \"critical pass\" failed, we displayed the number of errors from that critical pass. While that's the number of errors that caused compilation to abort in *that place*, that's not what people really want to know. Instead, always report the total number of errors, and don't bother to track the number of errors from the last pass that failed.\n\nThis changes the compiler driver API to handle errors more smoothly, therefore is a compiler-api-[breaking-change].\n\nFixes #42793.\n\nr? @eddyb"
  },
  {
    "hash": "fb7ab9e43da3727e1c58faf9451857968270dc77",
    "author": "Ariel Ben-Yehuda",
    "date": 1499001404,
    "message": "report the total number of errors on compilation failure\n\nPrior to this PR, when we aborted because a \"critical pass\" failed, we\ndisplayed the number of errors from that critical pass. While that's the\nnumber of errors that caused compilation to abort in *that place*,\nthat's not what people really want to know. Instead, always report the\ntotal number of errors, and don't bother to track the number of errors\nfrom the last pass that failed.\n\nThis changes the compiler driver API to handle errors more smoothly,\nand therefore is a compiler-api-[breaking-change].\n\nFixes #42793."
  },
  {
    "hash": "4079e6128f6cff3270ed2b0ebdc62fb6b1f4b5d7",
    "author": "bors",
    "date": 1498612332,
    "message": "Auto merge of #42417 - eddyb:separate-fn-sig, r=nikomatsakis\n\nDon't drag function signatures along function item types.\n\nThis PR separates the signature of a function from the \"function item type\" (`TyFnDef`), leaving only the `DefId` and parameter `Substs`, making them even more like (captureless) closure types.\n\nThe motivation for this change is reducing typesystem complexity, and its consequences:\n* operating on the signature instead of just the parameters was less efficient\n  * specifically, signatures can easily add several levels of depth on top of the parameter types\n  * and the signatured were always substituted and normalized, so typically even more complex\n* it was *the only* type that was *both* nominal (identity) and structural (signature)\n  * harder to model in Chalk than either a purely nominal or structural type\n  * subtyping worked on the signature but parameters were always invariant\n  * call type-checking was transforming signatures but keeping the nominal half intact\n  * the signature could therefore get out of sync during type inference in several ways\n\nThat last point comes with a `[breaking-change]`, because functions with `'static` in their return types will now *not* be as usable as if they were using lifetime parameters instead:\n```rust\n// Will cause lifetime mismatch in main after this PR.\nfn bar() -> &'static str { \"bar\" }\n// Will continue to work fine, as every use can choose its own lifetime.\nfn bar<'a>() -> &'a str { \"bar\" }\n\nfn main() {\n    let s = String::from(\"foo\");\n    Some(&s[..]).unwrap_or_else(bar);\n}\n```\n\nr? @nikomatsakis"
  },
  {
    "hash": "422faf7a6fbedd75653f1568e69858f62b5c0fe7",
    "author": "Corey Farwell",
    "date": 1496290159,
    "message": "Rollup merge of #42136 - petrochenkov:oldhard, r=nikomatsakis\n\nTurn sufficiently old compatibility lints into hard errors\n\nIt's been almost 7 months since https://github.com/rust-lang/rust/pull/36894 was merged, so it's time to take the next step.\n\n[breaking-change], needs crater run.\n\nPRs/issues submitted to affected crates:\nhttps://github.com/alexcrichton/ctest/pull/17\nhttps://github.com/Sean1708/rusty-cheddar/pull/55\nhttps://github.com/m-r-r/helianto/pull/3\nhttps://github.com/azdle/virgil/pull/1\nhttps://github.com/rust-locale/rust-locale/issues/24\nhttps://github.com/mneumann/acyclic-network-rs/pull/1\nhttps://github.com/reem/rust-typemap/pull/38\n\ncc https://internals.rust-lang.org/t/moving-forward-on-forward-compatibility-lints/4204\ncc https://github.com/rust-lang/rust/issues/34537 https://github.com/rust-lang/rust/issues/36887\nCloses https://github.com/rust-lang/rust/issues/36886\nCloses https://github.com/rust-lang/rust/issues/36888\nCloses https://github.com/rust-lang/rust/issues/36890\nCloses https://github.com/rust-lang/rust/issues/36891\nCloses https://github.com/rust-lang/rust/issues/36892\nr? @nikomatsakis"
  },
  {
    "hash": "493cd6b6e2dfc400c4026f1f2c9b89e97055107e",
    "author": "Robin Kruppe",
    "date": 1495912093,
    "message": "Reduce API surface of rustc_trans\n\nMark various items and fields as private or pub(crate), and remove a function that turns out to be unused.\nThese are not used anywhere in-tree, but I guess it's a [breaking-change] for plugins."
  },
  {
    "hash": "c104db48018ad01588153a59de6bdf9f177bf8f9",
    "author": "Corey Farwell",
    "date": 1494297286,
    "message": "Rollup merge of #41293 - est31:floating_literal_match, r=nikomatsakis\n\nImplement the illegal_floating_point_literal_pattern compat lint\n\nAdds a future-compatibility lint for the [breaking-change] introduced by issue #41620 . cc issue #41255 ."
  },
  {
    "hash": "7e7114fe2e26c5ccd6ebbd5686410b61a47820dc",
    "author": "bors",
    "date": 1493163997,
    "message": "Auto merge of #41332 - petrochenkov:privti, r=eddyb\n\nCheck privacy of trait items in all contexts\n\nFixes https://github.com/rust-lang/rust/issues/28514\n\nThis is a sufficiently rare scenario and it's currently guarded by `private_in_public` lint, so it shouldn't be a [breaking-change] in practice."
  },
  {
    "hash": "3b5754e5ce73d24c6684b3ed0c68a557dfdd2f52",
    "author": "bors",
    "date": 1491847223,
    "message": "Auto merge of #40018 - japaric:ld, r=alexcrichton\n\n-Z linker-flavor\n\n(Please read the commit message first)\n\nThis PR is an alternative to rust-lang/rust#36120 (internal lld linker). The\nmain goal of this PR is to make it *possible* to use LLD as a linker to allow\nout of tree experimentation. Now that LLD is going to be shipped with LLVM 4.0,\nit should become easier to get a hold of LLD (hopefully, it will be packaged by\nLinux distros soon).\n\nSince LLD is a multiarch linker, it has the potential to make cross compilation\neasier (less tools need to be installed). Supposedly, LLD is also faster than\nthe gold linker so LLD may improve build times where link times are significant\n(e.g. 100% incremental compilation reuse).\n\nThe place where LLD shines is at linking Rust programs that don't depend on\nsystem libraries. For example, here's how you would link a bare metal ARM\nCortex-M program:\n\n```\n$ xargo rustc --target thumbv7m-none-eabi -- -Z linker-flavor=ld -C linker=ld.lld -Z print-link-args\n\"ld.lld\" \\\n  \"-L\" \\\n  \"$XARGO_HOME/lib/rustlib/thumbv7m-none-eabi/lib\" \\\n  \"$PWD/target/thumbv7m-none-eabi/debug/deps/app-de1f86df314ad68c.0.o\" \\\n  \"-o\" \\\n  \"$PWD/target/thumbv7m-none-eabi/debug/deps/app-de1f86df314ad68c\" \\\n  \"--gc-sections\" \\\n  \"-L\" \\\n  \"$PWD/target/thumbv7m-none-eabi/debug/deps\" \\\n  \"-L\" \\\n  \"$PWD/target/debug/deps\" \\\n  \"-L\" \\\n  \"$XARGO_HOME/lib/rustlib/thumbv7m-none-eabi/lib\" \\\n  \"-Bstatic\" \\\n  \"-Bdynamic\" \\\n  \"$XARGO_HOME/lib/rustlib/thumbv7m-none-eabi/lib/libcore-11670d2bd4951fa7.rlib\"\n\n$ file target/thumbv7m-none-eabi/debug/app\napp: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped, with debug_info\n```\n\nThis doesn't require installing the `arm-none-eabi-gcc` toolchain.\n\nEven cooler (but I'm biased) is that you can link Rust programs that use\n[`steed`] (`steed` is a `std` re-implementation free of C dependencies for Linux\nsystems) instead of `std` for a bunch of different architectures without having\nto install a single cross toolchain.\n\n[`steed`]: https://github.com/japaric/steed\n\n```\n$ xargo rustc --target aarch64-unknown-linux-steed --example hello --release -- -Z print-link-args\n\"ld.lld\" \\\n  \"-L\" \\\n  \"$XARGO_HOME/lib/rustlib/aarch64-unknown-linux-steed/lib\" \\\n  \"$PWD/target/aarch64-unknown-linux-steed/release/examples/hello-80c130ad884c0f8f.0.o\" \\\n  \"-o\" \\\n  \"$PWD/target/aarch64-unknown-linux-steed/release/examples/hello-80c130ad884c0f8f\" \\\n  \"--gc-sections\" \\\n  \"-L\" \\\n  \"$PWD/target/aarch64-unknown-linux-steed/release/deps\" \\\n  \"-L\" \\\n  \"$PWD/target/release/deps\" \\\n  \"-L\" \\\n  \"$XARGO_HOME/lib/rustlib/aarch64-unknown-linux-steed/lib\" \\\n  \"-Bstatic\" \\\n  \"-Bdynamic\" \\\n  \"/tmp/rustc.lAybk9Ltx93Q/libcompiler_builtins-589aede02de78434.rlib\"\n\n$ file target/aarch64-unknown-linux-steed/release/examples/hello\nhello: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, not stripped, with debug_info\n```\n\nAll these targets (architectures) worked with LLD:\n\n- [aarch64-unknown-linux-steed](https://github.com/japaric/steed/blob/lld/docker/aarch64-unknown-linux-steed.json)\n- [arm-unknown-linux-steedeabi](https://github.com/japaric/steed/blob/lld/docker/arm-unknown-linux-steedeabi.json)\n- [arm-unknown-linux-steedeabihf](https://github.com/japaric/steed/blob/lld/docker/arm-unknown-linux-steedeabihf.json)\n- [armv7-unknown-linux-steedeabihf](https://github.com/japaric/steed/blob/lld/docker/armv7-unknown-linux-steedeabihf.json)\n- [i686-unknown-linux-steed](https://github.com/japaric/steed/blob/lld/docker/i686-unknown-linux-steed.json)\n- [mips-unknown-linux-steed](https://github.com/japaric/steed/blob/lld/docker/mips-unknown-linux-steed.json)\n- [mipsel-unknown-linux-steed](https://github.com/japaric/steed/blob/lld/docker/mipsel-unknown-linux-steed.json)\n- [powerpc-unknown-linux-steed](https://github.com/japaric/steed/blob/lld/docker/powerpc-unknown-linux-steed.json)\n- [powerpc64-unknown-linux-steed](https://github.com/japaric/steed/blob/lld/docker/powerpc64-unknown-linux-steed.json)\n- [x86_64-unknown-linux-steed](https://github.com/japaric/steed/blob/lld/docker/x86_64-unknown-linux-steed.json)\n\n---\n\nThe case where lld is unergonomic is linking binaries that depend on system\nlibraries. Like \"Hello, world\" for `x86_64-unknown-linux-gnu`. Because you have\nto pass as linker arguments: the path to the startup objects, the path to the\ndynamic linker and the library search paths. And all those are system specific\nso they can't be encoded in the target itself.\n\n```\n$ cargo \\\n  rustc \\\n  --release \\\n  -- \\\n  -C \\\n  linker=ld.lld \\\n  -Z \\\n  linker-flavor=ld \\\n  -C \\\n  link-args='-dynamic-linker /lib64/ld-linux-x86-64.so.2 -L/usr/lib -L/usr/lib/gcc/x86_64-pc-linux-gnu/6.3.1 /usr/lib/Scrt1.o /usr/lib/crti.o /usr/lib/gcc/x86_64-pc-linux-gnu/6.3.1/crtbeginS.o /usr/lib/gcc/x86_64-pc-linux-gnu/6.3.1/crtendS.o /usr/lib/crtn.o'\n```\n\n---\n\nAnother case where `-Z linker-flavor` may come in handy is directly calling\nSolaris' linker which is also a multiarch linker (or so I have heard). cc\n@binarycrusader\n\ncc @alexcrichton\nHeads up: [breaking-change] due to changes in the target specification format."
  },
  {
    "hash": "9d11b089ad136432dff6c49c6eb3c48c7f6e5273",
    "author": "Jorge Aparicio",
    "date": 1491580362,
    "message": "-Z linker-flavor\n\nThis patch adds a `-Z linker-flavor` flag to rustc which can be used to invoke\nthe linker using a different interface.\n\nFor example, by default rustc assumes that all the Linux targets will be linked\nusing GCC. This makes it impossible to use LLD as a linker using just `-C\nlinker=ld.lld` because that will invoke LLD with invalid command line\narguments. (e.g. rustc will pass -Wl,--gc-sections to LLD but LLD doesn't\nunderstand that; --gc-sections would be the right argument)\n\nWith this patch one can pass `-Z linker-flavor=ld` to rustc to invoke the linker\nusing a LD-like interface. This way, `rustc -C linker=ld.lld -Z\nlinker-flavor=ld` will invoke LLD with the right arguments.\n\n`-Z linker-flavor` accepts 4 different arguments: `em` (emcc), `ld`,\n`gcc`, `msvc` (link.exe). `em`, `gnu` and `msvc` cover all the existing linker\ninterfaces. `ld` is a new flavor for interfacing GNU's ld and LLD.\n\nThis patch also changes target specifications. `linker-flavor` is now a\nmandatory field that specifies the *default* linker flavor that the target will\nuse. This change also makes the linker interface *explicit*; before, it used to\nbe derived from other fields like linker-is-gnu, is-like-msvc,\nis-like-emscripten, etc.\n\nAnother change to target specifications is that the fields `pre-link-args`,\n`post-link-args` and `late-link-args` now expect a map from flavor to linker\narguments.\n\n``` diff\n-    \"pre-link-args\": [\"-Wl,--as-needed\", \"-Wl,-z,-noexecstack\"],\n+    \"pre-link-args\": {\n+        \"gcc\": [\"-Wl,--as-needed\", \"-Wl,-z,-noexecstack\"],\n+        \"ld\": [\"--as-needed\", \"-z,-noexecstack\"],\n+    },\n```\n\n[breaking-change]  for users of custom targets specifications"
  },
  {
    "hash": "8c4f2c64c6759a82f143e23964a46a65c67509c9",
    "author": "bors",
    "date": 1490148016,
    "message": "Auto merge of #40043 - petrochenkov:objpars, r=nikomatsakis\n\nRefactor parsing of trait object types\n\nBugs are fixed and code is cleaned up.\n\nUser visible changes:\n- `ty` matcher in macros accepts trait object types like `Write + Send` (https://github.com/rust-lang/rust/issues/39080)\n- Buggy priority of `+` in trait object types starting with `for` is fixed (https://github.com/rust-lang/rust/issues/39317). `&for<'a> Trait<'a> + Send` is now parsed as `(&for<'a> Trait<'a>) + Send` and requires parens `&(for<'a> Trait<'a> + Send)`. For comparison, `&Send + for<'a> Trait<'a>` was parsed like this since [Nov 27, 2014](https://github.com/rust-lang/rust/pull/19298).\n- Trailing `+`s are supported in trait objects, like in other bounds.\n- Better error reporting for trait objects starting with `?Sized`.\n\nFixes https://github.com/rust-lang/rust/issues/39080\nFixes https://github.com/rust-lang/rust/issues/39317 [breaking-change]\nCloses https://github.com/rust-lang/rust/issues/39298\ncc https://github.com/rust-lang/rust/issues/39085 (fixed, then reverted https://github.com/rust-lang/rust/pull/40043#issuecomment-286570653)\ncc https://github.com/rust-lang/rust/issues/39318 (fixed, then reverted https://github.com/rust-lang/rust/pull/40043#issuecomment-284493890)\n\nr? @nikomatsakis"
  },
  {
    "hash": "e5221f93977922090b0370aff1efdbf5c2d12f6d",
    "author": "Corey Farwell",
    "date": 1489971066,
    "message": "Rollup merge of #40241 - Sawyer47:fix-39997, r=alexcrichton\n\nChange how the `0` flag works in format!\n\nNow it always implies right-alignment, so that padding zeroes are placed after the sign (if any) and before the digits. In other words, it always takes precedence over explicitly specified `[[fill]align]`. This also affects the '#' flag: zeroes are placed after the prefix (0b, 0o, 0x) and before the digits.\n\nHere's a short summary of how similar format strings work in Python and Rust:\n\n```\n              :05     :<05    :>05    :^05\nPython 3.6  |-0001| |-1000| |000-1| |0-100|\nRust before |-0001| |-1000| |-0001| |-0100|\nRust after  |-0001| |-0001| |-0001| |-0001|\n\n             :#05x   :<#05x  :>#05x  :^#05x\nPython 3.6  |0x001| |0x100| |000x1| |00x10|\nRust before |0x001| |0x100| |000x1| |0x010|\nRust after  |0x001| |0x001| |0x001| |0x001|\n```\n\nFixes #39997 [breaking-change]"
  },
  {
    "hash": "ff63866edb511a73eed657a8a4f5c81f1ee5a9bb",
    "author": "Piotr Jawniak",
    "date": 1489589444,
    "message": "Change how the `0` flag works in format!\n\nNow it always implies right-alignment, so that padding zeroes are placed after the sign (if any) and before the digits. In other words, it always takes precedence over explicitly specified `[[fill]align]`. This also affects the '#' flag: zeroes are placed after the prefix (0b, 0o, 0x) and before the digits.\n\n           :05     :<05    :>05    :^05\nbefore   |-0001| |-1000| |-0001| |-0100|\nafter    |-0001| |-0001| |-0001| |-0001|\n          :#05x   :<#05x  :>#05x  :^#05x\nbefore   |0x001| |0x100| |000x1| |0x010|\nafter    |0x001| |0x001| |0x001| |0x001|\n\nFixes #39997 [breaking-change]"
  },
  {
    "hash": "1b19284ad9d85f2848650be6dd466ad0e1e2d82c",
    "author": "bors",
    "date": 1489272494,
    "message": "Auto merge of #40220 - jseyfried:ast_macro_def, r=nrc\n\nsyntax: add `ast::ItemKind::MacroDef`, simplify hygiene info\n\nThis PR\n - adds a new variant `MacroDef` to `ast::ItemKind` for `macro_rules!` and eventually `macro` items,\n - [breaking-change] forbids macro defs without a name (`macro_rules! { () => {} }` compiles today),\n - removes `ast::MacroDef`, and\n - no longer uses `Mark` and `Invocation` to identify and characterize macro definitions.\n   - We used to apply (at least) two `Mark`s to an expanded identifier's `SyntaxContext` -- the definition mark(s) and the expansion mark(s). We now only apply the latter.\n\nr? @nrc"
  },
  {
    "hash": "691eba1358fc3c9c7a8033314a4112d43680c128",
    "author": "bors",
    "date": 1488362624,
    "message": "Auto merge of #34198 - eddyb:you're-a-bad-transmute-and-you-should-feel-bad, r=nikomatsakis\n\nMake transmuting from fn item types to pointer-sized types a hard error.\n\nCloses #19925 by removing the future compatibility lint and the associated workarounds.\nThis is a `[breaking-change]` if you `transmute` from a function item without casting first.\nFor more information on how to fix your code, see https://github.com/rust-lang/rust/issues/19925."
  },
  {
    "hash": "7ce1fbe1f7fe5cdbec57377d76306e2bc7811bce",
    "author": "bors",
    "date": 1488347889,
    "message": "Auto merge of #39419 - jseyfried:simplify_tokentree, r=nrc\n\nSimplify `TokenTree` and fix `macro_rules!` bugs\n\nThis PR\n - fixes #39390, fixes #39403, and fixes #39404 (each is a [breaking-change], see issues for examples),\n - fixes #39889,\n - simplifies and optimizes macro invocation parsing,\n - cleans up `ext::tt::transcribe`,\n - removes `tokenstream::TokenTree::Sequence` and `Token::MatchNt`,\n   - instead, adds a new type `ext::tt::quoted::TokenTree` for use by `macro_rules!` (`ext::tt`)\n - removes `parser.quote_depth` and `parser.parsing_token_tree`, and\n - removes `quote_matcher!`.\n   - Instead, use `quote_tokens!` and `ext::tt::quoted::parse` the result with `expect_matchers=true`.\n   - I found no outside uses of `quote_matcher!` when searching Rust code on Github.\n\nr? @nrc"
  },
  {
    "hash": "4ba49ab39f942af3846cf0d8599674b0adde94b5",
    "author": "Corey Farwell",
    "date": 1488340526,
    "message": "Rollup merge of #39419 - jseyfried:simplify_tokentree, r=nrc\n\nSimplify `TokenTree` and fix `macro_rules!` bugs\n\nThis PR\n - fixes #39390, fixes #39403, and fixes #39404 (each is a [breaking-change], see issues for examples),\n - fixes #39889,\n - simplifies and optimizes macro invocation parsing,\n - cleans up `ext::tt::transcribe`,\n - removes `tokenstream::TokenTree::Sequence` and `Token::MatchNt`,\n   - instead, adds a new type `ext::tt::quoted::TokenTree` for use by `macro_rules!` (`ext::tt`)\n - removes `parser.quote_depth` and `parser.parsing_token_tree`, and\n - removes `quote_matcher!`.\n   - Instead, use `quote_tokens!` and `ext::tt::quoted::parse` the result with `expect_matchers=true`.\n   - I found no outside uses of `quote_matcher!` when searching Rust code on Github.\n\nr? @nrc"
  },
  {
    "hash": "87e544bca5ae1bd187f11239abcab1f73c836049",
    "author": "Ariel Ben-Yehuda",
    "date": 1487882782,
    "message": "use a more conservative inhabitableness rule\n\nThis is a [breaking-change] from 1.15, because this used to compile:\n\n```Rust\nenum Void {}\nfn foo(x: &Void) {\n    match x {}\n}\n```"
  },
  {
    "hash": "956e2bcbaa00c05e051718b1375375915064f1c3",
    "author": "bors",
    "date": 1486941675,
    "message": "Auto merge of #39572 - jseyfried:fix_inert_attributes, r=nrc\n\nmacros: fix inert attributes from `proc_macro_derives` with `#![feature(proc_macro)]`\n\nThis PR refactors collection of `proc_macro_derive` invocations to fix #39347.\n\nAfter this PR, the input to a `#[proc_macro_derive]` function no longer sees `#[derive]`s on the underlying item. For example, consider:\n```rust\nextern crate my_derives;\nuse my_derives::{Trait, Trait2};\n\n#[derive(Copy, Clone)]\n#[derive(Trait)]\n#[derive(Trait2)]\nstruct S;\n```\n\nToday, the input to the `Trait` derive is `#[derive(Copy, Clone, Trait2)] struct S;`, and the input to the `Trait2` derive is `#[derive(Copy, Clone)] struct S;`. More generally, a `proc_macro_derive` sees all builtin derives, as well as all `proc_macro_derive`s listed *after* the one being invoked.\n\nAfter this PR, both `Trait` and `Trait2` will see `struct S;`.\nThis is a [breaking-change], but I believe it is highly unlikely to cause breakage in practice.\n\nr? @nrc"
  },
  {
    "hash": "b27c7095606ad9386a7038d7af03abd7f948f02f",
    "author": "bors",
    "date": 1484165546,
    "message": "Auto merge of #38313 - jseyfried:self_imports, r=nrc\n\nresolve: clean up the semantics of `self` in an import list\n\nChange `self` in an import list `use foo::bar::{self, ...};` to import `bar` only in the type namespace. Today, `bar` is imported in every namespace in which `foo::bar` is defined.\n\nThis is a [breaking-change], see https://github.com/rust-lang/rust/issues/38293#issue-194817974 for examples of code that would break.\n\nFixes #38293.\nr? @nrc"
  },
  {
    "hash": "10771498273764e25d197209f80830a45b7cfdcd",
    "author": "bors",
    "date": 1480638011,
    "message": "Auto merge of #37789 - arielb1:length-limit, r=nikomatsakis\n\nlimit the length of types in monomorphization\n\nThis adds the new insta-stable `#![type_size_limit]` crate attribute to control\nthe limit, and is obviously a [breaking-change] fixable by that.\n\nFixes #37311.\n\nr? @nikomatsakis"
  },
  {
    "hash": "242cd7ebe295d44c7b612e2e1da8b83412d31f49",
    "author": "Ariel Ben-Yehuda",
    "date": 1480632862,
    "message": "limit the length of types in monomorphization\n\nThis adds the new insta-stable `#![type_size_limit]` crate attribute to control\nthe limit, and is obviously a [breaking-change] fixable by that."
  },
  {
    "hash": "1c11ea3aedebac562f5125e1cf22ac56a3a8993c",
    "author": "bors",
    "date": 1479784548,
    "message": "Auto merge of #37602 - jseyfried:directory_ownership, r=nikomatsakis\n\nparser: simplify directory ownership semantics\n\nThis PR simplifies the semantics of \"directory ownership\". After this PR,\n - a non-inline module without a `#[path]` attribute (e.g. `mod foo;`) is allowed iff its parent module/block (whichever is nearer) is a directory owner,\n - an non-inline module is a directory owner iff its corresponding file is named `mod.rs` (c.f. [comment](https://github.com/rust-lang/rust/issues/32401#issuecomment-201021902)),\n - a block is never a directory owner (c.f. #31534), and\n - an inline module is a directory owner iff either\n   - its parent module/block is a directory owner (again, c.f. #31534), or\n   - it has a `#[path]` attribute (c.f. #36789).\n\nThese semantics differ from today's in three orthogonal ways:\n - `#[path = \"foo.rs\"] mod foo;` is no longer a directory owner. This is a [breaking-change].\n - #36789 is generalized to apply to modules that are not directory owners in addition to blocks.\n - A macro-expanded non-inline module is only allowed where an ordinary non-inline module would be allowed. Today, we incorrectly allow macro-expanded non-inline modules in modules that are not directory owners (but not in blocks). This is a [breaking-change].\n\nFixes #32401.\nr? @nikomatsakis"
  },
  {
    "hash": "fb025b483a5ef96bba944055c47af620d2afb602",
    "author": "bors",
    "date": 1479560328,
    "message": "Auto merge of #37814 - japaric:aapcs, r=alexcrichton\n\nfix `extern \"aapcs\" fn`\n\nto actually use the AAPCS calling convention\n\ncloses #37810\n\nThis is technically a [breaking-change] because it changes the ABI of\n`extern \"aapcs\"` functions that (a) involve `f32`/`f64` arguments/return\nvalues and (b) are compiled for arm-eabihf targets from\n\"aapcs-vfp\" (wrong) to \"aapcs\" (correct).\n\nAppendix:\n\nWhat these ABIs mean?\n\n- In the \"aapcs-vfp\" ABI or \"hard float\" calling convention: Floating\npoint values are passed/returned through FPU registers (s0, s1, d0, etc.)\n\n- Whereas, in the \"aapcs\" ABI or \"soft float\" calling convention:\nFloating point values are passed/returned through general purpose\nregisters (r0, r1, etc.)\n\nMixing these ABIs can cause problems if the caller assumes that the\nroutine is using one of these ABIs but it's actually using the other\none.\n\n---\n\nr? @alexcrichton We are going this `extern \"aapcs\" fn` thing to implement some intrinsics (floatundidf) for the eabihf targets in order to comply with LLVM's calling convention of intrinsics.\n\nOh, and the value of the enum came from [here](http://llvm.org/docs/doxygen/html/namespacellvm_1_1CallingConv.html).\n\ncc @TimNN @parched"
  },
  {
    "hash": "456ceba13784f2f88f7f21239e308a0f195967a1",
    "author": "Jorge Aparicio",
    "date": 1479339512,
    "message": "fix `extern \"aapcs\" fn`\n\nto actually use the AAPCS calling convention\n\ncloses #37810\n\nThis is technically a [breaking-change] because it changes the ABI of\n`extern \"aapcs\"` functions that (a) involve `f32`/`f64` arguments/return\nvalues and (b) are compiled for arm-eabihf targets from\n\"aapcs-vfp\" (wrong) to \"aapcs\" (correct).\n\nAppendix:\n\nWhat these ABIs mean?\n\n- In the \"aapcs-vfp\" ABI or \"hard float\" calling convention: Floating\npoint values are passed/returned through FPU registers (s0, s1, d0, etc.)\n\n- Whereas, in the \"aapcs\" ABI or \"soft float\" calling convention:\nFloating point values are passed/returned through general purpose\nregisters (r0, r1, etc.)\n\nMixing these ABIs can cause problems if the caller assumes that the\nroutine is using one of these ABIs but it's actually using the other\none."
  },
  {
    "hash": "323c20c8a4747aa96285c90005a00aa43228af8e",
    "author": "Oliver 'ker' Schneider",
    "date": 1478867770,
    "message": "[breaking-change] change the `box_free` item to accept pointers to unsized types"
  },
  {
    "hash": "ab03f855221d83ad13120b309506488f4a34cb0f",
    "author": "bors",
    "date": 1478772345,
    "message": "Auto merge of #37463 - jseyfried:refactor_macro_reexports, r=nrc\n\nmacros: improve reexports\n\nThis PR\n- avoids building multiple module graphs for a crate that is referenced by multiple `extern crate` items,\n- registers `#[no_link] extern crate`s to avoid loading the same crate metadata twice,\n- stability checks `#[no_link] extern crate`s,\n  - [breaking-chage]: `#[no_link] #[macro_use] extern crate syntax;` is allowed on stable today\n- fixes `$crate` in `#[macro_reexport]`ed macros,\n  - [breaking-change] for `#[feature(macro_reexport)]` (technically)\n- allows selective macro importing (i.e. `#[macro_use(foo, bar)]`) from custom derive crates, and\n- refactors the crate metadata to support re-exported macros in arbitrary modules (not yet needed).\n\nr? @nrc"
  },
  {
    "hash": "09fc1af9d80ecb71c82367b6569461e645a3a946",
    "author": "bors",
    "date": 1478488348,
    "message": "Auto merge of #37506 - jseyfried:improve_shadowing_checks, r=nrc\n\nmacros: improve shadowing checks\n\nThis PR improves macro-expanded shadowing checks to work with out-of-(pre)order expansion.\n\nOut-of-order expansion became possible in #37084, so this technically a [breaking-change] for nightly.\nThe regression test from this PR is an example of code that would break.\n\nr? @nrc"
  },
  {
    "hash": "ccfc38f034e3f53cb460936bd9744085d4a63b40",
    "author": "bors",
    "date": 1478269244,
    "message": "Auto merge of #37167 - nikomatsakis:jroesch-issue-18937, r=pnkfelix\n\ndetect extra region requirements in impls\n\nThe current \"compare method\" check fails to check for the \"region obligations\" that accrue in the fulfillment context. This branch switches that code to create a `FnCtxt` so that it can invoke the regionck code. Previous crater runs (I haven't done one with the latest tip) have found some small number of affected crates, so I went ahead and introduced a warning cycle. I will kick off a crater run with this branch shortly.\n\nThis is a [breaking-change] because previously unsound code was accepted. The crater runs also revealed some cases where legitimate code was no longer type-checking, so the branch contains one additional (but orthogonal) change. It improves the elaborator so that we elaborate region requirements more thoroughly. In particular, if we know that `&'a T: 'b`, we now deduce that `T: 'b` and `'a: 'b`.\n\nI invested a certain amount of effort in getting a good error message. The error message looks like this:\n\n```\nerror[E0276]: impl has stricter requirements than trait\n  --> traits-elaborate-projection-region.rs:33:5\n   |\n21 |     fn foo() where T: 'a;\n   |     --------------------- definition of `foo` from trait\n...\n33 |     fn foo() where U: 'a { }\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `U: 'a`\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #18937 <https://github.com/rust-lang/rust/issues/18937>\nnote: lint level defined here\n  --> traits-elaborate-projection-region.rs:12:9\n   |\n12 | #![deny(extra_requirement_in_impl)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nObviously the warning only prints if this is a _new_ error (that resulted from the bugfix). But all existing errors that fit this description are updated to follow the general template. In order to get the lint to preserve the span-labels and the error code, I separate out the core `Diagnostic` type (which encapsulates the error code, message, span, and children) from the `DiagnosticBuilder` (which layers on a `Handler` that can be used to report errors). I also extended `add_lint` with an alternative `add_lint_diagnostic` that takes in a full diagnostic (cc @jonathandturner for those changes). This doesn't feel ideal but feels like it's moving in the right direction =).\n\nr? @pnkfelix\ncc @arielb1\n\nFixes #18937"
  },
  {
    "hash": "d00e5e9343a11939c80c0ade5ca71c8dcbc31847",
    "author": "Jonathan Turner",
    "date": 1478113781,
    "message": "Rollup merge of #37351 - Amanieu:consume, r=alexcrichton\n\nPrevent exhaustive matching of Ordering to allow for future extension\n\nThe C++11 atomic memory model defines a `memory_order_consume` ordering which is generally equivalent to `memory_order_acquire` but can allow better code generation by avoiding memory barrier instructions. Most compilers (including LLVM) currently do not implement this ordering directly and instead treat it identically to `memory_order_acquire`, including adding a memory barrier instruction.\n\nThere is currently [work](http://open-std.org/Jtc1/sc22/wg21/docs/papers/2016/p0098r1.pdf) to support consume ordering in compilers, and it would be a shame if Rust did not support this. This PR therefore reserves a `__Nonexhaustive` variant in `Ordering` so that adding a new ordering is not a breaking change in the future.\n\nThis is a [breaking-change] since it disallows exhaustive matching on `Ordering`, however a search of all Rust code on Github shows that there is no code that does this. This makes sense since `Ordering` is typically only used as a parameter to an atomic operation."
  },
  {
    "hash": "6062e7ed3d81cb3bd535993e9b14269924b76c29",
    "author": "bors",
    "date": 1477835490,
    "message": "Auto merge of #37431 - jseyfried:refactor_crate_config, r=eddyb\n\nMove `CrateConfig` from `Crate` to `ParseSess`\n\nThis is a syntax-[breaking-change]. Most breakage can be fixed by removing a `CrateConfig` argument.\nr? @eddyb"
  },
  {
    "hash": "aef18be1bc4e03617177c5e9df1164ce3df49ba2",
    "author": "bors",
    "date": 1477424263,
    "message": "Auto merge of #37111 - TimNN:sized-enums, r=nikomatsakis\n\nDisallow Unsized Enums\n\nFixes #16812.\n\nThis PR is a potential fix for #16812, an issue which is reported [again](https://github.com/rust-lang/rust/issues/36801) and [again](https://github.com/rust-lang/rust/issues/36975), with over a dozen duplicates by now.\n\nThis PR is mainly meant to promoted discussion about the issue and the correct way to fix it.\n\nThis is a [breaking-change] since the error is now reported during wfchecking, so that even the definition of a (potentially) unsized enum will cause an error (whereas it would previously cause an ICE at trans time if the enum was used in an unsized manner)."
  },
  {
    "hash": "da5b6467c33f7f86b4964b08b37726f7611a8f0c",
    "author": "bors",
    "date": 1477039711,
    "message": "Auto merge of #37247 - jseyfried:future_proof_no_link, r=nrc\n\nmacros: Future proof `#[no_link]`\n\nThis PR future proofs `#[no_link]` for macro modularization (cc #35896).\n\nFirst, we resolve all `#[no_link] extern crate`s. `#[no_link]` crates without `#[macro_use]` or `#[macro_reexport]` are not resolved today, this is a [breaking-change]. For example,\n```rust\n```\nAny breakage can be fixed by simply removing the `#[no_link] extern crate`.\n\nSecond, `#[no_link] extern crate`s will define an empty module in type namespace to eventually allow importing the crate's macros with `use`. This is a [breaking-change], for example:\n```rust\nmod syntax {} //< This becomes a duplicate error.\n```\n\nr? @nrc"
  },
  {
    "hash": "cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7",
    "author": "bors",
    "date": 1476883990,
    "message": "Auto merge of #37213 - jseyfried:refactor_crate_var, r=nrc\n\nmacros: improve `$crate`\n\nThis PR refactors the implementation of `$crate` so that\n - `$crate` is only allowed at the start of a path (like `super`),\n - we can make `$crate` work with inter-crate re-exports (groundwork for macro modularization), and\n - we can support importing macros from an extern crate that is not declared at the crate root (also groundwork for macro modularization).\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nfn foo() {}\nmacro_rules! m { () => {\n    $crate foo $crate () $crate $crate;\n    //^ Today, `$crate` is allowed just about anywhere in unexported macros.\n} }\nfn main() {\n    m!();\n}\n```\nr? @nrc"
  },
  {
    "hash": "20991829e2639d1786acbd52621b220c89f0d9cb",
    "author": "Alex Crichton",
    "date": 1476306476,
    "message": "Rollup merge of #37084 - jseyfried:cleanup_expanded_macro_use_scopes, r=nrc\n\nmacros: clean up scopes of expanded `#[macro_use]` imports\n\nThis PR changes the scope of macro-expanded `#[macro_use]` imports to match that of unexpanded `#[macro_use]` imports. For example, this would be allowed:\n```rust\nexample!();\nmacro_rules! m { () => { #[macro_use(example)] extern crate example_crate; } }\nm!();\n```\n\nThis PR also enforces the full shadowing restrictions from RFC 1560 on `#[macro_use]` imports (currently, we only enforce the weakened restrictions from #36767).\n\nThis is a [breaking-change], but I believe it is highly unlikely to cause breakage in practice.\nr? @nrc"
  },
  {
    "hash": "f05bd1b41ddda779032f4c5c8e30bf640129832f",
    "author": "Alex Crichton",
    "date": 1476306476,
    "message": "Rollup merge of #37064 - nnethercote:read_str, r=eddyb\n\nAvoid allocations in `Decoder::read_str`.\n\n`opaque::Decoder::read_str` is very hot within `rustc` due to its use in\nthe reading of crate metadata, and it currently returns a `String`. This\ncommit changes it to instead return a `Cow<str>`, which avoids a heap\nallocation.\n\nThis change reduces the number of calls to `malloc` by almost 10% in\nsome benchmarks.\n\nThis is a [breaking-change] to libserialize."
  },
  {
    "hash": "b043e11de2eb2c60f7bfec5e15960f537b229e20",
    "author": "Nicholas Nethercote",
    "date": 1476056195,
    "message": "Avoid allocations in `Decoder::read_str`.\n\n`opaque::Decoder::read_str` is very hot within `rustc` due to its use in\nthe reading of crate metadata, and it currently returns a `String`. This\ncommit changes it to instead return a `Cow<str>`, which avoids a heap\nallocation.\n\nThis change reduces the number of calls to `malloc` by almost 10% in\nsome benchmarks.\n\nThis is a [breaking-change] to libserialize."
  },
  {
    "hash": "e2631208b1888d6a340938314457446a7f8ed2fc",
    "author": "Nicholas Nethercote",
    "date": 1475618255,
    "message": "Rename StringReader::curr as ch.\n\nLikewise, rename StringReader::curr_is as ch_is.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "cb92f5c6d6e09a7c1575241a05df15c96ca3b531",
    "author": "Nicholas Nethercote",
    "date": 1475618217,
    "message": "Rename StringReader::last_pos as pos.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "94565a4409f8b8a133db36d3a22221b5b38a1a13",
    "author": "Nicholas Nethercote",
    "date": 1475618125,
    "message": "Rename StringReader::pos as next_pos.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "3c4c85947cddac2d36854e5bf8c7a8edb32e1245",
    "author": "Nicholas Nethercote",
    "date": 1475617998,
    "message": "Rename Parser::last_token_kind as prev_token_kind.\n\nLikewise, rename LastTokenKind as PrevTokenKind.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "2747923c272a355dbb6265586a884652e26b0ec7",
    "author": "Nicholas Nethercote",
    "date": 1475617998,
    "message": "Rename Parser::last_span as prev_span.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "f3745653e10e366e7e119a12c178a59ab6394007",
    "author": "bors",
    "date": 1475483432,
    "message": "Auto merge of #36767 - jseyfried:enforce_rfc_1560_shadowing, r=nrc\n\nEnforce the shadowing restrictions from RFC 1560 for today's macros\n\nThis PR enforces a weakened version of the shadowing restrictions from RFC 1560. More specifically,\n - If a macro expansion contains a `macro_rules!` macro definition that is used outside of the expansion, the defined macro may not shadow an existing macro.\n - If a macro expansion contains a `#[macro_use] extern crate` macro import that is used outside of the expansion, the imported macro may not shadow an existing macro.\n\nThis is a [breaking-change]. For example,\n```rust\nmacro_rules! m { () => {} }\nmacro_rules! n { () => {\n    macro_rules! m { () => {} } //< This shadows an existing macro.\n    m!(); //< This is inside the expansion that generated `m`'s definition, so it is OK.\n} }\nn!();\nm!(); //< This use of `m` is outside the expansion, so it causes the shadowing to be an error.\n```\n\nr? @nrc"
  },
  {
    "hash": "259d1fcd478f868a9980cdce63f7556f30d55b90",
    "author": "Manish Goregaokar",
    "date": 1475329932,
    "message": "Rollup merge of #36599 - jonas-schievink:whats-a-pirates-favorite-data-structure, r=pnkfelix\n\n Contains a syntax-[breaking-change] as a separate commit (cc #31645).nnAlso renames slice patterns from `PatKind::Vec` to `PatKind::Slice`."
  },
  {
    "hash": "48e5199de366ed2945d1103f0b6c8aa542604ebb",
    "author": "Jonas Schievink",
    "date": 1475094678,
    "message": "libsyntax: clearer names for some AST parts\n\nThis applies the HIR changes from the previous commits to the AST, and\nis thus a syntax-[breaking-change]\n\nRenames `PatKind::Vec` to `PatKind::Slice`, since these are called slice\npatterns, not vec patterns. Renames `TyKind::Vec`, which represents the\ntype `[T]`, to `TyKind::Slice`. Renames `TyKind::FixedLengthVec` to\n`TyKind::Array`."
  },
  {
    "hash": "eee2d04d877fe909309c39b6bdf711dc586d0a1e",
    "author": "bors",
    "date": 1475112667,
    "message": "Auto merge of #36395 - durka:rangeinclusive-no-esi, r=alexcrichton\n\nremove ExactSizeIterator from RangeInclusive<{u,i}{32,size}>\n\nFixes #36386.\n\nThis is a [breaking-change] for nightly users of `#![feature(inclusive_range_syntax)]` and/or `#![feature(inclusive_range)]`."
  },
  {
    "hash": "13a2dd96fe824cc5d61e94ed380db0114efdd014",
    "author": "tormol",
    "date": 1475046210,
    "message": "[breaking-change] std: change `encode_utf{8,16}()` to take a buffer and return a slice\n\nThey panic if the buffer is too small."
  },
  {
    "hash": "b786976a158e79196254f489bb3a6f87e4d16a5a",
    "author": "bors",
    "date": 1474878060,
    "message": "Auto merge of #36730 - jseyfried:make_macro_rules_invocations_magic, r=nrc\n\nForbid user-defined macros named \"macro_rules\"\n\nThis is a [breaking-change].\nr? @nrc"
  },
  {
    "hash": "a0843d7210f41974a0a2bc6876c538718404c268",
    "author": "bors",
    "date": 1474755427,
    "message": "Auto merge of #36657 - nnethercote:rm-TypedArena-with_capacity, r=eddyb\n\n[breaking-change] Remove TypedArena::with_capacity\n\nThis is a follow-up to #36592.\n\nThe function is unused by rustc. Also, it doesn't really follow the\nusual meaning of a `with_capacity` function because the first chunk\nallocation is now delayed until the first `alloc` call.\n\nThis change reduces the size of `TypedArena` by one `usize`.\n\n@eddyb: we discussed this on IRC. Would you like to review it?"
  },
  {
    "hash": "cf50f5f965c3d3dc56fce25f2eaf8f66194f69e4",
    "author": "Nicholas Nethercote",
    "date": 1474576822,
    "message": "[breaking-change] Remove TypedArena::with_capacity.\n\nThe function is unused by rustc. Also, it doesn't really follow the\nusual meaning of a `with_capacity` function because the first chunk\nallocation is now delayed until the first `alloc` call.\n\nThis change reduces the size of `TypedArena` by one `usize`."
  },
  {
    "hash": "7b25e886028195a4f90c0baa5cc9101ebeceb5a3",
    "author": "Ariel Ben-Yehuda",
    "date": 1474027712,
    "message": "forbid moves out of slices\n\nThe wording of RFC #495 enables moves out of slices. Unfortuantely, non-zeroing\nmoves out of slices introduce a very annoying complication: as slices can\nvary in their length, indexes from the start and end may or may not overlap\ndepending on the slice's exact length, which prevents assigning a particular\ndrop flag for each individual element.\n\nFor example, in the code\n\n```Rust\nfn foo<T>(a: Box<[Box<[T]>]>, c: bool) -> T {\n    match (a, c) {\n        (box [box [t, ..], ..], true) => t,\n        (box [.., box [.., t]], false) => t,\n        _ => panic!()\n    }\n}\n```\n\nIf the condition is false, we have to drop the first element\nof `a`, unless `a` has size 1 in which case we drop all the elements\nof it but the last.\n\nIf someone comes with a nice way of handling it, we can always re-allow\nmoves out of slices.\n\nThis is a [breaking-change], but it is behind the `slice_patterns` feature\ngate and was not allowed until recently."
  },
  {
    "hash": "b1363a73ede57ae595f3a1be2bb75d308ba4f7f6",
    "author": "bors",
    "date": 1473804492,
    "message": "Auto merge of #35021 - japaric:rustc-builtins, r=alexcrichton\n\ncrate-ify compiler-rt into compiler-builtins\n\nlibcompiler-rt.a is dead, long live libcompiler-builtins.rlib\n\nThis commit moves the logic that used to build libcompiler-rt.a into a\ncompiler-builtins crate on top of the core crate and below the std crate.\nThis new crate still compiles the compiler-rt instrinsics using gcc-rs\nbut produces an .rlib instead of a static library.\n\nAlso, with this commit rustc no longer passes -lcompiler-rt to the\nlinker. This effectively makes the \"no-compiler-rt\" field of target\nspecifications a no-op. Users of `no_std` will have to explicitly add\nthe compiler-builtins crate to their crate dependency graph *if* they\nneed the compiler-rt intrinsics - this is a [breaking-change]. Users\nof the `std` have to do nothing extra as the std crate depends\non compiler-builtins.\n\nFinally, this a step towards lazy compilation of std with Cargo as the\ncompiler-rt intrinsics can now be built by Cargo instead of having to\nbe supplied by the user by some other method.\n\ncloses #34400\n\n---\n\nr? @alexcrichton"
  },
  {
    "hash": "ecc6c39e876b69496bc88ef47ff3a339662346b1",
    "author": "Alex Crichton",
    "date": 1472845976,
    "message": "rustc: Implement custom derive (macros 1.1)\n\nThis commit is an implementation of [RFC 1681] which adds support to the\ncompiler for first-class user-define custom `#[derive]` modes with a far more\nstable API than plugins have today.\n\n[RFC 1681]: https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\n\nThe main features added by this commit are:\n\n* A new `rustc-macro` crate-type. This crate type represents one which will\n  provide custom `derive` implementations and perhaps eventually flower into the\n  implementation of macros 2.0 as well.\n\n* A new `rustc_macro` crate in the standard distribution. This crate will\n  provide the runtime interface between macro crates and the compiler. The API\n  here is particularly conservative right now but has quite a bit of room to\n  expand into any manner of APIs required by macro authors.\n\n* The ability to load new derive modes through the `#[macro_use]` annotations on\n  other crates.\n\nAll support added here is gated behind the `rustc_macro` feature gate, both for\nthe library support (the `rustc_macro` crate) as well as the language features.\n\nThere are a few minor differences from the implementation outlined in the RFC,\nsuch as the `rustc_macro` crate being available as a dylib and all symbols are\n`dlsym`'d directly instead of having a shim compiled. These should only affect\nthe implementation, however, not the public interface.\n\nThis commit also ended up touching a lot of code related to `#[derive]`, making\na few notable changes:\n\n* Recognized derive attributes are no longer desugared to `derive_Foo`. Wasn't\n  sure how to keep this behavior and *not* expose it to custom derive.\n\n* Derive attributes no longer have access to unstable features by default, they\n  have to opt in on a granular level.\n\n* The `derive(Copy,Clone)` optimization is now done through another \"obscure\n  attribute\" which is just intended to ferry along in the compiler that such an\n  optimization is possible. The `derive(PartialEq,Eq)` optimization was also\n  updated to do something similar.\n\n---\n\nOne part of this PR which needs to be improved before stabilizing are the errors\nand exact interfaces here. The error messages are relatively poor quality and\nthere are surprising spects of this such as `#[derive(PartialEq, Eq, MyTrait)]`\nnot working by default. The custom attributes added by the compiler end up\nbecoming unstable again when going through a custom impl.\n\nHopefully though this is enough to start allowing experimentation on crates.io!\n\nsyntax-[breaking-change]"
  },
  {
    "hash": "147371f58f1a99e32524d61af1d86b2e1e0a503b",
    "author": "bors",
    "date": 1472735104,
    "message": "Auto merge of #34982 - arielb1:bad-tuples-and-objects, r=nikomatsakis\n\nTurn the RFC1592 warnings into hard errors\n\nThe warnings have already reached stable, and I want to improve the trait error reporting code.\n\nTurning warnings into errors, this is obviously a [breaking-change].\n\nr? @nikomatsakis\n\ncc @rust-lang/compiler"
  },
  {
    "hash": "71ee82a8aa0c02fc2c73e84f40bdb55512d10938",
    "author": "bors",
    "date": 1472542579,
    "message": "Auto merge of #36066 - jseyfried:rollup, r=Manishearth\n\nBatch up libsyntax breaking changes\n\nBatch of the following syntax-[breaking-change] changes:\n - #35591: Add a field `span: Span` to `ast::Generics`.\n - #35618: Remove variant `Mod` of `ast::PathListItemKind` and refactor the remaining variant `ast::PathListKind::Ident` to a struct `ast::PathListKind_`.\n - #35480: Change uses of `Constness` in the AST to `Spanned<Constness>`.\n  - c.f. `MethodSig`, `ItemKind`\n - #35728: Refactor `cx.pat_enum()` into `cx.pat_tuple_struct()` and `cx.pat_path()`.\n - #35850: Generalize the elements of lists in attributes from `MetaItem` to a new type `NestedMetaItem` that can represent a `MetaItem` or a literal.\n - #35917: Remove traits `AttrMetaMethods`, `AttributeMethods`, and `AttrNestedMetaItemMethods`.\n  - Besides removing imports of these traits, this won't cause fallout.\n - Add a variant `Union` to `ItemKind` to future proof for `union` (c.f. #36016).\n - Remove inherent methods `attrs` and `fold_attrs` of `Annotatable`.\n  - Use methods `attrs` and `map_attrs` of `HasAttrs` instead.\n\nr? @Manishearth"
  },
  {
    "hash": "312734ca4295f6fa95c70d190ef297f926657155",
    "author": "bors",
    "date": 1472415407,
    "message": "Auto merge of #36029 - KiChjang:issue-12033, r=arielb1\n\nFix lifetime rules for 'if' conditions\n\nFixes #12033.\n\nChanges the temporary scope rules to make the condition of an if-then-else a terminating scope. This is a [breaking-change]."
  },
  {
    "hash": "71bdeea561355ba5adbc9a1f44f4f866a75a15c4",
    "author": "bors",
    "date": 1472149710,
    "message": "Auto merge of #34923 - eddyb:deny-fn-item-transmute, r=nikomatsakis\n\nDeny (by default) transmuting from fn item types to pointer-sized types.\n\nThis sets the #19925 lint (transmute from zero-sized fn item type) to `deny` by default.\nTechnically a `[breaking-change]`, but will not affect dependent crates because of `--cap-lints`."
  },
  {
    "hash": "e9bc1bac8c7664fb1b487879b3fbd56221f6a721",
    "author": "bors",
    "date": 1472075854,
    "message": "Auto merge of #35764 - eddyb:byegone, r=nikomatsakis\n\nRemove the old AST-based backend from rustc_trans.\n\nStarting with Rust 1.13, `--disable-orbit` , `-Z orbit=off` and `#[rustc_no_mir]` have been removed.\nOnly the new MIR backend is left in the compiler, and only early const_eval uses ASTs from other crates.\n\nFilling drop (previously \"zeroing drop\"), `#[unsafe_no_drop_flag]` and associated unstable APIs are gone.\nImplementing `Drop` doesn't add a flag anymore to the type, all of the dynamic drop is function local.\nThis is a [breaking-change], please use `Option::None` and/or `mem::forget` if you are unsure about your ability to prevent/control the drop of a value. In the future, `union` will be usable in some such cases.\n\n**NOTE**: DO NOT MERGE before we get the new beta as the stage0, there's some cruft to remove.\n\nAll of this will massively simplify any efforts to implement (and as such it blocks) features such as `union`s, safe use of `#[packed]` or new type layout optimizations, not to mention many other experiments."
  },
  {
    "hash": "271d048523b6c1b0e773d9e5cc76bbb997cc180c",
    "author": "bors",
    "date": 1470290193,
    "message": "Auto merge of #35015 - petrochenkov:forearg, r=nikomatsakis\n\nProperly enforce the \"patterns aren't allowed in foreign functions\" rule\n\nCases like `arg @ PATTERN` or `mut arg` were missing.\nApply the same rule to function pointer types.\n\nCloses https://github.com/rust-lang/rust/issues/35203\n[breaking-change], no breakage in sane code is expected though\nr? @nikomatsakis\n\nThis is somewhat related to https://github.com/rust-lang/rfcs/pull/1685 (cc @matklad).\nThe goal is to eventually support full pattern syntax where it makes sense (function body may present) and to support *only* the following forms - `TYPE`, `ident: TYPE`, `_: TYPE` - where patterns don't make sense (function body doesn't present), i.e. in foreign functions and function pointer types."
  },
  {
    "hash": "81df89fc2d6ba1b55ab20b0615b8523a6e90963f",
    "author": "Ariel Ben-Yehuda",
    "date": 1470226127,
    "message": "remove the ExecutionEngine binding\n\nthe code has no tests and will just bitrot by itself.\n\nthis is a [breaking-change]"
  },
  {
    "hash": "7333c4ac25648e831fb2033ee77fbbdc62ae492a",
    "author": "bors",
    "date": 1470001318,
    "message": "Auto merge of #35143 - arielb1:rfc447-regions, r=eddyb\n\ntypeck: use a TypeVisitor in ctp\n\nUse a TypeVisitor in ctp instead of `ty::walk`\n\nThis fixes a few cases where a region could be projected out of a trait while not being constrained by the type parameters, violating rust-lang/rfcs#447 and breaking soundness. As such, this is a [breaking-change].\n\nFixes #35139\n\nr? @eddyb"
  },
  {
    "hash": "1225e122fda8cfbe3a5da6007e912f204b97f8c4",
    "author": "bors",
    "date": 1469919500,
    "message": "Auto merge of #34904 - petrochenkov:rustcall, r=nikomatsakis\n\nProperly feature gate all unstable ABIs\n\nFixes https://github.com/rust-lang/rust/issues/34900\n[breaking-change]\nr? @pnkfelix\n\n---\nFunction-visiting machinery for AST/HIR is surprisingly error-prone, it's *very* easy to miss some cases or visit something twice while writing a visitor. This is the true problem behind https://github.com/rust-lang/rust/issues/34900. I'll try to restructure these visitors a bit and send one more PR later."
  },
  {
    "hash": "2ab18ce6f7e147a71e953b9a01ed09aff6b95972",
    "author": "bors",
    "date": 1468399027,
    "message": "Auto merge of #34660 - jseyfried:fix_parse_stmt, r=nrc\n\nFix bugs in macro-expanded statement parsing\n\nFixes #34543.\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m { () => {\n    println!(\"\") println!(\"\")\n    //^ Semicolons are now required on macro-expanded non-braced macro invocations\n    //| in statement positions.\n    let x = 0\n    //^ Semicolons are now required on macro-expanded `let` statements\n    //| that are followed by more statements, so this would break.\n    let y = 0 //< (this would still be allowed to reduce breakage in the wild)\n}\nfn main() { m!() }\n```\n\nr? @eddyb"
  },
  {
    "hash": "f93aaf84cb50dfaaba44b08c05bd51320263f592",
    "author": "bors",
    "date": 1468102581,
    "message": "Auto merge of #34365 - petrochenkov:deferr, r=eddyb\n\nSome more pattern cleanup and bugfixing\n\nThe next part of https://github.com/rust-lang/rust/pull/34095\n\nThe most significant fixed mistake is definitions for partially resolved associated types not being updated after full resolution.\n```\nfn f<T: Fn()>(arg: T::Output) { .... } // <- the definition of T::Output was not updated in def_map\n```\nFor this reason unstable associated types of stable traits, like `FnOnce::Output`, could be used in stable code when written in unqualified form. Now they are properly checked, this is a **[breaking-change]** (pretty minor one, but a crater run would be nice). The fix is not to use unstable library features in stable code, alternatively `FnOnce::Output` can be stabilized.\n\nBesides that, paths in struct patterns and expressions `S::A { .. }` are now fully resolved as associated types. Such types cannot be identified as structs at the moment, i.e. the change doesn't make previously invalid code valid, but it improves error diagnostics.\n\nOther changes: `Def::Err` is supported better (less chances for ICEs for erroneous code), some incorrect error messages are corrected, some duplicated error messages are not reported, ADT definitions are now available through constructor IDs, everything else is cleanup and code audit.\n\nFixes https://github.com/rust-lang/rust/issues/34209\nCloses https://github.com/rust-lang/rust/issues/22933 (adds tests)\n\nr? @eddyb"
  },
  {
    "hash": "de78655bca47cac8e783dbb563e7e5c25c1fae40",
    "author": "bors",
    "date": 1467860651,
    "message": "Auto merge of #34652 - jseyfried:fix_expansion_perf, r=nrc\n\nFix expansion performance regression\n\n**syntax-[breaking-change] cc #31645**\n\nThis fixes #34630 by reverting commit 5bf7970 of PR #33943, which landed in #34424.\n\nBy removing the `Rc<_>` wrapping around `Delimited` and `SequenceRepetition` in `TokenTree`, 5bf7970 made cloning `TokenTree`s more expensive. While this had no measurable performance impact on the compiler's crates, it caused an order of magnitude performance regression on some macro-heavy code in the wild. I believe this is due to clones of `TokenTree`s in `macro_parser.rs` and/or `macro_rules.rs`.\n\nr? @nrc"
  },
  {
    "hash": "47380768e7debc2ee6b66e491733b89534e80988",
    "author": "bors",
    "date": 1467790491,
    "message": "Auto merge of #34546 - jseyfried:cfg_attr_path, r=nrc\n\nSupport `cfg_attr` on `path` attributes\n\nFixes #25544.\nThis is technically a [breaking-change]. For example, the following would break:\n```rust\nmod foo; // Suppose `foo.rs` existed in the appropriate location\n```"
  },
  {
    "hash": "e85adffd6402acce79887e1b911ff33841c6133a",
    "author": "bors",
    "date": 1467477412,
    "message": "Auto merge of #34443 - eddyb:sized-matters, r=arielb1\n\nDisallow constants and statics from having unsized types.\n\nThis is a `[breaking-change]` which fixes #34390 by banning unsized `const` and `static`, e.g.:\n```rust\nconst A: [i32] = *(&[0, 1, 2] as &[i32]);\nstatic B: str = *\"foo\";\n```\n\nThis was not intentionally allowed, and other than for `static` since some versions ago, it ICE'd.\nIf you've been taking advantage of this with `static`, you should be able to just use references instead."
  },
  {
    "hash": "8886818a9ab3e6c52651038d4e22e2d51b932bb9",
    "author": "Manish Goregaokar",
    "date": 1467215482,
    "message": "Rollup merge of #34495 - jseyfried:only_ident_macro_invocations, r=eddyb\n\nForbid type parameters and global paths in macro invocations\n\nFixes #28558.\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m { () => { () } }\nfn main() {\n    m::<T>!(); // Type parameters are no longer allowed in macro invocations\n    ::m!(); // Global paths are no longer allowed in macro invocations\n}\n```\nAny breakage can be fixed by removing the type parameters or the leading `::` (respectively).\n\nr? @eddyb"
  },
  {
    "hash": "ea0dc9297283daff6486807f43e190b4eb561412",
    "author": "bors",
    "date": 1467070923,
    "message": "Auto merge of #34424 - jseyfried:breaking_batch, r=Manishearth\n\nBatch up libsyntax breaking changes\n\nBatch of the following syntax-[breaking-change] changes:\n - #34213: Add a variant `Macro` to `TraitItemKind`\n - #34368: Merge the variant `QPath` of `PatKind` into the variant `PatKind::Path`\n - #34385: Move `syntax::ast::TokenTree` into a new module `syntax::tokenstream`\n - #33943:\n  - Remove the type parameter from `visit::Visitor`\n  - Remove `attr::WithAttrs` -- use `attr::HasAttrs` instead.\n  - Change `fold_tt`/`fold_tts` to take token trees by value and avoid wrapping token trees in `Rc`.\n  - Remove the field `ctxt` of `ast::Mac_`\n  - Remove inherent method `attrs()` of types -- use the method `attrs` of `HasAttrs` instead.\n - #34316:\n  - Remove `ast::Decl`/`ast::DeclKind` and add variants `Local` and `Item` to `StmtKind`.\n  - Move the node id for statements from the `StmtKind` variants to a field of `Stmt` (making `Stmt` a struct instead of an alias for `Spanned<StmtKind>`)\n  - Rename `ast::ExprKind::Again` to `Continue`.\n - #34339: Generalize and abstract `ThinAttributes` to `ThinVec<Attribute>`\n  - Use `.into()` in convert between `Vec<Attribute>` and `ThinVec<Attribute>`\n  - Use autoderef instead of `.as_attr_slice()`\n - #34436: Remove the optional expression from `ast::Block` and instead use a `StmtKind::Expr` at the end of the statement list.\n - #34403: Move errors into a separate crate (unlikely to cause breakage)"
  },
  {
    "hash": "af2fe634bfa770e7da675210aa661a96cde51275",
    "author": "bors",
    "date": 1466992932,
    "message": "Auto merge of #34491 - eddyb:return-in-peace, r=nagisa\n\nRemove the return_address intrinsic.\n\nThis intrinsic to get the return pointer was introduced in #16248 / #16081 by @pcwalton for Servo.\nHowever, as explained in #34227, it's impossible to ensure it's used correctly, and it broke with `-Zorbit`.\n\nServo's usage is being replaced in servo/servo#11872, and I expect nobody else to have abused it.\nBut I've also started a crater run, just in case this is a `[breaking-change]` for anyone else."
  },
  {
    "hash": "82a15a6a0af724e71004c735f8a99ec5f2a03920",
    "author": "Jeffrey Seyfried",
    "date": 1466907119,
    "message": "Rollup merge of #34385 - cgswords:tstream, r=nrc\n\nsyntax-[breaking-change] cc #31645\n(Only breaking because ast::TokenTree is now tokenstream::TokenTree.)\n\nThis pull request refactors TokenTrees into their own file as src/libsyntax/tokenstream.rs, moving them out of src/libsyntax/ast.rs, in order to prepare for an accompanying TokenStream implementation (per RFC 1566)."
  },
  {
    "hash": "4e2e31c11837f244e5039165b777ddedde5dc44d",
    "author": "Jeffrey Seyfried",
    "date": 1466894106,
    "message": "Rollup merge of #34368 - petrochenkov:astqpath, r=Manishearth\n\nThe AST part of https://github.com/rust-lang/rust/pull/34365\n\nplugin-[breaking-change] cc https://github.com/rust-lang/rust/issues/31645"
  },
  {
    "hash": "f0310e061b9d0a7d8dc515390fa68dfb6318df4b",
    "author": "Jeffrey Seyfried",
    "date": 1466894101,
    "message": "Rollup merge of #34213 - josephDunne:trait_item_macros, r=jseyfried\n\n**syntax-[breaking-change]** cc #31645\nNew `TraitItemKind::Macro` variant\n\nThis change adds support for macro expansion inside trait items by adding the new `TraitItemKind::Macro` and associated parsing code."
  },
  {
    "hash": "6edea2cfda2818f0a76f4bac2d18a30feb54c137",
    "author": "bors",
    "date": 1466074195,
    "message": "Auto merge of #34216 - jseyfried:nested_cfg_attr, r=nrc\n\nSupport nested `cfg_attr` attributes\n\nSupport arbitrarily deeply nested `cfg_attr` attributes (e.g. `#[cfg_attr(foo, cfg_attr(bar, baz))]`).\nThis makes configuration idempotent.\n\nCurrently, the nighties do not support any `cfg_attr` nesting. Stable and beta support just one level of `cfg_attr` nesting (expect for attributes on macro-expanded nodes, where no nesting is supported).\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m { () => {\n    #[cfg_attr(all(), cfg_attr(all(), cfg(foo)))]\n    fn f() {}\n} }\nm!();\n\nfn main() { f() } //~ ERROR unresolved name `f`\n```\nr? @nrc"
  },
  {
    "hash": "a94881563c18e4ffca2e24aed4bd8f5de583cc91",
    "author": "bors",
    "date": 1465991309,
    "message": "Auto merge of #34180 - durka:patch-24, r=brson\n\nderive Hash (and not Copy) for ranges\n\nFixes #34170.\n\nAlso, `RangeInclusive` was `Copy` by mistake -- fix that, which is a [breaking-change] to that unstable type."
  },
  {
    "hash": "7d2f75a953b5645d3a336b2978b48b60d310bf54",
    "author": "bors",
    "date": 1465512517,
    "message": "Auto merge of #34095 - petrochenkov:pathir2, r=jseyfried\n\nImprovements to pattern resolution + some refactoring\n\nContinuation of https://github.com/rust-lang/rust/pull/33929\nFirst commit is a careful rewrite of `resolve_pattern`, pattern path resolution and new binding creation logic is factored out in separate functions, some minor bugs are fixed. Also, `resolve_possibly_assoc_item` doesn't swallow modules now.\nLater commits are refactorings, see the comment descriptions.\n\nI intend to continue this work later with better support for `Def::Err` in patterns in post-resolve stages and cleanup of pattern resolution code in type checker.\n\nFixes https://github.com/rust-lang/rust/issues/32086\nFixes https://github.com/rust-lang/rust/issues/34047 ([breaking-change])\nFixes https://github.com/rust-lang/rust/issues/34074\n\ncc @jseyfried\nr? @eddyb"
  },
  {
    "hash": "9e78cd73b5c4254efda9fe57be56b8b374383812",
    "author": "Alex Burka",
    "date": 1465493162,
    "message": "make RangeInclusive Hash and !Copy\n\n[breaking-change] due to the removal of Copy which shouldn't have been there in the first place, as per policy set forth in #27186."
  },
  {
    "hash": "dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf",
    "author": "bors",
    "date": 1465451135,
    "message": "Auto merge of #34032 - jseyfried:load_macros_in_expansion, r=nrc\n\nSupport `#[macro_use]` on macro-expanded crates\n\nThis PR loads macros from `#[macro_use]` crates during expansion so that\n - macro-expanded `#[macro_use]` crates work (fixes #33936, fixes #28071), and\n - macros imported from crates have the same scope as macros imported from modules.\n\nThis is a [breaking-change]. For example, this will break:\n```rust\nmacro_rules! m {\n    () => { #[macro_use(foo)] extern crate core; } //~ ERROR imported macro not found\n}\nm!();\n```\nAlso, this will break:\n```rust\nmacro_rules! try { () => {} }\n// #[macro_use] mod bar { macro_rules! try { ... } } //< ... just like this would ...\nfn main() { try!(); } //< ... making this an error\n```\n\nr? @nrc"
  },
  {
    "hash": "bb4b3fb7f97924919f072ec9a360bdf943218dbf",
    "author": "bors",
    "date": 1465439433,
    "message": "Auto merge of #32202 - arielb1:slice-patterns, r=nikomatsakis\n\nImplement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns.\n\n[RFC 495 text](https://github.com/rust-lang/rfcs/blob/master/text/0495-array-pattern-changes.md)"
  },
  {
    "hash": "5c717a6fc21594569d9e64968cdcf2e88e372a07",
    "author": "Ariel Ben-Yehuda",
    "date": 1465421918,
    "message": "implement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns."
  },
  {
    "hash": "814f685df21439ab6eab83f421d4b60cab026a0b",
    "author": "Steve Klabnik",
    "date": 1465310638,
    "message": "Rollup merge of #34124 - jonas-schievink:remove-useless-optns, r=sanxiyn\n\nRemove old -Z options that do nothing\n\nTechnically, this is a [breaking-change], but I'm not sure what the policy for -Z flags is (especially unused ones)."
  },
  {
    "hash": "6e2f966f729821ebc85fdca6a426493d6d2178ce",
    "author": "Jonas Schievink",
    "date": 1465249424,
    "message": "Remove old -Z options that do nothing\n\nTechnically, this is a [breaking-change], but I'm not sure what the\npolicy for -Z flags is (especially unused ones)."
  },
  {
    "hash": "12d16599d84c25899f02a6e53110d1e70cdcbd8a",
    "author": "bors",
    "date": 1464801715,
    "message": "Auto merge of #33814 - lambda:rtabort-use-platform-abort, r=alexcrichton\n\nOpen code the __fastfail intrinsic for rtabort! on windows\n\nAs described https://msdn.microsoft.com/en-us/library/dn774154.aspx\n\nThis is a Windows 8+ mechanism for terminating the process quickly,\nwhich degrades to either an access violation or bugcheck in older versions.\n\nI'm not sure this is better the the current mechanism of terminating\nwith an illegal instruction, but we recently converted unix to\nterminate more correctly with SIGABORT, and this *seems* more correct\nfor windows.\n\n[breaking-change]"
  },
  {
    "hash": "c2cab1fd58d6373582da189bd2c20ed3f6a7042a",
    "author": "bors",
    "date": 1464787313,
    "message": "Auto merge of #33794 - petrochenkov:sanity, r=nrc\n\nAdd AST validation pass and move some checks to it\n\nThe purpose of this pass is to catch constructions that fit into AST data structures, but not permitted by the language. As an example, `impl`s don't have visibilities, but for convenience and uniformity with other items they are represented with a structure `Item` which has `Visibility` field.\n\nThis pass is intended to run after expansion of macros and syntax extensions (and before lowering to HIR), so it can catch erroneous constructions that were generated by them. This pass allows to remove ad hoc semantic checks from the parser, which can be overruled by syntax extensions and occasionally macros.\n\nThe checks can be put here if they are simple, local, don't require results of any complex analysis like name resolution or type checking and maybe don't logically fall into other passes. I expect most of errors generated by this pass to be non-fatal and allowing the compilation to proceed.\n\nI intend to move some more checks to this pass later and maybe extend it with new checks, like, for example, identifier validity. Given that syntax extensions are going to be stabilized in the measurable future, it's important that they would not be able to subvert usual language rules.\n\nIn this patch I've added two new checks - a check for labels named `'static` and a check for lifetimes and labels named `'_`. The first one gives a hard error, the second one - a future compatibility warning.\nFixes https://github.com/rust-lang/rust/issues/33059 ([breaking-change])\ncc https://github.com/rust-lang/rfcs/pull/1177\n\nr? @nrc"
  },
  {
    "hash": "8b012ed142f03c9082773f5091c58c82d47cae79",
    "author": "bors",
    "date": 1464396374,
    "message": "Auto merge of #33706 - jseyfried:refactor_cfg, r=nrc\n\nPerform `cfg` attribute processing during macro expansion and fix bugs\n\nThis PR refactors `cfg` attribute processing and fixes bugs. More specifically:\n - It merges gated feature checking for stmt/expr attributes, `cfg_attr` processing, and `cfg` processing into a single fold.\n  - This allows feature gated `cfg` variables to be used in `cfg_attr` on unconfigured items. All other feature gated attributes can already be used on unconfigured items.\n - It performs `cfg` attribute processing during macro expansion instead of after expansion so that macro-expanded items are configured the same as ordinary items. In particular, to match their non-expanded counterparts,\n  - macro-expanded unconfigured macro invocations are no longer expanded,\n  - macro-expanded unconfigured macro definitions are no longer usable, and\n  - feature gated `cfg` variables on macro-expanded macro definitions/invocations are now errors.\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m {\n    () => {\n        #[cfg(attr)]\n        macro_rules! foo { () => {} }\n        foo!(); // This will be an error\n\n        macro_rules! bar { () => { fn f() {} } }\n        #[cfg(attr)] bar!(); // This will no longer be expanded ...\n        fn g() { f(); } // ... so that `f` will be unresolved.\n\n        #[cfg(target_thread_local)] // This will be a gated feature error\n        macro_rules! baz { () => {} }\n    }\n}\n\nm!();\n```\n\nr? @nrc"
  },
  {
    "hash": "7905452f083ab5ac3008dfe6727048e70bbeb142",
    "author": "Manish Goregaokar",
    "date": 1464323231,
    "message": "Rollup merge of #33644 - petrochenkov:selfast, r=nrc\n\n The AST part of https://github.com/rust-lang/rust/pull/33505.\nhttps://github.com/rust-lang/rust/pull/33505 isn't landed yet, so this PR is based on top of it.\n\nr? @nrc\n\nplugin-[breaking-change] cc #31645 @Manishearth"
  },
  {
    "hash": "35785712cd5e1acbfebd168c045b2e184ae979cc",
    "author": "Manish Goregaokar",
    "date": 1464323220,
    "message": "Rollup merge of #33639 - petrochenkov:dotdot, r=nmatsakis\n\n cc https://github.com/rust-lang/rust/issues/33627\nr? @nikomatsakis\n\nplugin-[breaking-change] cc https://github.com/rust-lang/rust/issues/31645 @Manishearth"
  },
  {
    "hash": "696a570a00db2528b7934be32da7d8334738a997",
    "author": "Brian Anderson",
    "date": 1464094563,
    "message": "Open code the __fastfail intrinsic for rtabort! on windows\n\nAs described https://msdn.microsoft.com/en-us/library/dn774154.aspx\n\nThis is a Windows 8+ mechanism for terminating the process quickly,\nwhich degrades to either an access violation or bugcheck in older versions.\n\nI'm not sure this is better the the current mechanism of terminating\nwith an illegal instruction, but we recently converted unix to\nterminate more correctly with SIGABORT, and this *seems* more correct\nfor windows.\n\n[breaking-change]"
  },
  {
    "hash": "6e455640950c4e8cb8bff919edb4854fcf7773ca",
    "author": "bors",
    "date": 1463984051,
    "message": "Auto merge of #31457 - lambda:rtabort-use-libc-abort, r=alexcrichton\n\nUse libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333"
  },
  {
    "hash": "cfc386583291c8868d093d07431a57a20e69c944",
    "author": "Brian Campbell",
    "date": 1463977361,
    "message": "Use libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333"
  },
  {
    "hash": "b711734a5f7280cc3ceb99e09551a7b7691c7d0b",
    "author": "Niko Matsakis",
    "date": 1463580645,
    "message": "thread the DepGraph to session/crate-store\n\nThis is a [breaking-change] for plugin authors.\nYou must now create a dep-graph earlier."
  },
  {
    "hash": "2237e899084f16f61e4a74c191a74c7bb2fd3727",
    "author": "Niko Matsakis",
    "date": 1463580645,
    "message": "remove the `Any` bound from `CrateStore`\n\nThis is a [breaking-change] for plugins, which\nought by now to have stopped relying on downcasting."
  },
  {
    "hash": "1ec22171e6053c640293067418ea1901cb1c7df1",
    "author": "bors",
    "date": 1462692700,
    "message": "Auto merge of #33130 - eddyb:mir-const, r=nikomatsakis\n\nImplement constant support in MIR.\n\nAll of the intended features in `trans::consts` are now supported by `mir::constant`.\nThe implementation is considered a temporary measure until `miri` replaces it.\n\nA `-Z orbit` bootstrap build will only translate LLVM IR from AST for `#[rustc_no_mir]` functions.\n\nFurthermore, almost all checks of constant expressions have been moved to MIR.\nIn non-`const` functions, trees of temporaries are promoted, as per RFC 1414 (rvalue promotion).\nPromotion before MIR borrowck would allow reasoning about promoted values' lifetimes.\n\nThe improved checking comes at the cost of four `[breaking-change]`s:\n* repeat counts must contain a constant expression, e.g.:\n`let arr = [0; { println!(\"foo\"); 5 }];` used to be allowed (it behaved like `let arr = [0; 5];`)\n* dereference of a reference to a `static` cannot be used in another `static`, e.g.:\n`static X: [u8; 1] = [1]; static Y: u8 = (&X)[0];` was unintentionally allowed before\n* the type of a `static` *must* be `Sync`, irrespective of the initializer, e.g.\n`static FOO: *const T = &BAR;` worked as `&T` is `Sync`, but it shouldn't because `*const T` isn't\n* a `static` cannot wrap `UnsafeCell` around a type that *may* need drop, e.g.\n`static X: MakeSync<UnsafeCell<Option<String>>> = MakeSync(UnsafeCell::new(None));`\nwas previously allowed based on the fact `None` alone doesn't need drop, but in `UnsafeCell`\nit can be later changed to `Some(String)` which *does* need dropping\n\nThe drop restrictions are relaxed by RFC 1440 (#33156), which is implemented, but feature-gated.\nHowever, creating `UnsafeCell` from constants is unstable, so users can just enable the feature gate."
  },
  {
    "hash": "2f8f256cef42350af2f0376891fd020b6b1c37de",
    "author": "Ariel Ben-Yehuda",
    "date": 1462289410,
    "message": "require the existential bounds of an object type to be object-safe\n\nThis is required, as Copy and Sized are object-unsafe.\n\nAs a soundness fix, this is a [breaking-change]\n\nFixes #32963"
  },
  {
    "hash": "0a6dfc51777eb388b6e795399bf1d3f8aac57db8",
    "author": "Ariel Ben-Yehuda",
    "date": 1462289410,
    "message": "require the non-last elements of a tuple to be Sized\n\nThis requirement appears to be missing from RFC1214, but is clearly\nnecessary for translation. The last field of a tuple/enum remains in\na state of limbo, compiling but causing an ICE when it is used - we\nshould eventually fix that somehow.\n\nthis is a [breaking-change] - a soundness fix - and requires a\ncrater run."
  },
  {
    "hash": "c1c6e99bfd3296954a192d9fe3151a222dd9045c",
    "author": "Nick Cameron",
    "date": 1462230909,
    "message": "rebasing\n\nNote that this whole PR is a [breaking-change] for clients of the Compiler API."
  },
  {
    "hash": "a31658de51444d1b5193ac203a1bd7ace5621f93",
    "author": "Manish Goregaokar",
    "date": 1461525464,
    "message": "Rollup merge of #33041 - petrochenkov:path, r=nrc,Manishearth\n\n Paths are mostly parsed without taking whitespaces into account, e.g. `std :: vec :: Vec :: new ()` parses successfully, however, there are some special cases involving keywords `super`, `self` and `Self`. For example, `self::` is considered a path start only if there are no spaces between `self` and `::`. These restrictions probably made sense when `self` and friends weren't keywords, but now they are unnecessary.\n\nThe first two commits remove this special treatment of whitespaces by removing `token::IdentStyle` entirely and therefore fix https://github.com/rust-lang/rust/issues/14109.\nThis change also affects naked `self` and `super` (which are not tightly followed by `::`, obviously) they can now be parsed as paths, however they are still not resolved correctly in imports (cc @jseyfried, see `compile-fail/use-keyword.rs`), so https://github.com/rust-lang/rust/issues/29036 is not completely fixed.\n\nThe third commit also makes `super`, `self`, `Self` and `static` keywords nominally (before this they acted as keywords for all purposes) and removes most of remaining \\\"special idents\\\".\n\nThe last commit (before tests) contains some small improvements - some qualified paths with type parameters are parsed correctly, `parse_path` is not used for parsing single identifiers, imports are sanity checked for absence of type parameters - such type parameters can be generated by syntax extensions or by macros when https://github.com/rust-lang/rust/issues/10415 is fixed (~~soon!~~already!).\n\nThis patch changes some pretty basic things in `libsyntax`, like `token::Token` and the keyword list, so it's a plugin-[breaking-change].\n\nr? @eddyb"
  }
]
