[
  {
    "hash": "323c20c8a4747aa96285c90005a00aa43228af8e",
    "author": "Oliver 'ker' Schneider",
    "date": 1478867770,
    "message": "[breaking-change] change the `box_free` item to accept pointers to unsized types"
  },
  {
    "hash": "ab03f855221d83ad13120b309506488f4a34cb0f",
    "author": "bors",
    "date": 1478772345,
    "message": "Auto merge of #37463 - jseyfried:refactor_macro_reexports, r=nrc\n\nmacros: improve reexports\n\nThis PR\n- avoids building multiple module graphs for a crate that is referenced by multiple `extern crate` items,\n- registers `#[no_link] extern crate`s to avoid loading the same crate metadata twice,\n- stability checks `#[no_link] extern crate`s,\n  - [breaking-chage]: `#[no_link] #[macro_use] extern crate syntax;` is allowed on stable today\n- fixes `$crate` in `#[macro_reexport]`ed macros,\n  - [breaking-change] for `#[feature(macro_reexport)]` (technically)\n- allows selective macro importing (i.e. `#[macro_use(foo, bar)]`) from custom derive crates, and\n- refactors the crate metadata to support re-exported macros in arbitrary modules (not yet needed).\n\nr? @nrc"
  },
  {
    "hash": "09fc1af9d80ecb71c82367b6569461e645a3a946",
    "author": "bors",
    "date": 1478488348,
    "message": "Auto merge of #37506 - jseyfried:improve_shadowing_checks, r=nrc\n\nmacros: improve shadowing checks\n\nThis PR improves macro-expanded shadowing checks to work with out-of-(pre)order expansion.\n\nOut-of-order expansion became possible in #37084, so this technically a [breaking-change] for nightly.\nThe regression test from this PR is an example of code that would break.\n\nr? @nrc"
  },
  {
    "hash": "ccfc38f034e3f53cb460936bd9744085d4a63b40",
    "author": "bors",
    "date": 1478269244,
    "message": "Auto merge of #37167 - nikomatsakis:jroesch-issue-18937, r=pnkfelix\n\ndetect extra region requirements in impls\n\nThe current \"compare method\" check fails to check for the \"region obligations\" that accrue in the fulfillment context. This branch switches that code to create a `FnCtxt` so that it can invoke the regionck code. Previous crater runs (I haven't done one with the latest tip) have found some small number of affected crates, so I went ahead and introduced a warning cycle. I will kick off a crater run with this branch shortly.\n\nThis is a [breaking-change] because previously unsound code was accepted. The crater runs also revealed some cases where legitimate code was no longer type-checking, so the branch contains one additional (but orthogonal) change. It improves the elaborator so that we elaborate region requirements more thoroughly. In particular, if we know that `&'a T: 'b`, we now deduce that `T: 'b` and `'a: 'b`.\n\nI invested a certain amount of effort in getting a good error message. The error message looks like this:\n\n```\nerror[E0276]: impl has stricter requirements than trait\n  --> traits-elaborate-projection-region.rs:33:5\n   |\n21 |     fn foo() where T: 'a;\n   |     --------------------- definition of `foo` from trait\n...\n33 |     fn foo() where U: 'a { }\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `U: 'a`\n   |\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #18937 <https://github.com/rust-lang/rust/issues/18937>\nnote: lint level defined here\n  --> traits-elaborate-projection-region.rs:12:9\n   |\n12 | #![deny(extra_requirement_in_impl)]\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nObviously the warning only prints if this is a _new_ error (that resulted from the bugfix). But all existing errors that fit this description are updated to follow the general template. In order to get the lint to preserve the span-labels and the error code, I separate out the core `Diagnostic` type (which encapsulates the error code, message, span, and children) from the `DiagnosticBuilder` (which layers on a `Handler` that can be used to report errors). I also extended `add_lint` with an alternative `add_lint_diagnostic` that takes in a full diagnostic (cc @jonathandturner for those changes). This doesn't feel ideal but feels like it's moving in the right direction =).\n\nr? @pnkfelix\ncc @arielb1\n\nFixes #18937"
  },
  {
    "hash": "d00e5e9343a11939c80c0ade5ca71c8dcbc31847",
    "author": "Jonathan Turner",
    "date": 1478113781,
    "message": "Rollup merge of #37351 - Amanieu:consume, r=alexcrichton\n\nPrevent exhaustive matching of Ordering to allow for future extension\n\nThe C++11 atomic memory model defines a `memory_order_consume` ordering which is generally equivalent to `memory_order_acquire` but can allow better code generation by avoiding memory barrier instructions. Most compilers (including LLVM) currently do not implement this ordering directly and instead treat it identically to `memory_order_acquire`, including adding a memory barrier instruction.\n\nThere is currently [work](http://open-std.org/Jtc1/sc22/wg21/docs/papers/2016/p0098r1.pdf) to support consume ordering in compilers, and it would be a shame if Rust did not support this. This PR therefore reserves a `__Nonexhaustive` variant in `Ordering` so that adding a new ordering is not a breaking change in the future.\n\nThis is a [breaking-change] since it disallows exhaustive matching on `Ordering`, however a search of all Rust code on Github shows that there is no code that does this. This makes sense since `Ordering` is typically only used as a parameter to an atomic operation."
  },
  {
    "hash": "6062e7ed3d81cb3bd535993e9b14269924b76c29",
    "author": "bors",
    "date": 1477835490,
    "message": "Auto merge of #37431 - jseyfried:refactor_crate_config, r=eddyb\n\nMove `CrateConfig` from `Crate` to `ParseSess`\n\nThis is a syntax-[breaking-change]. Most breakage can be fixed by removing a `CrateConfig` argument.\nr? @eddyb"
  },
  {
    "hash": "aef18be1bc4e03617177c5e9df1164ce3df49ba2",
    "author": "bors",
    "date": 1477424263,
    "message": "Auto merge of #37111 - TimNN:sized-enums, r=nikomatsakis\n\nDisallow Unsized Enums\n\nFixes #16812.\n\nThis PR is a potential fix for #16812, an issue which is reported [again](https://github.com/rust-lang/rust/issues/36801) and [again](https://github.com/rust-lang/rust/issues/36975), with over a dozen duplicates by now.\n\nThis PR is mainly meant to promoted discussion about the issue and the correct way to fix it.\n\nThis is a [breaking-change] since the error is now reported during wfchecking, so that even the definition of a (potentially) unsized enum will cause an error (whereas it would previously cause an ICE at trans time if the enum was used in an unsized manner)."
  },
  {
    "hash": "da5b6467c33f7f86b4964b08b37726f7611a8f0c",
    "author": "bors",
    "date": 1477039711,
    "message": "Auto merge of #37247 - jseyfried:future_proof_no_link, r=nrc\n\nmacros: Future proof `#[no_link]`\n\nThis PR future proofs `#[no_link]` for macro modularization (cc #35896).\n\nFirst, we resolve all `#[no_link] extern crate`s. `#[no_link]` crates without `#[macro_use]` or `#[macro_reexport]` are not resolved today, this is a [breaking-change]. For example,\n```rust\n```\nAny breakage can be fixed by simply removing the `#[no_link] extern crate`.\n\nSecond, `#[no_link] extern crate`s will define an empty module in type namespace to eventually allow importing the crate's macros with `use`. This is a [breaking-change], for example:\n```rust\nmod syntax {} //< This becomes a duplicate error.\n```\n\nr? @nrc"
  },
  {
    "hash": "cfc9b5185bbf5ab04a2736347bfa7fd9ab70c1e7",
    "author": "bors",
    "date": 1476883990,
    "message": "Auto merge of #37213 - jseyfried:refactor_crate_var, r=nrc\n\nmacros: improve `$crate`\n\nThis PR refactors the implementation of `$crate` so that\n - `$crate` is only allowed at the start of a path (like `super`),\n - we can make `$crate` work with inter-crate re-exports (groundwork for macro modularization), and\n - we can support importing macros from an extern crate that is not declared at the crate root (also groundwork for macro modularization).\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nfn foo() {}\nmacro_rules! m { () => {\n    $crate foo $crate () $crate $crate;\n    //^ Today, `$crate` is allowed just about anywhere in unexported macros.\n} }\nfn main() {\n    m!();\n}\n```\nr? @nrc"
  },
  {
    "hash": "e2631208b1888d6a340938314457446a7f8ed2fc",
    "author": "Nicholas Nethercote",
    "date": 1475618255,
    "message": "Rename StringReader::curr as ch.\n\nLikewise, rename StringReader::curr_is as ch_is.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "cb92f5c6d6e09a7c1575241a05df15c96ca3b531",
    "author": "Nicholas Nethercote",
    "date": 1475618217,
    "message": "Rename StringReader::last_pos as pos.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "94565a4409f8b8a133db36d3a22221b5b38a1a13",
    "author": "Nicholas Nethercote",
    "date": 1475618125,
    "message": "Rename StringReader::pos as next_pos.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "3c4c85947cddac2d36854e5bf8c7a8edb32e1245",
    "author": "Nicholas Nethercote",
    "date": 1475617998,
    "message": "Rename Parser::last_token_kind as prev_token_kind.\n\nLikewise, rename LastTokenKind as PrevTokenKind.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "2747923c272a355dbb6265586a884652e26b0ec7",
    "author": "Nicholas Nethercote",
    "date": 1475617998,
    "message": "Rename Parser::last_span as prev_span.\n\nThis is a [breaking-change] for libsyntax."
  },
  {
    "hash": "20991829e2639d1786acbd52621b220c89f0d9cb",
    "author": "Alex Crichton",
    "date": 1476306476,
    "message": "Rollup merge of #37084 - jseyfried:cleanup_expanded_macro_use_scopes, r=nrc\n\nmacros: clean up scopes of expanded `#[macro_use]` imports\n\nThis PR changes the scope of macro-expanded `#[macro_use]` imports to match that of unexpanded `#[macro_use]` imports. For example, this would be allowed:\n```rust\nexample!();\nmacro_rules! m { () => { #[macro_use(example)] extern crate example_crate; } }\nm!();\n```\n\nThis PR also enforces the full shadowing restrictions from RFC 1560 on `#[macro_use]` imports (currently, we only enforce the weakened restrictions from #36767).\n\nThis is a [breaking-change], but I believe it is highly unlikely to cause breakage in practice.\nr? @nrc"
  },
  {
    "hash": "f05bd1b41ddda779032f4c5c8e30bf640129832f",
    "author": "Alex Crichton",
    "date": 1476306476,
    "message": "Rollup merge of #37064 - nnethercote:read_str, r=eddyb\n\nAvoid allocations in `Decoder::read_str`.\n\n`opaque::Decoder::read_str` is very hot within `rustc` due to its use in\nthe reading of crate metadata, and it currently returns a `String`. This\ncommit changes it to instead return a `Cow<str>`, which avoids a heap\nallocation.\n\nThis change reduces the number of calls to `malloc` by almost 10% in\nsome benchmarks.\n\nThis is a [breaking-change] to libserialize."
  },
  {
    "hash": "b043e11de2eb2c60f7bfec5e15960f537b229e20",
    "author": "Nicholas Nethercote",
    "date": 1476056195,
    "message": "Avoid allocations in `Decoder::read_str`.\n\n`opaque::Decoder::read_str` is very hot within `rustc` due to its use in\nthe reading of crate metadata, and it currently returns a `String`. This\ncommit changes it to instead return a `Cow<str>`, which avoids a heap\nallocation.\n\nThis change reduces the number of calls to `malloc` by almost 10% in\nsome benchmarks.\n\nThis is a [breaking-change] to libserialize."
  },
  {
    "hash": "f3745653e10e366e7e119a12c178a59ab6394007",
    "author": "bors",
    "date": 1475483432,
    "message": "Auto merge of #36767 - jseyfried:enforce_rfc_1560_shadowing, r=nrc\n\nEnforce the shadowing restrictions from RFC 1560 for today's macros\n\nThis PR enforces a weakened version of the shadowing restrictions from RFC 1560. More specifically,\n - If a macro expansion contains a `macro_rules!` macro definition that is used outside of the expansion, the defined macro may not shadow an existing macro.\n - If a macro expansion contains a `#[macro_use] extern crate` macro import that is used outside of the expansion, the imported macro may not shadow an existing macro.\n\nThis is a [breaking-change]. For example,\n```rust\nmacro_rules! m { () => {} }\nmacro_rules! n { () => {\n    macro_rules! m { () => {} } //< This shadows an existing macro.\n    m!(); //< This is inside the expansion that generated `m`'s definition, so it is OK.\n} }\nn!();\nm!(); //< This use of `m` is outside the expansion, so it causes the shadowing to be an error.\n```\n\nr? @nrc"
  },
  {
    "hash": "259d1fcd478f868a9980cdce63f7556f30d55b90",
    "author": "Manish Goregaokar",
    "date": 1475329932,
    "message": "Rollup merge of #36599 - jonas-schievink:whats-a-pirates-favorite-data-structure, r=pnkfelix\n\n Contains a syntax-[breaking-change] as a separate commit (cc #31645).nnAlso renames slice patterns from `PatKind::Vec` to `PatKind::Slice`."
  },
  {
    "hash": "48e5199de366ed2945d1103f0b6c8aa542604ebb",
    "author": "Jonas Schievink",
    "date": 1475094678,
    "message": "libsyntax: clearer names for some AST parts\n\nThis applies the HIR changes from the previous commits to the AST, and\nis thus a syntax-[breaking-change]\n\nRenames `PatKind::Vec` to `PatKind::Slice`, since these are called slice\npatterns, not vec patterns. Renames `TyKind::Vec`, which represents the\ntype `[T]`, to `TyKind::Slice`. Renames `TyKind::FixedLengthVec` to\n`TyKind::Array`."
  },
  {
    "hash": "13a2dd96fe824cc5d61e94ed380db0114efdd014",
    "author": "tormol",
    "date": 1475046210,
    "message": "[breaking-change] std: change `encode_utf{8,16}()` to take a buffer and return a slice\n\nThey panic if the buffer is too small."
  },
  {
    "hash": "eee2d04d877fe909309c39b6bdf711dc586d0a1e",
    "author": "bors",
    "date": 1475112667,
    "message": "Auto merge of #36395 - durka:rangeinclusive-no-esi, r=alexcrichton\n\nremove ExactSizeIterator from RangeInclusive<{u,i}{32,size}>\n\nFixes #36386.\n\nThis is a [breaking-change] for nightly users of `#![feature(inclusive_range_syntax)]` and/or `#![feature(inclusive_range)]`."
  },
  {
    "hash": "b786976a158e79196254f489bb3a6f87e4d16a5a",
    "author": "bors",
    "date": 1474878060,
    "message": "Auto merge of #36730 - jseyfried:make_macro_rules_invocations_magic, r=nrc\n\nForbid user-defined macros named \"macro_rules\"\n\nThis is a [breaking-change].\nr? @nrc"
  },
  {
    "hash": "a0843d7210f41974a0a2bc6876c538718404c268",
    "author": "bors",
    "date": 1474755427,
    "message": "Auto merge of #36657 - nnethercote:rm-TypedArena-with_capacity, r=eddyb\n\n[breaking-change] Remove TypedArena::with_capacity\n\nThis is a follow-up to #36592.\n\nThe function is unused by rustc. Also, it doesn't really follow the\nusual meaning of a `with_capacity` function because the first chunk\nallocation is now delayed until the first `alloc` call.\n\nThis change reduces the size of `TypedArena` by one `usize`.\n\n@eddyb: we discussed this on IRC. Would you like to review it?"
  },
  {
    "hash": "cf50f5f965c3d3dc56fce25f2eaf8f66194f69e4",
    "author": "Nicholas Nethercote",
    "date": 1474576822,
    "message": "[breaking-change] Remove TypedArena::with_capacity.\n\nThe function is unused by rustc. Also, it doesn't really follow the\nusual meaning of a `with_capacity` function because the first chunk\nallocation is now delayed until the first `alloc` call.\n\nThis change reduces the size of `TypedArena` by one `usize`."
  },
  {
    "hash": "7b25e886028195a4f90c0baa5cc9101ebeceb5a3",
    "author": "Ariel Ben-Yehuda",
    "date": 1474027712,
    "message": "forbid moves out of slices\n\nThe wording of RFC #495 enables moves out of slices. Unfortuantely, non-zeroing\nmoves out of slices introduce a very annoying complication: as slices can\nvary in their length, indexes from the start and end may or may not overlap\ndepending on the slice's exact length, which prevents assigning a particular\ndrop flag for each individual element.\n\nFor example, in the code\n\n```Rust\nfn foo<T>(a: Box<[Box<[T]>]>, c: bool) -> T {\n    match (a, c) {\n        (box [box [t, ..], ..], true) => t,\n        (box [.., box [.., t]], false) => t,\n        _ => panic!()\n    }\n}\n```\n\nIf the condition is false, we have to drop the first element\nof `a`, unless `a` has size 1 in which case we drop all the elements\nof it but the last.\n\nIf someone comes with a nice way of handling it, we can always re-allow\nmoves out of slices.\n\nThis is a [breaking-change], but it is behind the `slice_patterns` feature\ngate and was not allowed until recently."
  },
  {
    "hash": "b1363a73ede57ae595f3a1be2bb75d308ba4f7f6",
    "author": "bors",
    "date": 1473804492,
    "message": "Auto merge of #35021 - japaric:rustc-builtins, r=alexcrichton\n\ncrate-ify compiler-rt into compiler-builtins\n\nlibcompiler-rt.a is dead, long live libcompiler-builtins.rlib\n\nThis commit moves the logic that used to build libcompiler-rt.a into a\ncompiler-builtins crate on top of the core crate and below the std crate.\nThis new crate still compiles the compiler-rt instrinsics using gcc-rs\nbut produces an .rlib instead of a static library.\n\nAlso, with this commit rustc no longer passes -lcompiler-rt to the\nlinker. This effectively makes the \"no-compiler-rt\" field of target\nspecifications a no-op. Users of `no_std` will have to explicitly add\nthe compiler-builtins crate to their crate dependency graph *if* they\nneed the compiler-rt intrinsics - this is a [breaking-change]. Users\nof the `std` have to do nothing extra as the std crate depends\non compiler-builtins.\n\nFinally, this a step towards lazy compilation of std with Cargo as the\ncompiler-rt intrinsics can now be built by Cargo instead of having to\nbe supplied by the user by some other method.\n\ncloses #34400\n\n---\n\nr? @alexcrichton"
  },
  {
    "hash": "ecc6c39e876b69496bc88ef47ff3a339662346b1",
    "author": "Alex Crichton",
    "date": 1472845976,
    "message": "rustc: Implement custom derive (macros 1.1)\n\nThis commit is an implementation of [RFC 1681] which adds support to the\ncompiler for first-class user-define custom `#[derive]` modes with a far more\nstable API than plugins have today.\n\n[RFC 1681]: https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\n\nThe main features added by this commit are:\n\n* A new `rustc-macro` crate-type. This crate type represents one which will\n  provide custom `derive` implementations and perhaps eventually flower into the\n  implementation of macros 2.0 as well.\n\n* A new `rustc_macro` crate in the standard distribution. This crate will\n  provide the runtime interface between macro crates and the compiler. The API\n  here is particularly conservative right now but has quite a bit of room to\n  expand into any manner of APIs required by macro authors.\n\n* The ability to load new derive modes through the `#[macro_use]` annotations on\n  other crates.\n\nAll support added here is gated behind the `rustc_macro` feature gate, both for\nthe library support (the `rustc_macro` crate) as well as the language features.\n\nThere are a few minor differences from the implementation outlined in the RFC,\nsuch as the `rustc_macro` crate being available as a dylib and all symbols are\n`dlsym`'d directly instead of having a shim compiled. These should only affect\nthe implementation, however, not the public interface.\n\nThis commit also ended up touching a lot of code related to `#[derive]`, making\na few notable changes:\n\n* Recognized derive attributes are no longer desugared to `derive_Foo`. Wasn't\n  sure how to keep this behavior and *not* expose it to custom derive.\n\n* Derive attributes no longer have access to unstable features by default, they\n  have to opt in on a granular level.\n\n* The `derive(Copy,Clone)` optimization is now done through another \"obscure\n  attribute\" which is just intended to ferry along in the compiler that such an\n  optimization is possible. The `derive(PartialEq,Eq)` optimization was also\n  updated to do something similar.\n\n---\n\nOne part of this PR which needs to be improved before stabilizing are the errors\nand exact interfaces here. The error messages are relatively poor quality and\nthere are surprising spects of this such as `#[derive(PartialEq, Eq, MyTrait)]`\nnot working by default. The custom attributes added by the compiler end up\nbecoming unstable again when going through a custom impl.\n\nHopefully though this is enough to start allowing experimentation on crates.io!\n\nsyntax-[breaking-change]"
  },
  {
    "hash": "147371f58f1a99e32524d61af1d86b2e1e0a503b",
    "author": "bors",
    "date": 1472735104,
    "message": "Auto merge of #34982 - arielb1:bad-tuples-and-objects, r=nikomatsakis\n\nTurn the RFC1592 warnings into hard errors\n\nThe warnings have already reached stable, and I want to improve the trait error reporting code.\n\nTurning warnings into errors, this is obviously a [breaking-change].\n\nr? @nikomatsakis\n\ncc @rust-lang/compiler"
  },
  {
    "hash": "71ee82a8aa0c02fc2c73e84f40bdb55512d10938",
    "author": "bors",
    "date": 1472542579,
    "message": "Auto merge of #36066 - jseyfried:rollup, r=Manishearth\n\nBatch up libsyntax breaking changes\n\nBatch of the following syntax-[breaking-change] changes:\n - #35591: Add a field `span: Span` to `ast::Generics`.\n - #35618: Remove variant `Mod` of `ast::PathListItemKind` and refactor the remaining variant `ast::PathListKind::Ident` to a struct `ast::PathListKind_`.\n - #35480: Change uses of `Constness` in the AST to `Spanned<Constness>`.\n  - c.f. `MethodSig`, `ItemKind`\n - #35728: Refactor `cx.pat_enum()` into `cx.pat_tuple_struct()` and `cx.pat_path()`.\n - #35850: Generalize the elements of lists in attributes from `MetaItem` to a new type `NestedMetaItem` that can represent a `MetaItem` or a literal.\n - #35917: Remove traits `AttrMetaMethods`, `AttributeMethods`, and `AttrNestedMetaItemMethods`.\n  - Besides removing imports of these traits, this won't cause fallout.\n - Add a variant `Union` to `ItemKind` to future proof for `union` (c.f. #36016).\n - Remove inherent methods `attrs` and `fold_attrs` of `Annotatable`.\n  - Use methods `attrs` and `map_attrs` of `HasAttrs` instead.\n\nr? @Manishearth"
  },
  {
    "hash": "312734ca4295f6fa95c70d190ef297f926657155",
    "author": "bors",
    "date": 1472415407,
    "message": "Auto merge of #36029 - KiChjang:issue-12033, r=arielb1\n\nFix lifetime rules for 'if' conditions\n\nFixes #12033.\n\nChanges the temporary scope rules to make the condition of an if-then-else a terminating scope. This is a [breaking-change]."
  },
  {
    "hash": "71bdeea561355ba5adbc9a1f44f4f866a75a15c4",
    "author": "bors",
    "date": 1472149710,
    "message": "Auto merge of #34923 - eddyb:deny-fn-item-transmute, r=nikomatsakis\n\nDeny (by default) transmuting from fn item types to pointer-sized types.\n\nThis sets the #19925 lint (transmute from zero-sized fn item type) to `deny` by default.\nTechnically a `[breaking-change]`, but will not affect dependent crates because of `--cap-lints`."
  },
  {
    "hash": "e9bc1bac8c7664fb1b487879b3fbd56221f6a721",
    "author": "bors",
    "date": 1472075854,
    "message": "Auto merge of #35764 - eddyb:byegone, r=nikomatsakis\n\nRemove the old AST-based backend from rustc_trans.\n\nStarting with Rust 1.13, `--disable-orbit` , `-Z orbit=off` and `#[rustc_no_mir]` have been removed.\nOnly the new MIR backend is left in the compiler, and only early const_eval uses ASTs from other crates.\n\nFilling drop (previously \"zeroing drop\"), `#[unsafe_no_drop_flag]` and associated unstable APIs are gone.\nImplementing `Drop` doesn't add a flag anymore to the type, all of the dynamic drop is function local.\nThis is a [breaking-change], please use `Option::None` and/or `mem::forget` if you are unsure about your ability to prevent/control the drop of a value. In the future, `union` will be usable in some such cases.\n\n**NOTE**: DO NOT MERGE before we get the new beta as the stage0, there's some cruft to remove.\n\nAll of this will massively simplify any efforts to implement (and as such it blocks) features such as `union`s, safe use of `#[packed]` or new type layout optimizations, not to mention many other experiments."
  },
  {
    "hash": "271d048523b6c1b0e773d9e5cc76bbb997cc180c",
    "author": "bors",
    "date": 1470290193,
    "message": "Auto merge of #35015 - petrochenkov:forearg, r=nikomatsakis\n\nProperly enforce the \"patterns aren't allowed in foreign functions\" rule\n\nCases like `arg @ PATTERN` or `mut arg` were missing.\nApply the same rule to function pointer types.\n\nCloses https://github.com/rust-lang/rust/issues/35203\n[breaking-change], no breakage in sane code is expected though\nr? @nikomatsakis\n\nThis is somewhat related to https://github.com/rust-lang/rfcs/pull/1685 (cc @matklad).\nThe goal is to eventually support full pattern syntax where it makes sense (function body may present) and to support *only* the following forms - `TYPE`, `ident: TYPE`, `_: TYPE` - where patterns don't make sense (function body doesn't present), i.e. in foreign functions and function pointer types."
  },
  {
    "hash": "81df89fc2d6ba1b55ab20b0615b8523a6e90963f",
    "author": "Ariel Ben-Yehuda",
    "date": 1470226127,
    "message": "remove the ExecutionEngine binding\n\nthe code has no tests and will just bitrot by itself.\n\nthis is a [breaking-change]"
  },
  {
    "hash": "7333c4ac25648e831fb2033ee77fbbdc62ae492a",
    "author": "bors",
    "date": 1470001318,
    "message": "Auto merge of #35143 - arielb1:rfc447-regions, r=eddyb\n\ntypeck: use a TypeVisitor in ctp\n\nUse a TypeVisitor in ctp instead of `ty::walk`\n\nThis fixes a few cases where a region could be projected out of a trait while not being constrained by the type parameters, violating rust-lang/rfcs#447 and breaking soundness. As such, this is a [breaking-change].\n\nFixes #35139\n\nr? @eddyb"
  },
  {
    "hash": "1225e122fda8cfbe3a5da6007e912f204b97f8c4",
    "author": "bors",
    "date": 1469919500,
    "message": "Auto merge of #34904 - petrochenkov:rustcall, r=nikomatsakis\n\nProperly feature gate all unstable ABIs\n\nFixes https://github.com/rust-lang/rust/issues/34900\n[breaking-change]\nr? @pnkfelix\n\n---\nFunction-visiting machinery for AST/HIR is surprisingly error-prone, it's *very* easy to miss some cases or visit something twice while writing a visitor. This is the true problem behind https://github.com/rust-lang/rust/issues/34900. I'll try to restructure these visitors a bit and send one more PR later."
  },
  {
    "hash": "2ab18ce6f7e147a71e953b9a01ed09aff6b95972",
    "author": "bors",
    "date": 1468399027,
    "message": "Auto merge of #34660 - jseyfried:fix_parse_stmt, r=nrc\n\nFix bugs in macro-expanded statement parsing\n\nFixes #34543.\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m { () => {\n    println!(\"\") println!(\"\")\n    //^ Semicolons are now required on macro-expanded non-braced macro invocations\n    //| in statement positions.\n    let x = 0\n    //^ Semicolons are now required on macro-expanded `let` statements\n    //| that are followed by more statements, so this would break.\n    let y = 0 //< (this would still be allowed to reduce breakage in the wild)\n}\nfn main() { m!() }\n```\n\nr? @eddyb"
  },
  {
    "hash": "f93aaf84cb50dfaaba44b08c05bd51320263f592",
    "author": "bors",
    "date": 1468102581,
    "message": "Auto merge of #34365 - petrochenkov:deferr, r=eddyb\n\nSome more pattern cleanup and bugfixing\n\nThe next part of https://github.com/rust-lang/rust/pull/34095\n\nThe most significant fixed mistake is definitions for partially resolved associated types not being updated after full resolution.\n```\nfn f<T: Fn()>(arg: T::Output) { .... } // <- the definition of T::Output was not updated in def_map\n```\nFor this reason unstable associated types of stable traits, like `FnOnce::Output`, could be used in stable code when written in unqualified form. Now they are properly checked, this is a **[breaking-change]** (pretty minor one, but a crater run would be nice). The fix is not to use unstable library features in stable code, alternatively `FnOnce::Output` can be stabilized.\n\nBesides that, paths in struct patterns and expressions `S::A { .. }` are now fully resolved as associated types. Such types cannot be identified as structs at the moment, i.e. the change doesn't make previously invalid code valid, but it improves error diagnostics.\n\nOther changes: `Def::Err` is supported better (less chances for ICEs for erroneous code), some incorrect error messages are corrected, some duplicated error messages are not reported, ADT definitions are now available through constructor IDs, everything else is cleanup and code audit.\n\nFixes https://github.com/rust-lang/rust/issues/34209\nCloses https://github.com/rust-lang/rust/issues/22933 (adds tests)\n\nr? @eddyb"
  },
  {
    "hash": "de78655bca47cac8e783dbb563e7e5c25c1fae40",
    "author": "bors",
    "date": 1467860651,
    "message": "Auto merge of #34652 - jseyfried:fix_expansion_perf, r=nrc\n\nFix expansion performance regression\n\n**syntax-[breaking-change] cc #31645**\n\nThis fixes #34630 by reverting commit 5bf7970 of PR #33943, which landed in #34424.\n\nBy removing the `Rc<_>` wrapping around `Delimited` and `SequenceRepetition` in `TokenTree`, 5bf7970 made cloning `TokenTree`s more expensive. While this had no measurable performance impact on the compiler's crates, it caused an order of magnitude performance regression on some macro-heavy code in the wild. I believe this is due to clones of `TokenTree`s in `macro_parser.rs` and/or `macro_rules.rs`.\n\nr? @nrc"
  },
  {
    "hash": "47380768e7debc2ee6b66e491733b89534e80988",
    "author": "bors",
    "date": 1467790491,
    "message": "Auto merge of #34546 - jseyfried:cfg_attr_path, r=nrc\n\nSupport `cfg_attr` on `path` attributes\n\nFixes #25544.\nThis is technically a [breaking-change]. For example, the following would break:\n```rust\nmod foo; // Suppose `foo.rs` existed in the appropriate location\n```"
  },
  {
    "hash": "e85adffd6402acce79887e1b911ff33841c6133a",
    "author": "bors",
    "date": 1467477412,
    "message": "Auto merge of #34443 - eddyb:sized-matters, r=arielb1\n\nDisallow constants and statics from having unsized types.\n\nThis is a `[breaking-change]` which fixes #34390 by banning unsized `const` and `static`, e.g.:\n```rust\nconst A: [i32] = *(&[0, 1, 2] as &[i32]);\nstatic B: str = *\"foo\";\n```\n\nThis was not intentionally allowed, and other than for `static` since some versions ago, it ICE'd.\nIf you've been taking advantage of this with `static`, you should be able to just use references instead."
  },
  {
    "hash": "8886818a9ab3e6c52651038d4e22e2d51b932bb9",
    "author": "Manish Goregaokar",
    "date": 1467215482,
    "message": "Rollup merge of #34495 - jseyfried:only_ident_macro_invocations, r=eddyb\n\nForbid type parameters and global paths in macro invocations\n\nFixes #28558.\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m { () => { () } }\nfn main() {\n    m::<T>!(); // Type parameters are no longer allowed in macro invocations\n    ::m!(); // Global paths are no longer allowed in macro invocations\n}\n```\nAny breakage can be fixed by removing the type parameters or the leading `::` (respectively).\n\nr? @eddyb"
  },
  {
    "hash": "ea0dc9297283daff6486807f43e190b4eb561412",
    "author": "bors",
    "date": 1467070923,
    "message": "Auto merge of #34424 - jseyfried:breaking_batch, r=Manishearth\n\nBatch up libsyntax breaking changes\n\nBatch of the following syntax-[breaking-change] changes:\n - #34213: Add a variant `Macro` to `TraitItemKind`\n - #34368: Merge the variant `QPath` of `PatKind` into the variant `PatKind::Path`\n - #34385: Move `syntax::ast::TokenTree` into a new module `syntax::tokenstream`\n - #33943:\n  - Remove the type parameter from `visit::Visitor`\n  - Remove `attr::WithAttrs` -- use `attr::HasAttrs` instead.\n  - Change `fold_tt`/`fold_tts` to take token trees by value and avoid wrapping token trees in `Rc`.\n  - Remove the field `ctxt` of `ast::Mac_`\n  - Remove inherent method `attrs()` of types -- use the method `attrs` of `HasAttrs` instead.\n - #34316:\n  - Remove `ast::Decl`/`ast::DeclKind` and add variants `Local` and `Item` to `StmtKind`.\n  - Move the node id for statements from the `StmtKind` variants to a field of `Stmt` (making `Stmt` a struct instead of an alias for `Spanned<StmtKind>`)\n  - Rename `ast::ExprKind::Again` to `Continue`.\n - #34339: Generalize and abstract `ThinAttributes` to `ThinVec<Attribute>`\n  - Use `.into()` in convert between `Vec<Attribute>` and `ThinVec<Attribute>`\n  - Use autoderef instead of `.as_attr_slice()`\n - #34436: Remove the optional expression from `ast::Block` and instead use a `StmtKind::Expr` at the end of the statement list.\n - #34403: Move errors into a separate crate (unlikely to cause breakage)"
  },
  {
    "hash": "82a15a6a0af724e71004c735f8a99ec5f2a03920",
    "author": "Jeffrey Seyfried",
    "date": 1466907119,
    "message": "Rollup merge of #34385 - cgswords:tstream, r=nrc\n\nsyntax-[breaking-change] cc #31645\n(Only breaking because ast::TokenTree is now tokenstream::TokenTree.)\n\nThis pull request refactors TokenTrees into their own file as src/libsyntax/tokenstream.rs, moving them out of src/libsyntax/ast.rs, in order to prepare for an accompanying TokenStream implementation (per RFC 1566)."
  },
  {
    "hash": "4e2e31c11837f244e5039165b777ddedde5dc44d",
    "author": "Jeffrey Seyfried",
    "date": 1466894106,
    "message": "Rollup merge of #34368 - petrochenkov:astqpath, r=Manishearth\n\nThe AST part of https://github.com/rust-lang/rust/pull/34365\n\nplugin-[breaking-change] cc https://github.com/rust-lang/rust/issues/31645"
  },
  {
    "hash": "f0310e061b9d0a7d8dc515390fa68dfb6318df4b",
    "author": "Jeffrey Seyfried",
    "date": 1466894101,
    "message": "Rollup merge of #34213 - josephDunne:trait_item_macros, r=jseyfried\n\n**syntax-[breaking-change]** cc #31645\nNew `TraitItemKind::Macro` variant\n\nThis change adds support for macro expansion inside trait items by adding the new `TraitItemKind::Macro` and associated parsing code."
  },
  {
    "hash": "af2fe634bfa770e7da675210aa661a96cde51275",
    "author": "bors",
    "date": 1466992932,
    "message": "Auto merge of #34491 - eddyb:return-in-peace, r=nagisa\n\nRemove the return_address intrinsic.\n\nThis intrinsic to get the return pointer was introduced in #16248 / #16081 by @pcwalton for Servo.\nHowever, as explained in #34227, it's impossible to ensure it's used correctly, and it broke with `-Zorbit`.\n\nServo's usage is being replaced in servo/servo#11872, and I expect nobody else to have abused it.\nBut I've also started a crater run, just in case this is a `[breaking-change]` for anyone else."
  },
  {
    "hash": "6edea2cfda2818f0a76f4bac2d18a30feb54c137",
    "author": "bors",
    "date": 1466074195,
    "message": "Auto merge of #34216 - jseyfried:nested_cfg_attr, r=nrc\n\nSupport nested `cfg_attr` attributes\n\nSupport arbitrarily deeply nested `cfg_attr` attributes (e.g. `#[cfg_attr(foo, cfg_attr(bar, baz))]`).\nThis makes configuration idempotent.\n\nCurrently, the nighties do not support any `cfg_attr` nesting. Stable and beta support just one level of `cfg_attr` nesting (expect for attributes on macro-expanded nodes, where no nesting is supported).\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m { () => {\n    #[cfg_attr(all(), cfg_attr(all(), cfg(foo)))]\n    fn f() {}\n} }\nm!();\n\nfn main() { f() } //~ ERROR unresolved name `f`\n```\nr? @nrc"
  },
  {
    "hash": "a94881563c18e4ffca2e24aed4bd8f5de583cc91",
    "author": "bors",
    "date": 1465991309,
    "message": "Auto merge of #34180 - durka:patch-24, r=brson\n\nderive Hash (and not Copy) for ranges\n\nFixes #34170.\n\nAlso, `RangeInclusive` was `Copy` by mistake -- fix that, which is a [breaking-change] to that unstable type."
  },
  {
    "hash": "9e78cd73b5c4254efda9fe57be56b8b374383812",
    "author": "Alex Burka",
    "date": 1465493162,
    "message": "make RangeInclusive Hash and !Copy\n\n[breaking-change] due to the removal of Copy which shouldn't have been there in the first place, as per policy set forth in #27186."
  },
  {
    "hash": "7d2f75a953b5645d3a336b2978b48b60d310bf54",
    "author": "bors",
    "date": 1465512517,
    "message": "Auto merge of #34095 - petrochenkov:pathir2, r=jseyfried\n\nImprovements to pattern resolution + some refactoring\n\nContinuation of https://github.com/rust-lang/rust/pull/33929\nFirst commit is a careful rewrite of `resolve_pattern`, pattern path resolution and new binding creation logic is factored out in separate functions, some minor bugs are fixed. Also, `resolve_possibly_assoc_item` doesn't swallow modules now.\nLater commits are refactorings, see the comment descriptions.\n\nI intend to continue this work later with better support for `Def::Err` in patterns in post-resolve stages and cleanup of pattern resolution code in type checker.\n\nFixes https://github.com/rust-lang/rust/issues/32086\nFixes https://github.com/rust-lang/rust/issues/34047 ([breaking-change])\nFixes https://github.com/rust-lang/rust/issues/34074\n\ncc @jseyfried\nr? @eddyb"
  },
  {
    "hash": "dc77c5ebe80d8e8fe08b9ba05859c04f4dbb99cf",
    "author": "bors",
    "date": 1465451135,
    "message": "Auto merge of #34032 - jseyfried:load_macros_in_expansion, r=nrc\n\nSupport `#[macro_use]` on macro-expanded crates\n\nThis PR loads macros from `#[macro_use]` crates during expansion so that\n - macro-expanded `#[macro_use]` crates work (fixes #33936, fixes #28071), and\n - macros imported from crates have the same scope as macros imported from modules.\n\nThis is a [breaking-change]. For example, this will break:\n```rust\nmacro_rules! m {\n    () => { #[macro_use(foo)] extern crate core; } //~ ERROR imported macro not found\n}\nm!();\n```\nAlso, this will break:\n```rust\nmacro_rules! try { () => {} }\n// #[macro_use] mod bar { macro_rules! try { ... } } //< ... just like this would ...\nfn main() { try!(); } //< ... making this an error\n```\n\nr? @nrc"
  },
  {
    "hash": "bb4b3fb7f97924919f072ec9a360bdf943218dbf",
    "author": "bors",
    "date": 1465439433,
    "message": "Auto merge of #32202 - arielb1:slice-patterns, r=nikomatsakis\n\nImplement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns.\n\n[RFC 495 text](https://github.com/rust-lang/rfcs/blob/master/text/0495-array-pattern-changes.md)"
  },
  {
    "hash": "5c717a6fc21594569d9e64968cdcf2e88e372a07",
    "author": "Ariel Ben-Yehuda",
    "date": 1465421918,
    "message": "implement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns."
  },
  {
    "hash": "814f685df21439ab6eab83f421d4b60cab026a0b",
    "author": "Steve Klabnik",
    "date": 1465310638,
    "message": "Rollup merge of #34124 - jonas-schievink:remove-useless-optns, r=sanxiyn\n\nRemove old -Z options that do nothing\n\nTechnically, this is a [breaking-change], but I'm not sure what the policy for -Z flags is (especially unused ones)."
  },
  {
    "hash": "6e2f966f729821ebc85fdca6a426493d6d2178ce",
    "author": "Jonas Schievink",
    "date": 1465249424,
    "message": "Remove old -Z options that do nothing\n\nTechnically, this is a [breaking-change], but I'm not sure what the\npolicy for -Z flags is (especially unused ones)."
  },
  {
    "hash": "12d16599d84c25899f02a6e53110d1e70cdcbd8a",
    "author": "bors",
    "date": 1464801715,
    "message": "Auto merge of #33814 - lambda:rtabort-use-platform-abort, r=alexcrichton\n\nOpen code the __fastfail intrinsic for rtabort! on windows\n\nAs described https://msdn.microsoft.com/en-us/library/dn774154.aspx\n\nThis is a Windows 8+ mechanism for terminating the process quickly,\nwhich degrades to either an access violation or bugcheck in older versions.\n\nI'm not sure this is better the the current mechanism of terminating\nwith an illegal instruction, but we recently converted unix to\nterminate more correctly with SIGABORT, and this *seems* more correct\nfor windows.\n\n[breaking-change]"
  },
  {
    "hash": "696a570a00db2528b7934be32da7d8334738a997",
    "author": "Brian Anderson",
    "date": 1464094563,
    "message": "Open code the __fastfail intrinsic for rtabort! on windows\n\nAs described https://msdn.microsoft.com/en-us/library/dn774154.aspx\n\nThis is a Windows 8+ mechanism for terminating the process quickly,\nwhich degrades to either an access violation or bugcheck in older versions.\n\nI'm not sure this is better the the current mechanism of terminating\nwith an illegal instruction, but we recently converted unix to\nterminate more correctly with SIGABORT, and this *seems* more correct\nfor windows.\n\n[breaking-change]"
  },
  {
    "hash": "c2cab1fd58d6373582da189bd2c20ed3f6a7042a",
    "author": "bors",
    "date": 1464787313,
    "message": "Auto merge of #33794 - petrochenkov:sanity, r=nrc\n\nAdd AST validation pass and move some checks to it\n\nThe purpose of this pass is to catch constructions that fit into AST data structures, but not permitted by the language. As an example, `impl`s don't have visibilities, but for convenience and uniformity with other items they are represented with a structure `Item` which has `Visibility` field.\n\nThis pass is intended to run after expansion of macros and syntax extensions (and before lowering to HIR), so it can catch erroneous constructions that were generated by them. This pass allows to remove ad hoc semantic checks from the parser, which can be overruled by syntax extensions and occasionally macros.\n\nThe checks can be put here if they are simple, local, don't require results of any complex analysis like name resolution or type checking and maybe don't logically fall into other passes. I expect most of errors generated by this pass to be non-fatal and allowing the compilation to proceed.\n\nI intend to move some more checks to this pass later and maybe extend it with new checks, like, for example, identifier validity. Given that syntax extensions are going to be stabilized in the measurable future, it's important that they would not be able to subvert usual language rules.\n\nIn this patch I've added two new checks - a check for labels named `'static` and a check for lifetimes and labels named `'_`. The first one gives a hard error, the second one - a future compatibility warning.\nFixes https://github.com/rust-lang/rust/issues/33059 ([breaking-change])\ncc https://github.com/rust-lang/rfcs/pull/1177\n\nr? @nrc"
  },
  {
    "hash": "8b012ed142f03c9082773f5091c58c82d47cae79",
    "author": "bors",
    "date": 1464396374,
    "message": "Auto merge of #33706 - jseyfried:refactor_cfg, r=nrc\n\nPerform `cfg` attribute processing during macro expansion and fix bugs\n\nThis PR refactors `cfg` attribute processing and fixes bugs. More specifically:\n - It merges gated feature checking for stmt/expr attributes, `cfg_attr` processing, and `cfg` processing into a single fold.\n  - This allows feature gated `cfg` variables to be used in `cfg_attr` on unconfigured items. All other feature gated attributes can already be used on unconfigured items.\n - It performs `cfg` attribute processing during macro expansion instead of after expansion so that macro-expanded items are configured the same as ordinary items. In particular, to match their non-expanded counterparts,\n  - macro-expanded unconfigured macro invocations are no longer expanded,\n  - macro-expanded unconfigured macro definitions are no longer usable, and\n  - feature gated `cfg` variables on macro-expanded macro definitions/invocations are now errors.\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m {\n    () => {\n        #[cfg(attr)]\n        macro_rules! foo { () => {} }\n        foo!(); // This will be an error\n\n        macro_rules! bar { () => { fn f() {} } }\n        #[cfg(attr)] bar!(); // This will no longer be expanded ...\n        fn g() { f(); } // ... so that `f` will be unresolved.\n\n        #[cfg(target_thread_local)] // This will be a gated feature error\n        macro_rules! baz { () => {} }\n    }\n}\n\nm!();\n```\n\nr? @nrc"
  },
  {
    "hash": "7905452f083ab5ac3008dfe6727048e70bbeb142",
    "author": "Manish Goregaokar",
    "date": 1464323231,
    "message": "Rollup merge of #33644 - petrochenkov:selfast, r=nrc\n\n The AST part of https://github.com/rust-lang/rust/pull/33505.\nhttps://github.com/rust-lang/rust/pull/33505 isn't landed yet, so this PR is based on top of it.\n\nr? @nrc\n\nplugin-[breaking-change] cc #31645 @Manishearth"
  },
  {
    "hash": "35785712cd5e1acbfebd168c045b2e184ae979cc",
    "author": "Manish Goregaokar",
    "date": 1464323220,
    "message": "Rollup merge of #33639 - petrochenkov:dotdot, r=nmatsakis\n\n cc https://github.com/rust-lang/rust/issues/33627\nr? @nikomatsakis\n\nplugin-[breaking-change] cc https://github.com/rust-lang/rust/issues/31645 @Manishearth"
  },
  {
    "hash": "6e455640950c4e8cb8bff919edb4854fcf7773ca",
    "author": "bors",
    "date": 1463984051,
    "message": "Auto merge of #31457 - lambda:rtabort-use-libc-abort, r=alexcrichton\n\nUse libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333"
  },
  {
    "hash": "cfc386583291c8868d093d07431a57a20e69c944",
    "author": "Brian Campbell",
    "date": 1463977361,
    "message": "Use libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333"
  },
  {
    "hash": "b711734a5f7280cc3ceb99e09551a7b7691c7d0b",
    "author": "Niko Matsakis",
    "date": 1463580645,
    "message": "thread the DepGraph to session/crate-store\n\nThis is a [breaking-change] for plugin authors.\nYou must now create a dep-graph earlier."
  },
  {
    "hash": "2237e899084f16f61e4a74c191a74c7bb2fd3727",
    "author": "Niko Matsakis",
    "date": 1463580645,
    "message": "remove the `Any` bound from `CrateStore`\n\nThis is a [breaking-change] for plugins, which\nought by now to have stopped relying on downcasting."
  },
  {
    "hash": "1ec22171e6053c640293067418ea1901cb1c7df1",
    "author": "bors",
    "date": 1462692700,
    "message": "Auto merge of #33130 - eddyb:mir-const, r=nikomatsakis\n\nImplement constant support in MIR.\n\nAll of the intended features in `trans::consts` are now supported by `mir::constant`.\nThe implementation is considered a temporary measure until `miri` replaces it.\n\nA `-Z orbit` bootstrap build will only translate LLVM IR from AST for `#[rustc_no_mir]` functions.\n\nFurthermore, almost all checks of constant expressions have been moved to MIR.\nIn non-`const` functions, trees of temporaries are promoted, as per RFC 1414 (rvalue promotion).\nPromotion before MIR borrowck would allow reasoning about promoted values' lifetimes.\n\nThe improved checking comes at the cost of four `[breaking-change]`s:\n* repeat counts must contain a constant expression, e.g.:\n`let arr = [0; { println!(\"foo\"); 5 }];` used to be allowed (it behaved like `let arr = [0; 5];`)\n* dereference of a reference to a `static` cannot be used in another `static`, e.g.:\n`static X: [u8; 1] = [1]; static Y: u8 = (&X)[0];` was unintentionally allowed before\n* the type of a `static` *must* be `Sync`, irrespective of the initializer, e.g.\n`static FOO: *const T = &BAR;` worked as `&T` is `Sync`, but it shouldn't because `*const T` isn't\n* a `static` cannot wrap `UnsafeCell` around a type that *may* need drop, e.g.\n`static X: MakeSync<UnsafeCell<Option<String>>> = MakeSync(UnsafeCell::new(None));`\nwas previously allowed based on the fact `None` alone doesn't need drop, but in `UnsafeCell`\nit can be later changed to `Some(String)` which *does* need dropping\n\nThe drop restrictions are relaxed by RFC 1440 (#33156), which is implemented, but feature-gated.\nHowever, creating `UnsafeCell` from constants is unstable, so users can just enable the feature gate."
  },
  {
    "hash": "2f8f256cef42350af2f0376891fd020b6b1c37de",
    "author": "Ariel Ben-Yehuda",
    "date": 1462289410,
    "message": "require the existential bounds of an object type to be object-safe\n\nThis is required, as Copy and Sized are object-unsafe.\n\nAs a soundness fix, this is a [breaking-change]\n\nFixes #32963"
  },
  {
    "hash": "0a6dfc51777eb388b6e795399bf1d3f8aac57db8",
    "author": "Ariel Ben-Yehuda",
    "date": 1462289410,
    "message": "require the non-last elements of a tuple to be Sized\n\nThis requirement appears to be missing from RFC1214, but is clearly\nnecessary for translation. The last field of a tuple/enum remains in\na state of limbo, compiling but causing an ICE when it is used - we\nshould eventually fix that somehow.\n\nthis is a [breaking-change] - a soundness fix - and requires a\ncrater run."
  },
  {
    "hash": "c1c6e99bfd3296954a192d9fe3151a222dd9045c",
    "author": "Nick Cameron",
    "date": 1462230909,
    "message": "rebasing\n\nNote that this whole PR is a [breaking-change] for clients of the Compiler API."
  },
  {
    "hash": "a31658de51444d1b5193ac203a1bd7ace5621f93",
    "author": "Manish Goregaokar",
    "date": 1461525464,
    "message": "Rollup merge of #33041 - petrochenkov:path, r=nrc,Manishearth\n\n Paths are mostly parsed without taking whitespaces into account, e.g. `std :: vec :: Vec :: new ()` parses successfully, however, there are some special cases involving keywords `super`, `self` and `Self`. For example, `self::` is considered a path start only if there are no spaces between `self` and `::`. These restrictions probably made sense when `self` and friends weren't keywords, but now they are unnecessary.\n\nThe first two commits remove this special treatment of whitespaces by removing `token::IdentStyle` entirely and therefore fix https://github.com/rust-lang/rust/issues/14109.\nThis change also affects naked `self` and `super` (which are not tightly followed by `::`, obviously) they can now be parsed as paths, however they are still not resolved correctly in imports (cc @jseyfried, see `compile-fail/use-keyword.rs`), so https://github.com/rust-lang/rust/issues/29036 is not completely fixed.\n\nThe third commit also makes `super`, `self`, `Self` and `static` keywords nominally (before this they acted as keywords for all purposes) and removes most of remaining \\\"special idents\\\".\n\nThe last commit (before tests) contains some small improvements - some qualified paths with type parameters are parsed correctly, `parse_path` is not used for parsing single identifiers, imports are sanity checked for absence of type parameters - such type parameters can be generated by syntax extensions or by macros when https://github.com/rust-lang/rust/issues/10415 is fixed (~~soon!~~already!).\n\nThis patch changes some pretty basic things in `libsyntax`, like `token::Token` and the keyword list, so it's a plugin-[breaking-change].\n\nr? @eddyb"
  },
  {
    "hash": "23ccaddaa7d1cb71e49ef1b1f423b3245fa3a879",
    "author": "bors",
    "date": 1461447606,
    "message": "Auto merge of #33124 - sfackler:kill-ipv6-only, r=alexcrichton\n\nRemove IPV6_V6ONLY functionality\n\nThese settings can only be adjusted before bind time, which doesn't make\nsense in the current set of functionality. These methods are stable, but\nhaven't hit a stable release yet.\n\nCloses #33052\n\n[breaking-change]\n\nr? @alexcrichton\n\nWill also need a backport to the beta."
  },
  {
    "hash": "c6480e8b6b13401030c52f3c2b4fcc4e80c14481",
    "author": "Steven Fackler",
    "date": 1461213739,
    "message": "Remove IPV6_V6ONLY functionality\n\nThese settings can only be adjusted before bind time, which doesn't make\nsense in the current set of functionality. These methods are stable, but\nhaven't hit a stable release yet.\n\nCloses #33052\n\n[breaking-change]"
  },
  {
    "hash": "6ece1447f02b2310e5f4c7ef1efd1312476cae80",
    "author": "bors",
    "date": 1461162479,
    "message": "Auto merge of #32939 - eddyb:layout, r=nikomatsakis\n\nCompute LLVM-agnostic type layouts in rustc.\n\nLayout for monomorphic types, and some polymorphic ones (e.g. `&T` where `T: Sized`),\ncan now be computed by rustc without involving LLVM in the actual process.\n\nThis gives rustc the ability to evaluate `size_of` or `align_of`, as well as obtain field offsets.\nMIR-based CTFE will eventually make use of these layouts, as will MIR trans, shortly.\n\nLayout computation also comes with a `[breaking-change]`, or two:\n* `\"data-layout\"` is now mandatory in custom target specifications, reverting the decision from #27076.\nThis string is needed because it describes endianness, pointer size and alignments for various types.\nWe have the first two and we could allow tweaking alignments in target specifications.\nOr we could also extract the data layout from LLVM and feed it back into rustc.\nHowever, that can vary with the LLVM version, which is fragile and undermines stability.\nFor built-in targets, I've added a check that the hardcoded data-layout matches LLVM defaults.\n* `transmute` calls are checked in a stricter fashion, which fixes #32377\n\nTo expand on `transmute`, there are only 2 allowed patterns: between types with statically known sizes and between pointers with the same potentially-unsized \"tail\" (which determines the type of unsized metadata they use, if any).\nIf you're affected, my suggestions are:\n* try to use casts (and raw pointer deref) instead of transmutes\n* *really* try to avoid `transmute` where possible\n* if you have a structure, try working on individual fields and unpack/repack the structure instead of transmuting it whole, e.g. `transmute::<RefCell<Box<T>>, RefCell<*mut T>>(x)` doesn't work, but `RefCell::new(Box::into_raw(x.into_inner()))` does (and `Box::into_raw` is just a `transmute`)"
  },
  {
    "hash": "6a0cfbcac294faab2b8bcd95a04cda042101a2d8",
    "author": "Manish Goregaokar",
    "date": 1460749603,
    "message": "Rollup merge of #32923 - jseyfried:fix_hygiene, r=nrc\n\nFix macro hygiene bug\n\nThis fixes #32922 (EDIT: and fixes #31856), macro hygiene bugs.\nIt is a [breaking-change]. For example, the following would break:\n```rust\nfn main() {\n    let x = true;\n    macro_rules! foo { () => {\n        let x = 0;\n        macro_rules! bar { () => {x} }\n        let _: bool = bar!();\n        //^ `bar!()` used to resolve the first `x` (a bool),\n        //| but will now resolve to the second x (an i32).\n    }}\n    foo! {};\n}\n```\n\nr? @nrc"
  },
  {
    "hash": "af7b00b68fc7960e98fb914be52d9a6a16fe2224",
    "author": "Manish Goregaokar",
    "date": 1459943131,
    "message": "Rollup merge of #32682 - petrochenkov:field3, r=Manishearth\n\n The AST part of https://github.com/rust-lang/rust/pull/31937\n\nUnlike HIR, AST still uses `Option` for field names because parser can't know field indexes reliably due to constructions like\n```\nstruct S(#[cfg(false)] u8, u8); // The index of the second field changes from 1 during parsing to 0 after expansion.\n```\nand I wouldn't like to put the burden of renaming fields on expansion passes and syntax extensions.\n\nplugin-[breaking-change] cc https://github.com/rust-lang/rust/issues/31645\nr? @Manishearth"
  },
  {
    "hash": "772c600d4d6f39daa6d07d1a60ee0df3d3426978",
    "author": "bors",
    "date": 1459907904,
    "message": "Auto merge of #32688 - jseyfried:ast_groundwork_for_1422, r=pnkfelix\n\n[breaking-batch] Add support for `pub(restricted)` syntax in the AST\n\nThis PR allows the AST to represent the `pub(restricted)` syntax from RFC 1422 (cc #32409).\n\nMore specifically, it makes `ast::Visibility` non-`Copy` and adds two new variants, `Visibility::Crate` for `pub(crate)` and `Visitibility::Restricted { path: P<Path>, id: NodeId }` for `pub(path)`.\n\nplugin-[breaking-change] cc #31645\nr? @pnkfelix"
  },
  {
    "hash": "a11129701c873d96fe0816e4c8b55510efebe96e",
    "author": "bors",
    "date": 1459223442,
    "message": "Auto merge of #32479 - eddyb:eof-not-even-twice, r=nikomatsakis\n\nPrevent bumping the parser past the EOF.\n\nMakes `Parser::bump` after EOF into an ICE, forcing callers to avoid repeated EOF bumps.\nThis ICE is intended to break infinite loops where EOF wasn't stopping the loop.\n\nFor example, the handling of EOF in `parse_trait_items`' recovery loop fixes #32446.\nBut even without this specific fix, the ICE is triggered, which helps diagnosis and UX.\n\nThis is a `[breaking-change]` for plugins authors who eagerly eat multiple EOFs.\nSee https://github.com/docopt/docopt.rs/pull/171 for such an example and the necessary fix."
  },
  {
    "hash": "128b2ad8298f33984c64b98cfb354bb932b740ef",
    "author": "Manish Goregaokar",
    "date": 1458963441,
    "message": "Rollup merge of #32199 - nikomatsakis:limiting-constants-in-patterns-2, r=pnkfelix\n\nRestrict constants in patterns\n\nThis implements [RFC 1445](https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md). The primary change is to limit the types of constants used in patterns to those that *derive* `Eq` (note that implementing `Eq` is not sufficient). This has two main effects:\n\n1. Floating point constants are linted, and will eventually be disallowed. This is because floating point constants do not implement `Eq` but only `PartialEq`. This check replaces the existing special case code that aimed to detect the use of `NaN`.\n2. Structs and enums must derive `Eq` to be usable within a match.\n\nThis is a [breaking-change]: if you encounter a problem, you are most likely using a constant in an expression where the type of the constant is some struct that does not currently implement\n`Eq`. Something like the following:\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nThe easiest and most future compatible fix is to annotate the type in question with `#[derive(Eq)]` (note that merely *implementing* `Eq` is not enough, it must be *derived*):\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nAnother good option is to rewrite the match arm to use an `if` condition (this is also particularly good for floating point types, which implement `PartialEq` but not `Eq`):\n\n```rust\nmatch foo {\n    c if c == SOME_CONST => ...\n}\n```\n\nFinally, a third alternative is to tag the type with `#[structural_match]`; but this is not recommended, as the attribute is never expected to be stabilized. Please see RFC #1445 for more details.\n\ncc https://github.com/rust-lang/rust/issues/31434\n\nr? @pnkfelix"
  },
  {
    "hash": "f69eb8efbe5dbc373426bf0ff021b49f37db41cb",
    "author": "Niko Matsakis",
    "date": 1458902742,
    "message": "issue a future-compat lint for constants of invalid type\n\nThis is a [breaking-change]: according to RFC #1445, constants used as\npatterns must be of a type that *derives* `Eq`. If you encounter a\nproblem, you are most likely using a constant in an expression where the\ntype of the constant is some struct that does not currently implement\n`Eq`. Something like the following:\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nThe easiest and most future compatible fix is to annotate the type in\nquestion with `#[derive(Eq)]` (note that merely *implementing* `Eq` is\nnot enough, it must be *derived*):\n\n```rust\nstruct SomeType { ... }\nconst SOME_CONST: SomeType = ...;\n\nmatch foo {\n    SOME_CONST => ...\n}\n```\n\nAnother good option is to rewrite the match arm to use an `if`\ncondition (this is also particularly good for floating point types,\nwhich implement `PartialEq` but not `Eq`):\n\n```rust\nmatch foo {\n    c if c == SOME_CONST => ...\n}\n```\n\nFinally, a third alternative is to tag the type with\n`#[structural_match]`; but this is not recommended, as the attribute is\nnever expected to be stabilized. Please see RFC #1445 for more details."
  },
  {
    "hash": "64a13a46601bb47a470264936b623b4adf706128",
    "author": "bors",
    "date": 1458907393,
    "message": "Auto merge of #31908 - jseyfried:disallow_shadowed_traits, r=nikomatsakis\n\nDisallow methods from traits that are not in scope\n\nThis PR only allows a trait method to be used if the trait is in scope (fixes #31379).\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmod foo {\n    pub trait T { fn f(&self) {} }\n    impl T for () {}\n}\n\nmod bar { pub use foo::T; }\n\nfn main() {\n    pub use bar::*;\n    struct T; // This shadows the trait `T`,\n    ().f() // making this an error.\n}\n```\nr? @nikomatsakis"
  },
  {
    "hash": "06074ac004701bff42c625247c4764b2ae6fca6c",
    "author": "bors",
    "date": 1457848514,
    "message": "Auto merge of #32141 - jseyfried:fix_resolution_in_lexical_scopes, r=nikomatsakis\n\nFix name resolution in lexical scopes\n\nCurrently, `resolve_item_in_lexical_scope` does not check the \"ribs\" (type parameters and local variables). This can allow items that should be shadowed by type parameters to be named.\n\nFor example,\n```rust\nstruct T { i: i32 }\nfn f<T>() {\n    let t = T { i: 0 }; // This use of `T` resolves to the struct, not the type parameter\n}\n\nmod Foo {\n    pub fn f() {}\n}\nfn g<Foo>() {\n    Foo::f(); // This use of `Foo` resolves to the module, not the type parameter\n}\n```\n\nThis PR changes `resolve_item_in_lexical_scope` so that it fails when the item is shadowed by a rib (fixes #32120).\nThis is a [breaking-change], but it looks unlikely to cause breakage in practice.\n\nr? @nikomatsakis"
  },
  {
    "hash": "5807fbbfde3ad04820f6fa0269711c81538057ec",
    "author": "bors",
    "date": 1457717207,
    "message": "Auto merge of #32134 - jseyfried:forbid_type_alias_as_module, r=nikomatsakis\n\nForbid glob-importing from a type alias\n\nThis PR forbids glob-importing from a type alias or trait (fixes #30560):\n```rust\ntype Alias = ();\nuse Alias::*; // This is currently allowed but shouldn't be\n```\n\nThis is a [breaking-change]. Since the disallowed glob imports don't actually import anything, any breakage can be fixed by removing the offending glob import.\n\nr? @alexcrichton"
  },
  {
    "hash": "bcda58f49133921abd091d7f800732fe2c4e5a98",
    "author": "bors",
    "date": 1457583380,
    "message": "Auto merge of #31710 - eddyb:reify, r=nikomatsakis\n\nDistinguish fn item types to allow reification from nothing to fn pointers.\n\nThe first commit is a rebase of #26284, except for files that have moved since.\n\nThis is a [breaking-change], due to:\n* each FFI function has a distinct type, like all other functions currently do\n* all generic parameters on functions are recorded in their item types, e.g.:\n`size_of::<u8>` & `size_of::<i8>`'s types differ despite their identical signature.\n* function items are zero-sized, which will stop transmutes from working on them\n\nThe first two cases are handled in most cases with the new coerce-unify logic,\nwhich will combine incompatible function item types into function pointers,\nat the outer-most level of if-else chains, match arms and array literals.\n\nThe last case is specially handled during type-checking such that transmutes\nfrom a function item type to a pointer or integer type will continue to work for\nanother release cycle, but are being linted against. To get rid of warnings and\nensure your code will continue to compile, cast to a pointer before transmuting."
  },
  {
    "hash": "3a872782d396e9ed3827a515a54d1f0a634c0b77",
    "author": "Jonas Schievink",
    "date": 1455625960,
    "message": "Move more uses of `panictry!` out of libsyntax\n\n[breaking-change] for syntax extensions"
  },
  {
    "hash": "c5d58de665819f7330b3d64bdd084d25a412830a",
    "author": "Alex Burka",
    "date": 1456556501,
    "message": "core: add inclusive ranges to core::ops\n\nSince it removes the old iter::{range_inclusive, RangeInclusive} which\nwere unstable and deprecated, this is a [breaking-change] on nightly."
  },
  {
    "hash": "5b5e52186917502258a9feadc8bf77a89183386b",
    "author": "bors",
    "date": 1457074511,
    "message": "Auto merge of #32006 - jseyfried:fix_expanded_mod_path, r=nikomatsakis\n\nThis PR changes the search paths for macro-expanded non-inline modules so that they match ordinary non-inline modules (fixes #31624). This is a [breaking-change].\n\nRight now, the search paths for a macro-expanded non-inline module are computed as if the module were declared in the top level of the file in which the macro was defined.\nFor example, consider `./foo/mod.rs`:\n```rust\nmod inconsequential { // moving the macro outside this module wouldn't change anything\n    macro_rules! mod_decl {\n        ($i:ident) => { mod $i; }\n    }\n}\n```\nand `./lib.rs`:\n```rust\nmod foo;\n\nmod bar {\n    mod_decl!(baz);\n    //^ Now, rustc expects `./foo/baz.rs` (or `./foo/baz/mod.rs`)\n    //| After this PR, rustc will expect `./bar/baz.rs` (or `./bar/baz/mod.rs`)\n}\n```\nr? @alexcrichton"
  },
  {
    "hash": "7cee8b9ffb6a2dac7e2f729988c2324e2f8ac10f",
    "author": "bors",
    "date": 1456971688,
    "message": "Auto merge of #31824 - jseyfried:privacy_in_resolve, r=nikomatsakis\n\nThis PR privacy checks paths as they are resolved instead of in `librustc_privacy` (fixes #12334 and fixes #31779). This removes the need for the `LastPrivate` system introduced in PR #9735, the limitations of which cause #31779.\n\nThis PR also reports privacy violations in paths to intra- and inter-crate items the same way -- it always reports the first inaccessible segment of the path.\n\nSince it fixes #31779, this is a [breaking-change]. For example, the following code would break:\n```rust\nmod foo {\n    pub use foo::bar::S;\n    mod bar { // `bar` should be private to `foo`\n        pub struct S;\n    }\n}\n\nimpl foo::S {\n    fn f() {}\n}\n\nfn main() {\n    foo::bar::S::f(); // This is now a privacy error\n}\n```\n\nr? @alexcrichton"
  },
  {
    "hash": "acea6fc1cb5edf5211ade6ad4a79b119879eab82",
    "author": "Manish Goregaokar",
    "date": 1456486422,
    "message": "Rollup merge of #31904 - bluss:writer-formatter-error, r=alexcrichton\n\nMake sure formatter errors are emitted by the default Write::write_fmt\n\nPreviously, if an error was returned from the formatter that did not\noriginate in an underlying writer error, Write::write_fmt would return\nsuccessfully even if the formatting did not complete (was interrupted by\nan `fmt::Error` return).\n\nNow we choose to emit an io::Error with kind Other for formatter errors.\n\nSince this may reveal error returns from `write!()` and similar that\npreviously passed silently, it's a kind of a [breaking-change].\n\nFixes #31879"
  },
  {
    "hash": "6cfafad3c56736a62e1043a8d01f7f2c74384008",
    "author": "Ulrik Sverdrup",
    "date": 1456451965,
    "message": "Make sure formatter errors are emitted by the default Write::write_fmt\n\nPreviously, if an error was returned from the formatter that did not\noriginate in an underlying writer error, Write::write_fmt would return\nsuccessfully even if the formatting did not complete (was interrupted by\nan `fmt::Error` return).\n\nNow we choose to emit an io::Error with kind Other for formatter errors.\n\nSince this may reveal error returns from `write!()` and similar that\npreviously passed silently, it's a kind of a [breaking-change]."
  },
  {
    "hash": "9c6a0088fbdae5a6554c39f8db9207c1b878eb05",
    "author": "bors",
    "date": 1456461508,
    "message": "Auto merge of #31857 - jseyfried:fix_scoping, r=nikomatsakis\n\nThis fixes a bug (#31845) introduced in #31105 in which lexical scopes contain items from all anonymous module ancestors, even if the path to the anonymous module includes a normal module:\n```rust\nfn f() {\n    fn g() {}\n    mod foo {\n        fn h() {\n           g(); // This erroneously resolves on nightly\n        }\n    }\n}\n```\n\nThis is a [breaking-change] on nightly but not on stable or beta.\nr? @nikomatsakis"
  },
  {
    "hash": "9658645407c784105bb361297d5316cadc9ff2bd",
    "author": "bors",
    "date": 1455651297,
    "message": "Auto merge of #31534 - jseyfried:restrict_noninline_mod, r=nikomatsakis\n\nThis PR disallows non-inline modules without path annotations that are either in a block or in an inline module whose containing file is not a directory owner (fixes #29765).\nThis is a [breaking-change].\nr? @nikomatsakis"
  },
  {
    "hash": "9d98390765bbe61ce2a39b40c99ae1a68bb6d1cc",
    "author": "bors",
    "date": 1455430690,
    "message": "Auto merge of #31581 - petrochenkov:patrefact, r=Manishearth\n\ncc https://github.com/rust-lang/rust/pull/31487#issuecomment-182945101\nplugin-[breaking-change]\n\nThe first commit renames `ast::Pat_` to `ast::PatKind` and uses its variants in enum qualified form. I've also taken the opportunity and renamed `PatKind::Region` into `PatKind::Ref`.\n\nThe second commit splits `PatKind::Enum` into `PatKind::TupleStruct` and `PatKind::UnitStruct`.\nSo, pattern kinds now correspond to their struct/variant kinds - `Struct`, `TupleStruct` and `UnitStruct`.\n@nikomatsakis @nrc @arielb1 Are you okay with this naming scheme?\nAn alternative possible naming scheme is `PatKind::StructVariant`, `PatKind::TupleVariant`, `PatKind::UnitVariant` (it's probably closer to the common use, but I like it less).\n\nI intend to apply these changes to HIR later, they should not necessarily go in the same nightly with https://github.com/rust-lang/rust/pull/31487\nr? @Manishearth"
  },
  {
    "hash": "c7640aa2aaad857bbc9f9a1002f8e1aaf520752e",
    "author": "bors",
    "date": 1455288980,
    "message": "Auto merge of #31583 - petrochenkov:indi_ast, r=Manishearth\n\ncc #31487\nplugin-[breaking-change]\n\nThe AST part of https://github.com/rust-lang/rust/pull/30087\n\nr? @Manishearth"
  },
  {
    "hash": "2b816b0d6a9bc8210ca314a020a247f8632b4f38",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::PathListItem_ variants"
  },
  {
    "hash": "8b3856b1bc1c23969e5d8983f25cf85698a5c2b1",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::StrStyle variants"
  },
  {
    "hash": "d844bfb1967b780ff6cc6e81644bf4b529dc0738",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Visibility variants"
  },
  {
    "hash": "dfe35da6b83f64bb7553b19649839512a3c301ce",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::TraitItemKind variants"
  },
  {
    "hash": "73fa9b2da2ee82c91a5c8d605b91f22f19e4d74b",
    "author": "Oliver 'ker' Schneider",
    "date": 1455190488,
    "message": "[breaking-change] don't glob export ast::Mutablity variants"
  }
]
